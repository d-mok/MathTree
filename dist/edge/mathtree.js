var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var lib = {};
var data$1 = {};
var numbers$2 = {};
var list$2 = {};
Object.defineProperty(list$2, "__esModule", { value: true });
list$2.toList = list$2.list = list$2.List = void 0;
class List extends Array {
  create(elements) {
    let ls = new this.constructor();
    ls.push(...elements);
    return ls;
  }
  clear() {
    this.splice(0, this.length);
  }
  set(elements) {
    this.clear();
    this.push(...elements);
  }
  clone() {
    return this.create([...this]);
  }
  indexValid(index) {
    if (this.length === 0)
      return false;
    return index >= 0 && index <= this.length - 1;
  }
  isEmpty() {
    return this.length === 0;
  }
  first() {
    return this[0];
  }
  last() {
    return this[this.length - 1];
  }
  cyclicAt(index) {
    let n2 = this.length;
    if (n2 === 0)
      return void 0;
    while (index < 0) {
      index += n2;
    }
    while (index > n2 - 1) {
      index -= n2;
    }
    return this[index];
  }
  pull(index) {
    let n2 = this.length;
    if (n2 === 0)
      return void 0;
    while (index < 0)
      return void 0;
    while (index > n2 - 1)
      return void 0;
    let element = this[index];
    this.splice(index, 1);
    return element;
  }
  head(n2) {
    if (n2 <= 0)
      return this.create([]);
    return this.slice(0, n2);
  }
  tail(n2) {
    if (n2 <= 0)
      return this.create([]);
    return this.slice(-n2);
  }
  before(index) {
    if (index <= 0)
      return this.create([]);
    if (index >= this.length)
      return this.clone();
    return this.slice(0, index);
  }
  till(index) {
    return this.before(index + 1);
  }
  after(index) {
    if (index < 0)
      return this.clone();
    if (index >= this.length - 1)
      return this.create([]);
    return this.slice(index + 1);
  }
  since(index) {
    return this.after(index - 1);
  }
  chunk(size) {
    if (size <= 0)
      return List.of();
    let ls = List.of();
    for (let i2 = 0; i2 < this.length; i2 += size) {
      ls.push(this.slice(i2, i2 + size));
    }
    return ls;
  }
  split(delimitElement) {
    let ls = List.of();
    let clone2 = this.clone();
    while (true) {
      let firstDelimIndex = clone2.findIndex(($) => $ === delimitElement);
      if (firstDelimIndex === -1) {
        let head = clone2.splice(0);
        ls.push(this.create(head));
        break;
      } else {
        let head = clone2.splice(0, firstDelimIndex);
        ls.push(this.create(head));
        clone2.shift();
        if (clone2.length === 0) {
          ls.push(this.create([]));
          break;
        }
      }
    }
    return ls;
  }
  includesAll(elements) {
    return elements.every(($) => this.includes($));
  }
  includesAny(elements) {
    return elements.some(($) => this.includes($));
  }
  includesExact(elements) {
    let other = List.of(...elements);
    return this.includesAll(other) && this.belongs(other);
  }
  belongs(elements) {
    return this.every(($) => elements.includes($));
  }
  unique() {
    return this.create([...new Set(this)]);
  }
  uniqueBy(mapper) {
    let ls = this.create([]);
    let mapped = [];
    for (let ele of this) {
      let map = mapper(ele);
      let found = mapped.findIndex(($) => $ === map) !== -1;
      if (found)
        continue;
      ls.push(ele);
      mapped.push(map);
    }
    return ls;
  }
  uniqueDeep() {
    return this.uniqueBy(($) => JSON.stringify($));
  }
  freq(element) {
    return this.filter(($) => $ === element).length;
  }
  distincts() {
    return this.filter(($) => this.freq($) === 1);
  }
  duplicates() {
    let distincts = this.distincts();
    return this.except(distincts);
  }
  duplicated() {
    return this.duplicates().unique();
  }
  dupless() {
    return [...new Set(this)].length === this.length;
  }
  duplessDeep() {
    return this.uniqueDeep().length === this.length;
  }
  duppy() {
    return !this.dupless();
  }
  dedup() {
    this.set(this.unique());
  }
  violate(predicate) {
    return this.filter(($) => !predicate($));
  }
  inside(elements) {
    return this.filter(($) => elements.includes($));
  }
  except(elements) {
    return this.filter(($) => !elements.includes($));
  }
  filterIndex(predicate) {
    let ls = this.create([]);
    for (let i2 = 0; i2 < this.length; i2++) {
      if (predicate(i2))
        ls.push(this[i2]);
    }
    return ls;
  }
  countIf(predicate) {
    return this.filter(predicate).length;
  }
  sieve(predicate) {
    this.set(this.filter(predicate));
  }
  reject(predicate) {
    this.set(this.violate(predicate));
  }
  keep(elements) {
    this.set(this.inside(elements));
  }
  drop(elements) {
    this.set(this.except(elements));
  }
  reversed() {
    let ls = this.clone();
    ls.reverse();
    return ls;
  }
  ascending() {
    let ls = this.clone();
    ls.ascend();
    return ls;
  }
  descending() {
    let ls = this.clone();
    ls.descend();
    return ls;
  }
  sorted(...compareFns) {
    let ls = this.clone();
    ls.sorts(...compareFns);
    return ls;
  }
  sortedBy(...mappers) {
    let ls = this.clone();
    ls.sortBy(...mappers);
    return ls;
  }
  sortedByFreq() {
    return this.sortedBy(($) => -this.freq($));
  }
  ascend() {
    if (this.every(($) => typeof $ === "number")) {
      this.sortBy(($) => Number($));
    } else {
      this.sortBy(($) => String($));
    }
  }
  descend() {
    this.ascend();
    this.reverse();
  }
  arrange(newIndices) {
    let newArr = Array(this.length);
    for (let i2 = 0; i2 < this.length; i2++) {
      const newIndex = newIndices[i2];
      newArr[newIndex] = this[i2];
    }
    this.set(newArr);
  }
  permute(newOrder) {
    let newArr = Array(this.length);
    for (let i2 = 0; i2 < this.length; i2++) {
      const newIndex = newOrder[i2];
      newArr[i2] = this[newIndex];
    }
    this.set(newArr);
  }
  sorts(...compareFns) {
    function compare(a2, b2) {
      for (let fn of compareFns) {
        let v2 = fn(a2, b2);
        if (v2 > 0)
          return 1;
        if (v2 < 0)
          return -1;
      }
      return 0;
    }
    this.sort(compare);
  }
  sortBy(...mappers) {
    const compareFns = mappers.map((m2) => function(a2, b2) {
      const va = m2(a2);
      const vb = m2(b2);
      return va === vb ? 0 : va > vb ? 1 : -1;
    });
    this.sorts(...compareFns);
  }
  cycle(n2) {
    if (this.length === 0)
      return;
    if (n2 === 0)
      return;
    if (n2 > 0) {
      for (let i2 = 1; i2 <= n2; i2++) {
        this.push(this.shift());
      }
    }
    if (n2 < 0) {
      n2 = Math.abs(n2);
      for (let i2 = 1; i2 <= n2; i2++) {
        this.unshift(this.pop());
      }
    }
  }
  randomIndex() {
    if (this.length === 0)
      return void 0;
    function rndInt(min2, max2) {
      return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
    }
    return rndInt(0, this.length - 1);
  }
  draw() {
    if (this.length === 0)
      return void 0;
    return this[this.randomIndex()];
  }
  draws(n2) {
    if (this.length === 0)
      return void 0;
    let arr = this.create([]);
    for (let i2 = 0; i2 < n2; i2++) {
      arr.push(this.draw());
    }
    return arr;
  }
  sample(n2) {
    if (n2 > this.length)
      return void 0;
    let ls = this.shuffled();
    ls.length = n2;
    return ls;
  }
  shuffled() {
    let ls = this.clone();
    ls.shuffle();
    return ls;
  }
  deal() {
    if (this.length === 0)
      return void 0;
    return this.pull(this.randomIndex());
  }
  shuffle() {
    for (let i2 = this.length - 1; i2 > 0; i2--) {
      let j2 = Math.floor(Math.random() * (i2 + 1));
      [this[i2], this[j2]] = [this[j2], this[i2]];
    }
  }
  combinations(k2) {
    if (k2 > this.length || k2 <= 0)
      return List.of();
    if (k2 === this.length)
      return List.of(this);
    if (k2 === 1)
      return List.of(...this.map(($) => this.create([$])));
    const combs = List.of();
    let tail_combs = List.of();
    for (let i2 = 0; i2 <= this.length - k2 + 1; i2++) {
      let tail = this.after(i2);
      tail_combs = tail.combinations(k2 - 1);
      for (let j2 = 0; j2 < tail_combs.length; j2++) {
        combs.push(this.create([this[i2], ...tail_combs[j2]]));
      }
    }
    return combs;
  }
  pairs() {
    return this.combinations(2);
  }
  permutations() {
    if (this.length === 0)
      return List.of();
    if (this.length === 1)
      return List.of(this);
    if (this.length === 2) {
      let [a2, b2] = this;
      return List.of(this.create([a2, b2]), this.create([b2, a2]));
    }
    const perm = List.of();
    for (let i2 = 0; i2 < this.length; i2++) {
      let clone2 = this.clone();
      let pulled = clone2.pull(i2);
      for (let p2 of clone2.permutations()) {
        perm.push(this.create([pulled, ...p2]));
      }
    }
    return perm;
  }
  zip(array2, mapper) {
    let ls = new List();
    for (let i2 = 0; i2 < this.length; i2++) {
      ls.push(mapper(this[i2], array2[i2]));
    }
    return ls;
  }
  meanOf(metric) {
    let metrics = this.map(metric);
    let sum2 = metrics.reduce((a2, b2) => a2 + b2, 0);
    return sum2 / metrics.length;
  }
  maxOf(metric, rank = 1) {
    var _a;
    if (this.length === 0)
      return NaN;
    if (rank === 1) {
      return this.map(metric).descending().first();
    } else {
      let sortedMetrics = this.map(metric).unique().descending();
      return (_a = sortedMetrics[rank - 1]) != null ? _a : NaN;
    }
  }
  minOf(metric, rank = 1) {
    var _a;
    if (this.length === 0)
      return NaN;
    if (rank === 1) {
      return this.map(metric).ascending().first();
    } else {
      let sortedMetrics = this.map(metric).unique().ascending();
      return (_a = sortedMetrics[rank - 1]) != null ? _a : NaN;
    }
  }
  maxsBy(metric, rank = 1) {
    let max2 = this.maxOf(metric, rank);
    return this.filter(($) => metric($) === max2);
  }
  minsBy(metric, rank = 1) {
    let min2 = this.minOf(metric, rank);
    return this.filter(($) => metric($) === min2);
  }
  maxBy(metric, rank = 1) {
    if (this.length === 0)
      return void 0;
    return this.maxsBy(metric, rank).first();
  }
  minBy(metric, rank = 1) {
    if (this.length === 0)
      return void 0;
    return this.minsBy(metric, rank).first();
  }
  padTail(length) {
    if (length <= this.length)
      return this.clone();
    if (this.length === 0)
      return this.clone();
    let last = this.last();
    let clone2 = this.clone();
    for (let i2 = clone2.length; i2 < length; i2++) {
      clone2.push(last);
    }
    return clone2;
  }
  padHead(length) {
    if (length <= this.length)
      return this.clone();
    if (this.length === 0)
      return this.clone();
    let first = this.first();
    let clone2 = this.create([]);
    for (let i2 = 0; i2 < length - this.length; i2++) {
      clone2.push(first);
    }
    clone2.push(...this);
    return clone2;
  }
  padCyclic(length) {
    if (length <= this.length)
      return this.clone();
    if (this.length === 0)
      return this.clone();
    let clone2 = this.create([]);
    for (let i2 = 0; i2 < length; i2++) {
      clone2.push(this.cyclicAt(i2));
    }
    return clone2;
  }
}
list$2.List = List;
function list$1(...elements) {
  let ls = new List();
  ls.push(...elements);
  return ls;
}
list$2.list = list$1;
function toList$1(elements) {
  return list$1(...elements);
}
list$2.toList = toList$1;
var cal$3 = {};
var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
}, inexact, quadrant$1, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s < 0)
    x2.s = 1;
  return finalise(x2);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k2, x2 = this, Ctor = x2.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k2 = x2.cmp(min2);
  return k2 < 0 ? min2 : x2.cmp(max2) > 0 ? max2 : new Ctor(x2);
};
P.comparedTo = P.cmp = function(y2) {
  var i2, j2, xdL, ydL, x2 = this, xd = x2.d, yd = (y2 = new x2.constructor(y2)).d, xs = x2.s, ys = y2.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x2.e !== y2.e)
    return x2.e > y2.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i2 = 0, j2 = xdL < ydL ? xdL : ydL; i2 < j2; ++i2) {
    if (xd[i2] !== yd[i2])
      return xd[i2] > yd[i2] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.d)
    return new Ctor(NaN);
  if (!x2.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x2.e, x2.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x2 = cosine(Ctor, toLessThanHalfPi(Ctor, x2));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant$1 == 2 || quadrant$1 == 3 ? x2.neg() : x2, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e2, m2, n2, r2, rep, s2, sd, t2, t3, t3plusx, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero())
    return new Ctor(x2);
  external = false;
  s2 = x2.s * mathpow(x2.s * x2, 1 / 3);
  if (!s2 || Math.abs(s2) == 1 / 0) {
    n2 = digitsToString(x2.d);
    e2 = x2.e;
    if (s2 = (e2 - n2.length + 1) % 3)
      n2 += s2 == 1 || s2 == -2 ? "0" : "00";
    s2 = mathpow(n2, 1 / 3);
    e2 = mathfloor((e2 + 1) / 3) - (e2 % 3 == (e2 < 0 ? -1 : 2));
    if (s2 == 1 / 0) {
      n2 = "5e" + e2;
    } else {
      n2 = s2.toExponential();
      n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
    }
    r2 = new Ctor(n2);
    r2.s = x2.s;
  } else {
    r2 = new Ctor(s2.toString());
  }
  sd = (e2 = Ctor.precision) + 3;
  for (; ; ) {
    t2 = r2;
    t3 = t2.times(t2).times(t2);
    t3plusx = t3.plus(x2);
    r2 = divide(t3plusx.plus(x2).times(t2), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t2.d).slice(0, sd) === (n2 = digitsToString(r2.d)).slice(0, sd)) {
      n2 = n2.slice(sd - 3, sd + 1);
      if (n2 == "9999" || !rep && n2 == "4999") {
        if (!rep) {
          finalise(t2, e2 + 1, 0);
          if (t2.times(t2).times(t2).eq(x2)) {
            r2 = t2;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
          finalise(r2, e2 + 1, 1);
          m2 = !r2.times(r2).times(r2).eq(x2);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r2, e2, Ctor.rounding, m2);
};
P.decimalPlaces = P.dp = function() {
  var w2, d2 = this.d, n2 = NaN;
  if (d2) {
    w2 = d2.length - 1;
    n2 = (w2 - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w2 = d2[w2];
    if (w2)
      for (; w2 % 10 == 0; w2 /= 10)
        n2--;
    if (n2 < 0)
      n2 = 0;
  }
  return n2;
};
P.dividedBy = P.div = function(y2) {
  return divide(this, new this.constructor(y2));
};
P.dividedToIntegerBy = P.divToInt = function(y2) {
  var x2 = this, Ctor = x2.constructor;
  return finalise(divide(x2, new Ctor(y2), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y2) {
  return this.cmp(y2) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y2) {
  var k2 = this.cmp(y2);
  return k2 == 1 || k2 === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k2, n2, pr, rm, len, x2 = this, Ctor = x2.constructor, one = new Ctor(1);
  if (!x2.isFinite())
    return new Ctor(x2.s ? 1 / 0 : NaN);
  if (x2.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x2.e, x2.sd()) + 4;
  Ctor.rounding = 1;
  len = x2.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    n2 = (1 / tinyPow(4, k2)).toString();
  } else {
    k2 = 16;
    n2 = "2.3283064365386962890625e-10";
  }
  x2 = taylorSeries(Ctor, 1, x2.times(n2), new Ctor(1), true);
  var cosh2_x, i2 = k2, d8 = new Ctor(8);
  for (; i2--; ) {
    cosh2_x = x2.times(x2);
    x2 = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x2, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k2, pr, rm, len, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x2.e, x2.sd()) + 4;
  Ctor.rounding = 1;
  len = x2.d.length;
  if (len < 3) {
    x2 = taylorSeries(Ctor, 2, x2, x2, true);
  } else {
    k2 = 1.4 * Math.sqrt(len);
    k2 = k2 > 16 ? 16 : k2 | 0;
    x2 = x2.times(1 / tinyPow(5, k2));
    x2 = taylorSeries(Ctor, 2, x2, x2, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k2--; ) {
      sinh2_x = x2.times(x2);
      x2 = x2.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x2, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite())
    return new Ctor(x2.s);
  if (x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x2.sinh(), x2.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x2 = this, Ctor = x2.constructor, k2 = x2.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k2 !== -1) {
    return k2 === 0 ? x2.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x2.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x2 = x2.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x2);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (x2.lte(1))
    return new Ctor(x2.eq(1) ? 0 : NaN);
  if (!x2.isFinite())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x2.e), x2.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x2 = x2.times(x2).minus(1).sqrt().plus(x2);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x2.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x2.e), x2.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x2 = x2.times(x2).plus(1).sqrt().plus(x2);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x2.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite())
    return new Ctor(NaN);
  if (x2.e >= 0)
    return new Ctor(x2.abs().eq(1) ? x2.s / 0 : x2.isZero() ? x2 : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x2.sd();
  if (Math.max(xsd, pr) < 2 * -x2.e - 1)
    return finalise(new Ctor(x2), pr, rm, true);
  Ctor.precision = wpr = xsd - x2.e;
  x2 = divide(x2.plus(1), new Ctor(1).minus(x2), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x2 = x2.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x2.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k2, pr, rm, x2 = this, Ctor = x2.constructor;
  if (x2.isZero())
    return new Ctor(x2);
  k2 = x2.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k2 !== -1) {
    if (k2 === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x2.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x2 = x2.div(new Ctor(1).minus(x2.times(x2)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x2.times(2);
};
P.inverseTangent = P.atan = function() {
  var i2, j2, k2, n2, px, t2, r2, wpr, x2, x3 = this, Ctor = x3.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x3.isFinite()) {
    if (!x3.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r2 = getPi(Ctor, pr + 4, rm).times(0.5);
      r2.s = x3.s;
      return r2;
    }
  } else if (x3.isZero()) {
    return new Ctor(x3);
  } else if (x3.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r2 = getPi(Ctor, pr + 4, rm).times(0.25);
    r2.s = x3.s;
    return r2;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k2 = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i2 = k2; i2; --i2)
    x3 = x3.div(x3.times(x3).plus(1).sqrt().plus(1));
  external = false;
  j2 = Math.ceil(wpr / LOG_BASE);
  n2 = 1;
  x2 = x3.times(x3);
  r2 = new Ctor(x3);
  px = x3;
  for (; i2 !== -1; ) {
    px = px.times(x2);
    t2 = r2.minus(px.div(n2 += 2));
    px = px.times(x2);
    r2 = t2.plus(px.div(n2 += 2));
    if (r2.d[j2] !== void 0)
      for (i2 = j2; r2.d[i2] === t2.d[i2] && i2--; )
        ;
  }
  if (k2)
    r2 = r2.times(2 << k2 - 1);
  external = true;
  return finalise(r2, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P.logarithm = P.log = function(base2) {
  var isBase10, d2, denominator, k2, inf, num2, sd, r2, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base2 == null) {
    base2 = new Ctor(10);
    isBase10 = true;
  } else {
    base2 = new Ctor(base2);
    d2 = base2.d;
    if (base2.s < 0 || !d2 || !d2[0] || base2.eq(1))
      return new Ctor(NaN);
    isBase10 = base2.eq(10);
  }
  d2 = arg.d;
  if (arg.s < 0 || !d2 || !d2[0] || arg.eq(1)) {
    return new Ctor(d2 && !d2[0] ? -1 / 0 : arg.s != 1 ? NaN : d2 ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d2.length > 1) {
      inf = true;
    } else {
      for (k2 = d2[0]; k2 % 10 === 0; )
        k2 /= 10;
      inf = k2 !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num2 = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
  r2 = divide(num2, denominator, sd, 1);
  if (checkRoundingDigits(r2.d, k2 = pr, rm)) {
    do {
      sd += 10;
      num2 = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
      r2 = divide(num2, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r2.d).slice(k2 + 1, k2 + 15) + 1 == 1e14) {
          r2 = finalise(r2, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r2.d, k2 += 10, rm));
  }
  external = true;
  return finalise(r2, pr, rm);
};
P.minus = P.sub = function(y2) {
  var d2, e2, i2, j2, k2, len, pr, rm, xd, xe, xLTy, yd, x2 = this, Ctor = x2.constructor;
  y2 = new Ctor(y2);
  if (!x2.d || !y2.d) {
    if (!x2.s || !y2.s)
      y2 = new Ctor(NaN);
    else if (x2.d)
      y2.s = -y2.s;
    else
      y2 = new Ctor(y2.d || x2.s !== y2.s ? x2 : NaN);
    return y2;
  }
  if (x2.s != y2.s) {
    y2.s = -y2.s;
    return x2.plus(y2);
  }
  xd = x2.d;
  yd = y2.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y2.s = -y2.s;
    else if (xd[0])
      y2 = new Ctor(x2);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y2, pr, rm) : y2;
  }
  e2 = mathfloor(y2.e / LOG_BASE);
  xe = mathfloor(x2.e / LOG_BASE);
  xd = xd.slice();
  k2 = xe - e2;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d2 = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d2 = yd;
      e2 = xe;
      len = xd.length;
    }
    i2 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k2 > i2) {
      k2 = i2;
      d2.length = 1;
    }
    d2.reverse();
    for (i2 = k2; i2--; )
      d2.push(0);
    d2.reverse();
  } else {
    i2 = xd.length;
    len = yd.length;
    xLTy = i2 < len;
    if (xLTy)
      len = i2;
    for (i2 = 0; i2 < len; i2++) {
      if (xd[i2] != yd[i2]) {
        xLTy = xd[i2] < yd[i2];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d2 = xd;
    xd = yd;
    yd = d2;
    y2.s = -y2.s;
  }
  len = xd.length;
  for (i2 = yd.length - len; i2 > 0; --i2)
    xd[len++] = 0;
  for (i2 = yd.length; i2 > k2; ) {
    if (xd[--i2] < yd[i2]) {
      for (j2 = i2; j2 && xd[--j2] === 0; )
        xd[j2] = BASE - 1;
      --xd[j2];
      xd[i2] += BASE;
    }
    xd[i2] -= yd[i2];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e2;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y2.d = xd;
  y2.e = getBase10Exponent(xd, e2);
  return external ? finalise(y2, pr, rm) : y2;
};
P.modulo = P.mod = function(y2) {
  var q2, x2 = this, Ctor = x2.constructor;
  y2 = new Ctor(y2);
  if (!x2.d || !y2.s || y2.d && !y2.d[0])
    return new Ctor(NaN);
  if (!y2.d || x2.d && !x2.d[0]) {
    return finalise(new Ctor(x2), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q2 = divide(x2, y2.abs(), 0, 3, 1);
    q2.s *= y2.s;
  } else {
    q2 = divide(x2, y2, 0, Ctor.modulo, 1);
  }
  q2 = q2.times(y2);
  external = true;
  return x2.minus(q2);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s;
  return finalise(x2);
};
P.plus = P.add = function(y2) {
  var carry, d2, e2, i2, k2, len, pr, rm, xd, yd, x2 = this, Ctor = x2.constructor;
  y2 = new Ctor(y2);
  if (!x2.d || !y2.d) {
    if (!x2.s || !y2.s)
      y2 = new Ctor(NaN);
    else if (!x2.d)
      y2 = new Ctor(y2.d || x2.s === y2.s ? x2 : NaN);
    return y2;
  }
  if (x2.s != y2.s) {
    y2.s = -y2.s;
    return x2.minus(y2);
  }
  xd = x2.d;
  yd = y2.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y2 = new Ctor(x2);
    return external ? finalise(y2, pr, rm) : y2;
  }
  k2 = mathfloor(x2.e / LOG_BASE);
  e2 = mathfloor(y2.e / LOG_BASE);
  xd = xd.slice();
  i2 = k2 - e2;
  if (i2) {
    if (i2 < 0) {
      d2 = xd;
      i2 = -i2;
      len = yd.length;
    } else {
      d2 = yd;
      e2 = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i2 > len) {
      i2 = len;
      d2.length = 1;
    }
    d2.reverse();
    for (; i2--; )
      d2.push(0);
    d2.reverse();
  }
  len = xd.length;
  i2 = yd.length;
  if (len - i2 < 0) {
    i2 = len;
    d2 = yd;
    yd = xd;
    xd = d2;
  }
  for (carry = 0; i2; ) {
    carry = (xd[--i2] = xd[i2] + yd[i2] + carry) / BASE | 0;
    xd[i2] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e2;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y2.d = xd;
  y2.e = getBase10Exponent(xd, e2);
  return external ? finalise(y2, pr, rm) : y2;
};
P.precision = P.sd = function(z2) {
  var k2, x2 = this;
  if (z2 !== void 0 && z2 !== !!z2 && z2 !== 1 && z2 !== 0)
    throw Error(invalidArgument + z2);
  if (x2.d) {
    k2 = getPrecision(x2.d);
    if (z2 && x2.e + 1 > k2)
      k2 = x2.e + 1;
  } else {
    k2 = NaN;
  }
  return k2;
};
P.round = function() {
  var x2 = this, Ctor = x2.constructor;
  return finalise(new Ctor(x2), x2.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite())
    return new Ctor(NaN);
  if (x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x2.e, x2.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x2 = sine(Ctor, toLessThanHalfPi(Ctor, x2));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant$1 > 2 ? x2.neg() : x2, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m2, n2, sd, r2, rep, t2, x2 = this, d2 = x2.d, e2 = x2.e, s2 = x2.s, Ctor = x2.constructor;
  if (s2 !== 1 || !d2 || !d2[0]) {
    return new Ctor(!s2 || s2 < 0 && (!d2 || d2[0]) ? NaN : d2 ? x2 : 1 / 0);
  }
  external = false;
  s2 = Math.sqrt(+x2);
  if (s2 == 0 || s2 == 1 / 0) {
    n2 = digitsToString(d2);
    if ((n2.length + e2) % 2 == 0)
      n2 += "0";
    s2 = Math.sqrt(n2);
    e2 = mathfloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
    if (s2 == 1 / 0) {
      n2 = "5e" + e2;
    } else {
      n2 = s2.toExponential();
      n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
    }
    r2 = new Ctor(n2);
  } else {
    r2 = new Ctor(s2.toString());
  }
  sd = (e2 = Ctor.precision) + 3;
  for (; ; ) {
    t2 = r2;
    r2 = t2.plus(divide(x2, t2, sd + 2, 1)).times(0.5);
    if (digitsToString(t2.d).slice(0, sd) === (n2 = digitsToString(r2.d)).slice(0, sd)) {
      n2 = n2.slice(sd - 3, sd + 1);
      if (n2 == "9999" || !rep && n2 == "4999") {
        if (!rep) {
          finalise(t2, e2 + 1, 0);
          if (t2.times(t2).eq(x2)) {
            r2 = t2;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
          finalise(r2, e2 + 1, 1);
          m2 = !r2.times(r2).eq(x2);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r2, e2, Ctor.rounding, m2);
};
P.tangent = P.tan = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite())
    return new Ctor(NaN);
  if (x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x2 = x2.sin();
  x2.s = 1;
  x2 = divide(x2, new Ctor(1).minus(x2.times(x2)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant$1 == 2 || quadrant$1 == 4 ? x2.neg() : x2, pr, rm, true);
};
P.times = P.mul = function(y2) {
  var carry, e2, i2, k2, r2, rL, t2, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y2 = new Ctor(y2)).d;
  y2.s *= x2.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y2.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y2.s / 0 : y2.s * 0);
  }
  e2 = mathfloor(x2.e / LOG_BASE) + mathfloor(y2.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r2 = xd;
    xd = yd;
    yd = r2;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r2 = [];
  rL = xdL + ydL;
  for (i2 = rL; i2--; )
    r2.push(0);
  for (i2 = ydL; --i2 >= 0; ) {
    carry = 0;
    for (k2 = xdL + i2; k2 > i2; ) {
      t2 = r2[k2] + yd[i2] * xd[k2 - i2 - 1] + carry;
      r2[k2--] = t2 % BASE | 0;
      carry = t2 / BASE | 0;
    }
    r2[k2] = (r2[k2] + carry) % BASE | 0;
  }
  for (; !r2[--rL]; )
    r2.pop();
  if (carry)
    ++e2;
  else
    r2.shift();
  y2.d = r2;
  y2.e = getBase10Exponent(r2, e2);
  return external ? finalise(y2, Ctor.precision, Ctor.rounding) : y2;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp2, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp2 === void 0)
    return x2;
  checkInt32(dp2, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x2, dp2 + x2.e + 1, rm);
};
P.toExponential = function(dp2, rm) {
  var str2, x2 = this, Ctor = x2.constructor;
  if (dp2 === void 0) {
    str2 = finiteToString(x2, true);
  } else {
    checkInt32(dp2, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = finalise(new Ctor(x2), dp2 + 1, rm);
    str2 = finiteToString(x2, true, dp2 + 1);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str2 : str2;
};
P.toFixed = function(dp2, rm) {
  var str2, y2, x2 = this, Ctor = x2.constructor;
  if (dp2 === void 0) {
    str2 = finiteToString(x2);
  } else {
    checkInt32(dp2, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y2 = finalise(new Ctor(x2), dp2 + x2.e + 1, rm);
    str2 = finiteToString(y2, false, dp2 + y2.e + 1);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str2 : str2;
};
P.toFraction = function(maxD) {
  var d2, d0, d1, d22, e2, k2, n2, n0, n1, pr, q2, r2, x2 = this, xd = x2.d, Ctor = x2.constructor;
  if (!xd)
    return new Ctor(x2);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d2 = new Ctor(d1);
  e2 = d2.e = getPrecision(xd) - x2.e - 1;
  k2 = e2 % LOG_BASE;
  d2.d[0] = mathpow(10, k2 < 0 ? LOG_BASE + k2 : k2);
  if (maxD == null) {
    maxD = e2 > 0 ? d2 : n1;
  } else {
    n2 = new Ctor(maxD);
    if (!n2.isInt() || n2.lt(n1))
      throw Error(invalidArgument + n2);
    maxD = n2.gt(d2) ? e2 > 0 ? d2 : n1 : n2;
  }
  external = false;
  n2 = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e2 = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q2 = divide(n2, d2, 0, 1, 1);
    d22 = d0.plus(q2.times(d1));
    if (d22.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d22;
    d22 = n1;
    n1 = n0.plus(q2.times(d22));
    n0 = d22;
    d22 = d2;
    d2 = n2.minus(q2.times(d22));
    n2 = d22;
  }
  d22 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d22.times(n1));
  d0 = d0.plus(d22.times(d1));
  n0.s = n1.s = x2.s;
  r2 = divide(n1, d1, e2, 1).minus(x2).abs().cmp(divide(n0, d0, e2, 1).minus(x2).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r2;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y2, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (y2 == null) {
    if (!x2.d)
      return x2;
    y2 = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y2 = new Ctor(y2);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x2.d)
      return y2.s ? x2 : y2;
    if (!y2.d) {
      if (y2.s)
        y2.s = x2.s;
      return y2;
    }
  }
  if (y2.d[0]) {
    external = false;
    x2 = divide(x2, y2, 0, rm, 1).times(y2);
    external = true;
    finalise(x2);
  } else {
    y2.s = x2.s;
    x2 = y2;
  }
  return x2;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y2) {
  var e2, k2, pr, r2, rm, s2, x2 = this, Ctor = x2.constructor, yn = +(y2 = new Ctor(y2));
  if (!x2.d || !y2.d || !x2.d[0] || !y2.d[0])
    return new Ctor(mathpow(+x2, yn));
  x2 = new Ctor(x2);
  if (x2.eq(1))
    return x2;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y2.eq(1))
    return finalise(x2, pr, rm);
  e2 = mathfloor(y2.e / LOG_BASE);
  if (e2 >= y2.d.length - 1 && (k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r2 = intPow(Ctor, x2, k2, pr);
    return y2.s < 0 ? new Ctor(1).div(r2) : finalise(r2, pr, rm);
  }
  s2 = x2.s;
  if (s2 < 0) {
    if (e2 < y2.d.length - 1)
      return new Ctor(NaN);
    if ((y2.d[e2] & 1) == 0)
      s2 = 1;
    if (x2.e == 0 && x2.d[0] == 1 && x2.d.length == 1) {
      x2.s = s2;
      return x2;
    }
  }
  k2 = mathpow(+x2, yn);
  e2 = k2 == 0 || !isFinite(k2) ? mathfloor(yn * (Math.log("0." + digitsToString(x2.d)) / Math.LN10 + x2.e + 1)) : new Ctor(k2 + "").e;
  if (e2 > Ctor.maxE + 1 || e2 < Ctor.minE - 1)
    return new Ctor(e2 > 0 ? s2 / 0 : 0);
  external = false;
  Ctor.rounding = x2.s = 1;
  k2 = Math.min(12, (e2 + "").length);
  r2 = naturalExponential(y2.times(naturalLogarithm(x2, pr + k2)), pr);
  if (r2.d) {
    r2 = finalise(r2, pr + 5, 1);
    if (checkRoundingDigits(r2.d, pr, rm)) {
      e2 = pr + 10;
      r2 = finalise(naturalExponential(y2.times(naturalLogarithm(x2, e2 + k2)), e2), e2 + 5, 1);
      if (+digitsToString(r2.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r2 = finalise(r2, pr + 1, 0);
      }
    }
  }
  r2.s = s2;
  external = true;
  Ctor.rounding = rm;
  return finalise(r2, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str2, x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    str2 = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = finalise(new Ctor(x2), sd, rm);
    str2 = finiteToString(x2, sd <= x2.e || x2.e <= Ctor.toExpNeg, sd);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str2 : str2;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x2), sd, rm);
};
P.toString = function() {
  var x2 = this, Ctor = x2.constructor, str2 = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  return x2.isNeg() && !x2.isZero() ? "-" + str2 : str2;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x2 = this, Ctor = x2.constructor, str2 = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  return x2.isNeg() ? "-" + str2 : str2;
};
function digitsToString(d2) {
  var i2, k2, ws, indexOfLastWord = d2.length - 1, str2 = "", w2 = d2[0];
  if (indexOfLastWord > 0) {
    str2 += w2;
    for (i2 = 1; i2 < indexOfLastWord; i2++) {
      ws = d2[i2] + "";
      k2 = LOG_BASE - ws.length;
      if (k2)
        str2 += getZeroString(k2);
      str2 += ws;
    }
    w2 = d2[i2];
    ws = w2 + "";
    k2 = LOG_BASE - ws.length;
    if (k2)
      str2 += getZeroString(k2);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; )
    w2 /= 10;
  return str2 + w2;
}
function checkInt32(i2, min2, max2) {
  if (i2 !== ~~i2 || i2 < min2 || i2 > max2) {
    throw Error(invalidArgument + i2);
  }
}
function checkRoundingDigits(d2, i2, rm, repeating) {
  var di, k2, r2, rd;
  for (k2 = d2[0]; k2 >= 10; k2 /= 10)
    --i2;
  if (--i2 < 0) {
    i2 += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i2 + 1) / LOG_BASE);
    i2 %= LOG_BASE;
  }
  k2 = mathpow(10, LOG_BASE - i2);
  rd = d2[di] % k2 | 0;
  if (repeating == null) {
    if (i2 < 3) {
      if (i2 == 0)
        rd = rd / 100 | 0;
      else if (i2 == 1)
        rd = rd / 10 | 0;
      r2 = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r2 = (rm < 4 && rd + 1 == k2 || rm > 3 && rd + 1 == k2 / 2) && (d2[di + 1] / k2 / 100 | 0) == mathpow(10, i2 - 2) - 1 || (rd == k2 / 2 || rd == 0) && (d2[di + 1] / k2 / 100 | 0) == 0;
    }
  } else {
    if (i2 < 4) {
      if (i2 == 0)
        rd = rd / 1e3 | 0;
      else if (i2 == 1)
        rd = rd / 100 | 0;
      else if (i2 == 2)
        rd = rd / 10 | 0;
      r2 = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r2 = ((repeating || rm < 4) && rd + 1 == k2 || !repeating && rm > 3 && rd + 1 == k2 / 2) && (d2[di + 1] / k2 / 1e3 | 0) == mathpow(10, i2 - 3) - 1;
    }
  }
  return r2;
}
function convertBase(str2, baseIn, baseOut) {
  var j2, arr = [0], arrL, i2 = 0, strL = str2.length;
  for (; i2 < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str2.charAt(i2++));
    for (j2 = 0; j2 < arr.length; j2++) {
      if (arr[j2] > baseOut - 1) {
        if (arr[j2 + 1] === void 0)
          arr[j2 + 1] = 0;
        arr[j2 + 1] += arr[j2] / baseOut | 0;
        arr[j2] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x2) {
  var k2, len, y2;
  if (x2.isZero())
    return x2;
  len = x2.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    y2 = (1 / tinyPow(4, k2)).toString();
  } else {
    k2 = 16;
    y2 = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k2;
  x2 = taylorSeries(Ctor, 1, x2.times(y2), new Ctor(1));
  for (var i2 = k2; i2--; ) {
    var cos2x = x2.times(x2);
    x2 = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k2;
  return x2;
}
var divide = function() {
  function multiplyInteger(x2, k2, base2) {
    var temp, carry = 0, i2 = x2.length;
    for (x2 = x2.slice(); i2--; ) {
      temp = x2[i2] * k2 + carry;
      x2[i2] = temp % base2 | 0;
      carry = temp / base2 | 0;
    }
    if (carry)
      x2.unshift(carry);
    return x2;
  }
  function compare(a2, b2, aL, bL) {
    var i2, r2;
    if (aL != bL) {
      r2 = aL > bL ? 1 : -1;
    } else {
      for (i2 = r2 = 0; i2 < aL; i2++) {
        if (a2[i2] != b2[i2]) {
          r2 = a2[i2] > b2[i2] ? 1 : -1;
          break;
        }
      }
    }
    return r2;
  }
  function subtract(a2, b2, aL, base2) {
    var i2 = 0;
    for (; aL--; ) {
      a2[aL] -= i2;
      i2 = a2[aL] < b2[aL] ? 1 : 0;
      a2[aL] = i2 * base2 + a2[aL] - b2[aL];
    }
    for (; !a2[0] && a2.length > 1; )
      a2.shift();
  }
  return function(x2, y2, pr, rm, dp2, base2) {
    var cmp, e2, i2, k2, logBase, more, prod, prodL, q2, qd, rem, remL, rem0, sd, t2, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign2 = x2.s == y2.s ? 1 : -1, xd = x2.d, yd = y2.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!x2.s || !y2.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);
    }
    if (base2) {
      logBase = 1;
      e2 = x2.e - y2.e;
    } else {
      base2 = BASE;
      logBase = LOG_BASE;
      e2 = mathfloor(x2.e / logBase) - mathfloor(y2.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q2 = new Ctor(sign2);
    qd = q2.d = [];
    for (i2 = 0; yd[i2] == (xd[i2] || 0); i2++)
      ;
    if (yd[i2] > (xd[i2] || 0))
      e2--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp2) {
      sd = pr + (x2.e - y2.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i2 = 0;
      if (yL == 1) {
        k2 = 0;
        yd = yd[0];
        sd++;
        for (; (i2 < xL || k2) && sd--; i2++) {
          t2 = k2 * base2 + (xd[i2] || 0);
          qd[i2] = t2 / yd | 0;
          k2 = t2 % yd | 0;
        }
        more = k2 || i2 < xL;
      } else {
        k2 = base2 / (yd[0] + 1) | 0;
        if (k2 > 1) {
          yd = multiplyInteger(yd, k2, base2);
          xd = multiplyInteger(xd, k2, base2);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base2 / 2)
          ++yd0;
        do {
          k2 = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base2 + (rem[1] || 0);
            k2 = rem0 / yd0 | 0;
            if (k2 > 1) {
              if (k2 >= base2)
                k2 = base2 - 1;
              prod = multiplyInteger(yd, k2, base2);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k2--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base2);
              }
            } else {
              if (k2 == 0)
                cmp = k2 = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base2);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k2++;
                subtract(rem, yL < remL ? yz : yd, remL, base2);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k2++;
            rem = [0];
          }
          qd[i2++] = k2;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q2.e = e2;
      inexact = more;
    } else {
      for (i2 = 1, k2 = qd[0]; k2 >= 10; k2 /= 10)
        i2++;
      q2.e = i2 + e2 * logBase - 1;
      finalise(q2, dp2 ? pr + q2.e + 1 : pr, rm, more);
    }
    return q2;
  };
}();
function finalise(x2, sd, rm, isTruncated) {
  var digits, i2, j2, k2, rd, roundUp, w2, xd, xdi, Ctor = x2.constructor;
  out:
    if (sd != null) {
      xd = x2.d;
      if (!xd)
        return x2;
      for (digits = 1, k2 = xd[0]; k2 >= 10; k2 /= 10)
        digits++;
      i2 = sd - digits;
      if (i2 < 0) {
        i2 += LOG_BASE;
        j2 = sd;
        w2 = xd[xdi = 0];
        rd = w2 / mathpow(10, digits - j2 - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i2 + 1) / LOG_BASE);
        k2 = xd.length;
        if (xdi >= k2) {
          if (isTruncated) {
            for (; k2++ <= xdi; )
              xd.push(0);
            w2 = rd = 0;
            digits = 1;
            i2 %= LOG_BASE;
            j2 = i2 - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w2 = k2 = xd[xdi];
          for (digits = 1; k2 >= 10; k2 /= 10)
            digits++;
          i2 %= LOG_BASE;
          j2 = i2 - LOG_BASE + digits;
          rd = j2 < 0 ? 0 : w2 / mathpow(10, digits - j2 - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j2 < 0 ? w2 : w2 % mathpow(10, digits - j2 - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i2 > 0 ? j2 > 0 ? w2 / mathpow(10, digits - j2) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x2.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x2.e = -sd || 0;
        } else {
          xd[0] = x2.e = 0;
        }
        return x2;
      }
      if (i2 == 0) {
        xd.length = xdi;
        k2 = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k2 = mathpow(10, LOG_BASE - i2);
        xd[xdi] = j2 > 0 ? (w2 / mathpow(10, digits - j2) % mathpow(10, j2) | 0) * k2 : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i2 = 1, j2 = xd[0]; j2 >= 10; j2 /= 10)
              i2++;
            j2 = xd[0] += k2;
            for (k2 = 1; j2 >= 10; j2 /= 10)
              k2++;
            if (i2 != k2) {
              x2.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k2;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k2 = 1;
          }
        }
      }
      for (i2 = xd.length; xd[--i2] === 0; )
        xd.pop();
    }
  if (external) {
    if (x2.e > Ctor.maxE) {
      x2.d = null;
      x2.e = NaN;
    } else if (x2.e < Ctor.minE) {
      x2.e = 0;
      x2.d = [0];
    }
  }
  return x2;
}
function finiteToString(x2, isExp, sd) {
  if (!x2.isFinite())
    return nonFiniteToString(x2);
  var k2, e2 = x2.e, str2 = digitsToString(x2.d), len = str2.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str2 = str2.charAt(0) + "." + str2.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str2 = str2.charAt(0) + "." + str2.slice(1);
    }
    str2 = str2 + (x2.e < 0 ? "e" : "e+") + x2.e;
  } else if (e2 < 0) {
    str2 = "0." + getZeroString(-e2 - 1) + str2;
    if (sd && (k2 = sd - len) > 0)
      str2 += getZeroString(k2);
  } else if (e2 >= len) {
    str2 += getZeroString(e2 + 1 - len);
    if (sd && (k2 = sd - e2 - 1) > 0)
      str2 = str2 + "." + getZeroString(k2);
  } else {
    if ((k2 = e2 + 1) < len)
      str2 = str2.slice(0, k2) + "." + str2.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e2 + 1 === len)
        str2 += ".";
      str2 += getZeroString(k2);
    }
  }
  return str2;
}
function getBase10Exponent(digits, e2) {
  var w2 = digits[0];
  for (e2 *= LOG_BASE; w2 >= 10; w2 /= 10)
    e2++;
  return e2;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w2 = digits.length - 1, len = w2 * LOG_BASE + 1;
  w2 = digits[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10)
      len--;
    for (w2 = digits[0]; w2 >= 10; w2 /= 10)
      len++;
  }
  return len;
}
function getZeroString(k2) {
  var zs = "";
  for (; k2--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x2, n2, pr) {
  var isTruncated, r2 = new Ctor(1), k2 = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n2 % 2) {
      r2 = r2.times(x2);
      if (truncate(r2.d, k2))
        isTruncated = true;
    }
    n2 = mathfloor(n2 / 2);
    if (n2 === 0) {
      n2 = r2.d.length - 1;
      if (isTruncated && r2.d[n2] === 0)
        ++r2.d[n2];
      break;
    }
    x2 = x2.times(x2);
    truncate(x2.d, k2);
  }
  external = true;
  return r2;
}
function isOdd$1(n2) {
  return n2.d[n2.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y2, x2 = new Ctor(args[0]), i2 = 0;
  for (; ++i2 < args.length; ) {
    y2 = new Ctor(args[i2]);
    if (!y2.s) {
      x2 = y2;
      break;
    } else if (x2[ltgt](y2)) {
      x2 = y2;
    }
  }
  return x2;
}
function naturalExponential(x2, sd) {
  var denominator, guard, j2, pow2, sum2, t2, wpr, rep = 0, i2 = 0, k2 = 0, Ctor = x2.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x2.d || !x2.d[0] || x2.e > 17) {
    return new Ctor(x2.d ? !x2.d[0] ? 1 : x2.s < 0 ? 0 : 1 / 0 : x2.s ? x2.s < 0 ? 0 : x2 : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t2 = new Ctor(0.03125);
  while (x2.e > -2) {
    x2 = x2.times(t2);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x2), wpr, 1);
    denominator = denominator.times(++i2);
    t2 = sum2.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j2 = k2;
      while (j2--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t2 = new Ctor(1);
          i2 = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t2;
  }
}
function naturalLogarithm(y2, sd) {
  var c2, c0, denominator, e2, numerator, rep, sum2, t2, wpr, x1, x2, n2 = 1, guard = 10, x3 = y2, xd = x3.d, Ctor = x3.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x3.s < 0 || !xd || !xd[0] || !x3.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x3.s != 1 ? NaN : xd ? 0 : x3);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c2 = digitsToString(xd);
  c0 = c2.charAt(0);
  if (Math.abs(e2 = x3.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x3 = x3.times(y2);
      c2 = digitsToString(x3.d);
      c0 = c2.charAt(0);
      n2++;
    }
    e2 = x3.e;
    if (c0 > 1) {
      x3 = new Ctor("0." + c2);
      e2++;
    } else {
      x3 = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t2 = getLn10(Ctor, wpr + 2, pr).times(e2 + "");
    x3 = naturalLogarithm(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t2);
    Ctor.precision = pr;
    return sd == null ? finalise(x3, pr, rm, external = true) : x3;
  }
  x1 = x3;
  sum2 = numerator = x3 = divide(x3.minus(1), x3.plus(1), wpr, 1);
  x2 = finalise(x3.times(x3), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t2 = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e2 !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e2 + ""));
      sum2 = divide(sum2, new Ctor(n2), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t2 = numerator = x3 = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x3.times(x3), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t2;
    denominator += 2;
  }
}
function nonFiniteToString(x2) {
  return String(x2.s * x2.s / 0);
}
function parseDecimal(x2, str2) {
  var e2, i2, len;
  if ((e2 = str2.indexOf(".")) > -1)
    str2 = str2.replace(".", "");
  if ((i2 = str2.search(/e/i)) > 0) {
    if (e2 < 0)
      e2 = i2;
    e2 += +str2.slice(i2 + 1);
    str2 = str2.substring(0, i2);
  } else if (e2 < 0) {
    e2 = str2.length;
  }
  for (i2 = 0; str2.charCodeAt(i2) === 48; i2++)
    ;
  for (len = str2.length; str2.charCodeAt(len - 1) === 48; --len)
    ;
  str2 = str2.slice(i2, len);
  if (str2) {
    len -= i2;
    x2.e = e2 = e2 - i2 - 1;
    x2.d = [];
    i2 = (e2 + 1) % LOG_BASE;
    if (e2 < 0)
      i2 += LOG_BASE;
    if (i2 < len) {
      if (i2)
        x2.d.push(+str2.slice(0, i2));
      for (len -= LOG_BASE; i2 < len; )
        x2.d.push(+str2.slice(i2, i2 += LOG_BASE));
      str2 = str2.slice(i2);
      i2 = LOG_BASE - str2.length;
    } else {
      i2 -= len;
    }
    for (; i2--; )
      str2 += "0";
    x2.d.push(+str2);
    if (external) {
      if (x2.e > x2.constructor.maxE) {
        x2.d = null;
        x2.e = NaN;
      } else if (x2.e < x2.constructor.minE) {
        x2.e = 0;
        x2.d = [0];
      }
    }
  } else {
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function parseOther(x2, str2) {
  var base2, Ctor, divisor, i2, isFloat, len, p2, xd, xe;
  if (str2.indexOf("_") > -1) {
    str2 = str2.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str2))
      return parseDecimal(x2, str2);
  } else if (str2 === "Infinity" || str2 === "NaN") {
    if (!+str2)
      x2.s = NaN;
    x2.e = NaN;
    x2.d = null;
    return x2;
  }
  if (isHex.test(str2)) {
    base2 = 16;
    str2 = str2.toLowerCase();
  } else if (isBinary.test(str2)) {
    base2 = 2;
  } else if (isOctal.test(str2)) {
    base2 = 8;
  } else {
    throw Error(invalidArgument + str2);
  }
  i2 = str2.search(/p/i);
  if (i2 > 0) {
    p2 = +str2.slice(i2 + 1);
    str2 = str2.substring(2, i2);
  } else {
    str2 = str2.slice(2);
  }
  i2 = str2.indexOf(".");
  isFloat = i2 >= 0;
  Ctor = x2.constructor;
  if (isFloat) {
    str2 = str2.replace(".", "");
    len = str2.length;
    i2 = len - i2;
    divisor = intPow(Ctor, new Ctor(base2), i2, i2 * 2);
  }
  xd = convertBase(str2, base2, BASE);
  xe = xd.length - 1;
  for (i2 = xe; xd[i2] === 0; --i2)
    xd.pop();
  if (i2 < 0)
    return new Ctor(x2.s * 0);
  x2.e = getBase10Exponent(xd, xe);
  x2.d = xd;
  external = false;
  if (isFloat)
    x2 = divide(x2, divisor, len * 4);
  if (p2)
    x2 = x2.times(Math.abs(p2) < 54 ? mathpow(2, p2) : Decimal.pow(2, p2));
  external = true;
  return x2;
}
function sine(Ctor, x2) {
  var k2, len = x2.d.length;
  if (len < 3) {
    return x2.isZero() ? x2 : taylorSeries(Ctor, 2, x2, x2);
  }
  k2 = 1.4 * Math.sqrt(len);
  k2 = k2 > 16 ? 16 : k2 | 0;
  x2 = x2.times(1 / tinyPow(5, k2));
  x2 = taylorSeries(Ctor, 2, x2, x2);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k2--; ) {
    sin2_x = x2.times(x2);
    x2 = x2.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x2;
}
function taylorSeries(Ctor, n2, x2, y2, isHyperbolic) {
  var j2, t2, u2, x22, pr = Ctor.precision, k2 = Math.ceil(pr / LOG_BASE);
  external = false;
  x22 = x2.times(x2);
  u2 = new Ctor(y2);
  for (; ; ) {
    t2 = divide(u2.times(x22), new Ctor(n2++ * n2++), pr, 1);
    u2 = isHyperbolic ? y2.plus(t2) : y2.minus(t2);
    y2 = divide(t2.times(x22), new Ctor(n2++ * n2++), pr, 1);
    t2 = u2.plus(y2);
    if (t2.d[k2] !== void 0) {
      for (j2 = k2; t2.d[j2] === u2.d[j2] && j2--; )
        ;
      if (j2 == -1)
        break;
    }
    j2 = u2;
    u2 = y2;
    y2 = t2;
    t2 = j2;
  }
  external = true;
  t2.d.length = k2 + 1;
  return t2;
}
function tinyPow(b2, e2) {
  var n2 = b2;
  while (--e2)
    n2 *= b2;
  return n2;
}
function toLessThanHalfPi(Ctor, x2) {
  var t2, isNeg = x2.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x2 = x2.abs();
  if (x2.lte(halfPi)) {
    quadrant$1 = isNeg ? 4 : 1;
    return x2;
  }
  t2 = x2.divToInt(pi);
  if (t2.isZero()) {
    quadrant$1 = isNeg ? 3 : 2;
  } else {
    x2 = x2.minus(t2.times(pi));
    if (x2.lte(halfPi)) {
      quadrant$1 = isOdd$1(t2) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x2;
    }
    quadrant$1 = isOdd$1(t2) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x2.minus(pi).abs();
}
function toStringBinary(x2, baseOut, sd, rm) {
  var base2, e2, i2, k2, len, roundUp, str2, xd, y2, Ctor = x2.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x2.isFinite()) {
    str2 = nonFiniteToString(x2);
  } else {
    str2 = finiteToString(x2);
    i2 = str2.indexOf(".");
    if (isExp) {
      base2 = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base2 = baseOut;
    }
    if (i2 >= 0) {
      str2 = str2.replace(".", "");
      y2 = new Ctor(1);
      y2.e = str2.length - i2;
      y2.d = convertBase(finiteToString(y2), 10, base2);
      y2.e = y2.d.length;
    }
    xd = convertBase(str2, 10, base2);
    e2 = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str2 = isExp ? "0p+0" : "0";
    } else {
      if (i2 < 0) {
        e2--;
      } else {
        x2 = new Ctor(x2);
        x2.d = xd;
        x2.e = e2;
        x2 = divide(x2, y2, sd, rm, 0, base2);
        xd = x2.d;
        e2 = x2.e;
        roundUp = inexact;
      }
      i2 = xd[sd];
      k2 = base2 / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i2 !== void 0 || roundUp) && (rm === 0 || rm === (x2.s < 0 ? 3 : 2)) : i2 > k2 || i2 === k2 && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x2.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base2 - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e2;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i2 = 0, str2 = ""; i2 < len; i2++)
        str2 += NUMERALS.charAt(xd[i2]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i2 = baseOut == 16 ? 4 : 3;
            for (--len; len % i2; len++)
              str2 += "0";
            xd = convertBase(str2, base2, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i2 = 1, str2 = "1."; i2 < len; i2++)
              str2 += NUMERALS.charAt(xd[i2]);
          } else {
            str2 = str2.charAt(0) + "." + str2.slice(1);
          }
        }
        str2 = str2 + (e2 < 0 ? "p" : "p+") + e2;
      } else if (e2 < 0) {
        for (; ++e2; )
          str2 = "0" + str2;
        str2 = "0." + str2;
      } else {
        if (++e2 > len)
          for (e2 -= len; e2--; )
            str2 += "0";
        else if (e2 < len)
          str2 = str2.slice(0, e2) + "." + str2.slice(e2);
      }
    }
    str2 = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str2;
  }
  return x2.s < 0 ? "-" + str2 : str2;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x2) {
  return new this(x2).abs();
}
function acos(x2) {
  return new this(x2).acos();
}
function acosh(x2) {
  return new this(x2).acosh();
}
function add(x2, y2) {
  return new this(x2).plus(y2);
}
function asin(x2) {
  return new this(x2).asin();
}
function asinh(x2) {
  return new this(x2).asinh();
}
function atan(x2) {
  return new this(x2).atan();
}
function atanh(x2) {
  return new this(x2).atanh();
}
function atan2$1(y2, x2) {
  y2 = new this(y2);
  x2 = new this(x2);
  var r2, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y2.s || !x2.s) {
    r2 = new this(NaN);
  } else if (!y2.d && !x2.d) {
    r2 = getPi(this, wpr, 1).times(x2.s > 0 ? 0.25 : 0.75);
    r2.s = y2.s;
  } else if (!x2.d || y2.isZero()) {
    r2 = x2.s < 0 ? getPi(this, pr, rm) : new this(0);
    r2.s = y2.s;
  } else if (!y2.d || x2.isZero()) {
    r2 = getPi(this, wpr, 1).times(0.5);
    r2.s = y2.s;
  } else if (x2.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r2 = this.atan(divide(y2, x2, wpr, 1));
    x2 = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r2 = y2.s < 0 ? r2.minus(x2) : r2.plus(x2);
  } else {
    r2 = this.atan(divide(y2, x2, wpr, 1));
  }
  return r2;
}
function cbrt(x2) {
  return new this(x2).cbrt();
}
function ceil(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 2);
}
function clamp(x2, min2, max2) {
  return new this(x2).clamp(min2, max2);
}
function config(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i2, p2, v2, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i2 = 0; i2 < ps.length; i2 += 3) {
    if (p2 = ps[i2], useDefaults)
      this[p2] = DEFAULTS[p2];
    if ((v2 = obj[p2]) !== void 0) {
      if (mathfloor(v2) === v2 && v2 >= ps[i2 + 1] && v2 <= ps[i2 + 2])
        this[p2] = v2;
      else
        throw Error(invalidArgument + p2 + ": " + v2);
    }
  }
  if (p2 = "crypto", useDefaults)
    this[p2] = DEFAULTS[p2];
  if ((v2 = obj[p2]) !== void 0) {
    if (v2 === true || v2 === false || v2 === 0 || v2 === 1) {
      if (v2) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p2] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p2] = false;
      }
    } else {
      throw Error(invalidArgument + p2 + ": " + v2);
    }
  }
  return this;
}
function cos$3(x2) {
  return new this(x2).cos();
}
function cosh(x2) {
  return new this(x2).cosh();
}
function clone(obj) {
  var i2, p2, ps;
  function Decimal2(v2) {
    var e2, i3, t2, x2 = this;
    if (!(x2 instanceof Decimal2))
      return new Decimal2(v2);
    x2.constructor = Decimal2;
    if (isDecimalInstance(v2)) {
      x2.s = v2.s;
      if (external) {
        if (!v2.d || v2.e > Decimal2.maxE) {
          x2.e = NaN;
          x2.d = null;
        } else if (v2.e < Decimal2.minE) {
          x2.e = 0;
          x2.d = [0];
        } else {
          x2.e = v2.e;
          x2.d = v2.d.slice();
        }
      } else {
        x2.e = v2.e;
        x2.d = v2.d ? v2.d.slice() : v2.d;
      }
      return;
    }
    t2 = typeof v2;
    if (t2 === "number") {
      if (v2 === 0) {
        x2.s = 1 / v2 < 0 ? -1 : 1;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (v2 < 0) {
        v2 = -v2;
        x2.s = -1;
      } else {
        x2.s = 1;
      }
      if (v2 === ~~v2 && v2 < 1e7) {
        for (e2 = 0, i3 = v2; i3 >= 10; i3 /= 10)
          e2++;
        if (external) {
          if (e2 > Decimal2.maxE) {
            x2.e = NaN;
            x2.d = null;
          } else if (e2 < Decimal2.minE) {
            x2.e = 0;
            x2.d = [0];
          } else {
            x2.e = e2;
            x2.d = [v2];
          }
        } else {
          x2.e = e2;
          x2.d = [v2];
        }
        return;
      } else if (v2 * 0 !== 0) {
        if (!v2)
          x2.s = NaN;
        x2.e = NaN;
        x2.d = null;
        return;
      }
      return parseDecimal(x2, v2.toString());
    } else if (t2 !== "string") {
      throw Error(invalidArgument + v2);
    }
    if ((i3 = v2.charCodeAt(0)) === 45) {
      v2 = v2.slice(1);
      x2.s = -1;
    } else {
      if (i3 === 43)
        v2 = v2.slice(1);
      x2.s = 1;
    }
    return isDecimal.test(v2) ? parseDecimal(x2, v2) : parseOther(x2, v2);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2$1;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos$3;
  Decimal2.cosh = cosh;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round$1;
  Decimal2.sign = sign;
  Decimal2.sin = sin$3;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub$1;
  Decimal2.sum = sum;
  Decimal2.tan = tan$1;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i2 = 0; i2 < ps.length; )
        if (!obj.hasOwnProperty(p2 = ps[i2++]))
          obj[p2] = this[p2];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x2, y2) {
  return new this(x2).div(y2);
}
function exp(x2) {
  return new this(x2).exp();
}
function floor(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 3);
}
function hypot() {
  var i2, n2, t2 = new this(0);
  external = false;
  for (i2 = 0; i2 < arguments.length; ) {
    n2 = new this(arguments[i2++]);
    if (!n2.d) {
      if (n2.s) {
        external = true;
        return new this(1 / 0);
      }
      t2 = n2;
    } else if (t2.d) {
      t2 = t2.plus(n2.times(n2));
    }
  }
  external = true;
  return t2.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x2) {
  return new this(x2).ln();
}
function log(x2, y2) {
  return new this(x2).log(y2);
}
function log2(x2) {
  return new this(x2).log(2);
}
function log10(x2) {
  return new this(x2).log(10);
}
function max() {
  return maxOrMin(this, arguments, "lt");
}
function min() {
  return maxOrMin(this, arguments, "gt");
}
function mod(x2, y2) {
  return new this(x2).mod(y2);
}
function mul(x2, y2) {
  return new this(x2).mul(y2);
}
function pow(x2, y2) {
  return new this(x2).pow(y2);
}
function random(sd) {
  var d2, e2, k2, n2, i2 = 0, r2 = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k2 = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i2 < k2; )
      rd[i2++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d2 = crypto.getRandomValues(new Uint32Array(k2));
    for (; i2 < k2; ) {
      n2 = d2[i2];
      if (n2 >= 429e7) {
        d2[i2] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i2++] = n2 % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d2 = crypto.randomBytes(k2 *= 4);
    for (; i2 < k2; ) {
      n2 = d2[i2] + (d2[i2 + 1] << 8) + (d2[i2 + 2] << 16) + ((d2[i2 + 3] & 127) << 24);
      if (n2 >= 214e7) {
        crypto.randomBytes(4).copy(d2, i2);
      } else {
        rd.push(n2 % 1e7);
        i2 += 4;
      }
    }
    i2 = k2 / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k2 = rd[--i2];
  sd %= LOG_BASE;
  if (k2 && sd) {
    n2 = mathpow(10, LOG_BASE - sd);
    rd[i2] = (k2 / n2 | 0) * n2;
  }
  for (; rd[i2] === 0; i2--)
    rd.pop();
  if (i2 < 0) {
    e2 = 0;
    rd = [0];
  } else {
    e2 = -1;
    for (; rd[0] === 0; e2 -= LOG_BASE)
      rd.shift();
    for (k2 = 1, n2 = rd[0]; n2 >= 10; n2 /= 10)
      k2++;
    if (k2 < LOG_BASE)
      e2 -= LOG_BASE - k2;
  }
  r2.e = e2;
  r2.d = rd;
  return r2;
}
function round$1(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, this.rounding);
}
function sign(x2) {
  x2 = new this(x2);
  return x2.d ? x2.d[0] ? x2.s : 0 * x2.s : x2.s || NaN;
}
function sin$3(x2) {
  return new this(x2).sin();
}
function sinh(x2) {
  return new this(x2).sinh();
}
function sqrt(x2) {
  return new this(x2).sqrt();
}
function sub$1(x2, y2) {
  return new this(x2).sub(y2);
}
function sum() {
  var i2 = 0, args = arguments, x2 = new this(args[i2]);
  external = false;
  for (; x2.s && ++i2 < args.length; )
    x2 = x2.plus(args[i2]);
  external = true;
  return finalise(x2, this.precision, this.rounding);
}
function tan$1(x2) {
  return new this(x2).tan();
}
function tanh(x2) {
  return new this(x2).tanh();
}
function trunc(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  Decimal,
  "default": Decimal
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(decimal);
Object.defineProperty(cal$3, "__esModule", { value: true });
cal$3.crammer = cal$3.traceCircle = cal$3.trace = cal$3.range = cal$3.nPr = cal$3.nCr = cal$3.factorial = cal$3.primeFactors = cal$3.primes = cal$3.isPrime = cal$3.toSurd = cal$3.isRational = cal$3.toFraction = cal$3.logFloor = cal$3.logCeil = cal$3.mantissa = cal$3.e = cal$3.fix = cal$3.round = cal$3.dp = cal$3.sigfig = cal$3.eq = cal$3.correct = cal$3.blur = void 0;
const decimal_js_1 = require$$0;
const STANDARD_SIGFIG = 14;
function blur(num2) {
  let n2 = parseFloat(num2.toPrecision(STANDARD_SIGFIG));
  return sigfig(n2) <= STANDARD_SIGFIG - 5 ? n2 : num2;
}
cal$3.blur = blur;
function correct(num2) {
  return parseFloat(num2.toPrecision(STANDARD_SIGFIG - 2));
}
cal$3.correct = correct;
function eq(a2, b2) {
  return correct(a2) === correct(b2);
}
cal$3.eq = eq;
function sigfig(num2) {
  return new decimal_js_1.Decimal(num2).precision(false);
}
cal$3.sigfig = sigfig;
function dp(num2) {
  return new decimal_js_1.Decimal(num2).decimalPlaces();
}
cal$3.dp = dp;
function round(num2, sigfig2 = 3) {
  function exec(mode) {
    return new decimal_js_1.Decimal(num2).toSignificantDigits(sigfig2, mode).toNumber();
  }
  return {
    off: () => exec(decimal_js_1.Decimal.ROUND_HALF_UP),
    up: () => exec(decimal_js_1.Decimal.ROUND_UP),
    down: () => exec(decimal_js_1.Decimal.ROUND_DOWN)
  };
}
cal$3.round = round;
function fix(num2, dp2 = 0) {
  function exec(mode) {
    return new decimal_js_1.Decimal(num2).toNearest(Number("1e" + String(-dp2)), mode).toNumber();
  }
  return {
    off: () => exec(decimal_js_1.Decimal.ROUND_HALF_UP),
    up: () => exec(decimal_js_1.Decimal.ROUND_UP),
    down: () => exec(decimal_js_1.Decimal.ROUND_DOWN)
  };
}
cal$3.fix = fix;
function e$3(num2) {
  return Number(num2.toExponential().split("e")[1]);
}
cal$3.e = e$3;
function mantissa(num2) {
  return Number(num2.toExponential().split("e")[0]);
}
cal$3.mantissa = mantissa;
function logCeil(num2) {
  let exp2 = e$3(num2) + 1;
  return Number("1e" + exp2);
}
cal$3.logCeil = logCeil;
function logFloor(num2) {
  let exp2 = e$3(num2);
  return Number("1e" + exp2);
}
cal$3.logFloor = logFloor;
function toFraction(num2) {
  if (num2 === Infinity)
    return [1, 0];
  if (num2 === -Infinity)
    return [-1, 0];
  let f2 = new decimal_js_1.Decimal(num2).toFraction(1e5);
  return [f2[0].toNumber(), f2[1].toNumber()];
}
cal$3.toFraction = toFraction;
function isRational(num2) {
  function convert(num3, deno) {
    let f2 = new decimal_js_1.Decimal(num3).toFraction(deno);
    return [f2[0].toNumber(), f2[1].toNumber()];
  }
  if (num2 === Infinity)
    return false;
  if (num2 === -Infinity)
    return false;
  let rough = convert(num2, 1e5);
  let accurate = convert(num2, 1e7);
  return rough[0] === accurate[0] && rough[1] === accurate[1];
}
cal$3.isRational = isRational;
function toSurd(num2) {
  num2 = blur(num2);
  let s2 = Math.sign(num2);
  let a2 = Math.abs(num2);
  let square = blur(a2 ** 2);
  if (square === 0)
    return [0, 1];
  let factors = [1];
  let i2 = 2;
  while (i2 <= a2) {
    let s3 = i2 ** 2;
    if (square % s3 === 0) {
      square = square / s3;
      factors.push(i2);
    } else {
      i2++;
    }
  }
  let product = factors.reduce((a3, b2) => a3 * b2, 1);
  return [s2 * product, square];
}
cal$3.toSurd = toSurd;
function isPrime(num2) {
  if (!Number.isInteger(num2))
    return false;
  if (num2 <= 1)
    return false;
  if (num2 === 2)
    return true;
  if (num2 % 2 === 0)
    return false;
  for (let i2 = 3; i2 <= Math.sqrt(num2) + 1; i2 = i2 + 2) {
    if (num2 % i2 === 0)
      return false;
  }
  return true;
}
cal$3.isPrime = isPrime;
function primes(max2) {
  let arr = [];
  for (let i2 = 2; i2 <= max2; i2++) {
    if (isPrime(i2))
      arr.push(i2);
  }
  return arr;
}
cal$3.primes = primes;
function primeFactors(num2) {
  let arr = [];
  let i2 = 2;
  while (num2 > 1) {
    if (!isPrime(i2)) {
      i2++;
      continue;
    }
    if (num2 % i2 === 0) {
      arr.push(i2);
      num2 = num2 / i2;
    } else {
      i2++;
    }
  }
  return arr;
}
cal$3.primeFactors = primeFactors;
function factorial(n2) {
  if (n2 <= 1)
    return 1;
  return factorial(n2 - 1) * n2;
}
cal$3.factorial = factorial;
function nCr(n2, r2) {
  return factorial(n2) / factorial(r2) / factorial(n2 - r2);
}
cal$3.nCr = nCr;
function nPr(n2, r2) {
  return factorial(n2) / factorial(n2 - r2);
}
cal$3.nPr = nPr;
function range(min2, max2) {
  let arr = [];
  min2 = Math.ceil(min2 - Number.EPSILON);
  for (let i2 = min2; i2 <= max2; i2++) {
    arr.push(i2);
  }
  return arr;
}
cal$3.range = range;
function trace$1(func, range2, dots = 1e3) {
  function tracer(t3) {
    let result2;
    try {
      result2 = func(t3);
    } catch {
      return [NaN, NaN];
    }
    if (!Array.isArray(result2))
      result2 = [t3, result2];
    return result2;
  }
  let [t1, t2] = range2;
  const step = (t2 - t1) / (dots - 1);
  let points = [];
  for (let t3 = t1; t3 <= t2; t3 += step) {
    points.push(tracer(t3));
  }
  return points;
}
cal$3.trace = trace$1;
function traceCircle$1(center, radius, angleRange, dots = 100) {
  const [h2, k2] = center;
  function sin2(degree) {
    return Math.sin(degree / 180 * Math.PI);
  }
  function cos2(degree) {
    return Math.cos(degree / 180 * Math.PI);
  }
  return trace$1((t2) => [h2 + radius * cos2(t2), k2 + radius * sin2(t2)], angleRange, dots);
}
cal$3.traceCircle = traceCircle$1;
function crammer(a2, b2, c2, p2, q2, r2) {
  if (a2 / b2 === p2 / q2)
    return [NaN, NaN];
  const D2 = a2 * q2 - b2 * p2;
  const x2 = (c2 * q2 - b2 * r2) / D2;
  const y2 = (a2 * r2 - c2 * p2) / D2;
  return [blur(x2), blur(y2)];
}
cal$3.crammer = crammer;
Object.defineProperty(numbers$2, "__esModule", { value: true });
numbers$2.toNumbers = numbers$2.numbers = numbers$2.Numbers = void 0;
const list_1$6 = list$2;
const cal_1$1 = cal$3;
class Numbers extends list_1$6.List {
  sum() {
    return this.reduce((a2, b2) => a2 + b2, 0);
  }
  product() {
    if (this.length === 0)
      return NaN;
    return this.reduce((a2, b2) => a2 * b2, 1);
  }
  mean() {
    if (this.length === 0)
      return NaN;
    return this.sum() / this.length;
  }
  max(rank = 1) {
    var _a;
    if (this.length === 0)
      return NaN;
    if (rank === 1) {
      return Math.max(...this);
    } else {
      let desc = this.unique().descending();
      return (_a = desc[rank - 1]) != null ? _a : NaN;
    }
  }
  min(rank = 1) {
    var _a;
    if (this.length === 0)
      return NaN;
    if (rank === 1) {
      return Math.min(...this);
    } else {
      let asc = this.unique().ascending();
      return (_a = asc[rank - 1]) != null ? _a : NaN;
    }
  }
  add(nums) {
    if (!Array.isArray(nums))
      nums = Array(this.length).fill(nums);
    let zipped = this.zip(nums, (a2, b2) => a2 + b2);
    return this.create(zipped);
  }
  minus(nums) {
    if (!Array.isArray(nums))
      nums = Array(this.length).fill(nums);
    let zipped = this.zip(nums, (a2, b2) => a2 - b2);
    return this.create(zipped);
  }
  times(nums) {
    if (!Array.isArray(nums))
      nums = Array(this.length).fill(nums);
    let zipped = this.zip(nums, (a2, b2) => a2 * b2);
    return this.create(zipped);
  }
  divide(nums) {
    if (!Array.isArray(nums))
      nums = Array(this.length).fill(nums);
    let zipped = this.zip(nums, (a2, b2) => a2 / b2);
    return this.create(zipped);
  }
  toPower(indices) {
    if (!Array.isArray(indices))
      indices = Array(this.length).fill(indices);
    let zipped = this.zip(indices, (a2, b2) => a2 ** b2);
    return this.create(zipped);
  }
  rootNth(nths) {
    if (!Array.isArray(nths))
      nths = Array(this.length).fill(nths);
    let zipped = this.zip(nths, (a2, b2) => a2 ** (1 / b2));
    return this.create(zipped);
  }
  square() {
    return this.toPower(2);
  }
  squareRoot() {
    return this.rootNth(2);
  }
  negate() {
    return this.times(-1);
  }
  abs() {
    const mapped = this.map(($) => Math.abs($));
    return this.create(mapped);
  }
  blur() {
    let blurred = this.map(($) => (0, cal_1$1.blur)($));
    return this.create(blurred);
  }
  toFraction() {
    let fracs = this.map(($) => (0, cal_1$1.toFraction)($));
    return (0, list_1$6.list)(...fracs);
  }
  gaps() {
    const sorted = this.ascending();
    const gaps = this.create([]);
    for (let i2 = 0; i2 < this.length - 1; i2++) {
      let gap = sorted[i2 + 1] - sorted[i2];
      gaps.push(gap);
    }
    return gaps;
  }
  gapsMod(mod2) {
    function reduce(x2) {
      while (x2 >= mod2) {
        x2 = x2 - mod2;
      }
      while (x2 < 0) {
        x2 = x2 + mod2;
      }
      return x2;
    }
    const reduced = this.map(reduce);
    const sorted = reduced.ascending();
    const patched = this.create([...sorted, sorted[0] + mod2]);
    return patched.gaps();
  }
  hcf() {
    if (this.some(($) => !Number.isInteger($)))
      return NaN;
    let arr = this.except([0]).abs().unique();
    if (arr.length === 0)
      return NaN;
    if (arr.length === 1)
      return arr[0];
    if (arr.length === 2) {
      let [a2, b2] = arr;
      while (true) {
        if (a2 === 0)
          return b2;
        if (b2 === 0)
          return a2;
        if (a2 >= b2) {
          a2 = a2 % b2;
        } else {
          b2 = b2 % a2;
        }
      }
      return a2;
    }
    return arr.reduce((last, now) => this.create([last, now]).hcf());
  }
  lcm() {
    if (this.some(($) => !Number.isInteger($)))
      return NaN;
    let arr = this.except([0]).abs().unique();
    if (arr.length === 0)
      return NaN;
    if (arr.length === 1)
      return arr[0];
    if (arr.length === 2) {
      let [a2, b2] = arr;
      let hcf = arr.hcf();
      return a2 * b2 / hcf;
    }
    return arr.reduce((last, now) => this.create([last, now]).lcm());
  }
  reduceRatio() {
    if (this.except([0]).length === 0)
      return this.clone();
    if (this.some(($) => !Number.isInteger($)))
      return this.clone();
    let HCF2 = this.hcf();
    return this.divide(HCF2).blur();
  }
  ratio() {
    if (this.except([0]).length === 0)
      return this.clone();
    if (this.some(($) => !(0, cal_1$1.isRational)($)))
      return this.clone();
    let fracs = this.toFraction();
    let denos = this.create(fracs.map(($) => $[1]));
    return this.times(denos.lcm()).blur().reduceRatio();
  }
  ratioFactor() {
    if (this.except([0]).length === 0)
      return NaN;
    if (this.some(($) => !(0, cal_1$1.isRational)($)))
      return NaN;
    let clone2 = this.except([0]);
    let ratioed = clone2.ratio();
    return (0, cal_1$1.blur)(ratioed[0] / clone2[0]);
  }
}
numbers$2.Numbers = Numbers;
function numbers$1(...elements) {
  let nums = new Numbers();
  nums.push(...elements);
  return nums;
}
numbers$2.numbers = numbers$1;
function toNumbers$1(elements) {
  return numbers$1(...elements);
}
numbers$2.toNumbers = toNumbers$1;
Object.defineProperty(data$1, "__esModule", { value: true });
data$1.toData = data$1.data = data$1.Data = void 0;
const numbers_1$3 = numbers$2;
class Data extends numbers_1$3.Numbers {
  median() {
    if (this.length === 0)
      return NaN;
    const sorted = this.ascending();
    if (sorted.length % 2 === 0) {
      let i2 = sorted.length / 2;
      let j2 = i2 + 1;
      return (sorted[i2 - 1] + sorted[j2 - 1]) / 2;
    } else {
      let i2 = sorted.length / 2;
      i2 = Math.ceil(i2);
      return sorted[i2 - 1];
    }
  }
  modes(Nth = 1) {
    if (this.length === 0)
      return this.create([]);
    return this.maxsBy(($) => this.freq($), Nth).unique();
  }
  mode(Nth = 1) {
    if (this.length === 0)
      return NaN;
    const modes = this.modes(Nth);
    if (modes.length > 1)
      return NaN;
    return modes.first();
  }
  isSingleMode(Nth = 1) {
    const modes = this.modes(Nth);
    return modes.length === 1;
  }
  lowerQuartile() {
    if (this.length === 0)
      return NaN;
    const sorted = this.ascending();
    let n2 = sorted.length;
    let m2 = n2 / 2;
    if (n2 % 2 !== 0)
      m2 = Math.floor(m2);
    return sorted.head(m2).median();
  }
  upperQuartile() {
    if (this.length === 0)
      return NaN;
    const sorted = this.ascending();
    let n2 = sorted.length;
    let m2 = n2 / 2;
    if (n2 % 2 !== 0)
      m2 = Math.floor(m2);
    return sorted.tail(m2).median();
  }
  stdDev() {
    if (this.length === 0)
      return NaN;
    let mean = this.mean();
    let deviations = this.minus(mean);
    let squaredDev = deviations.square();
    let meanSq = squaredDev.mean();
    return Math.sqrt(meanSq);
  }
  range() {
    if (this.length === 0)
      return NaN;
    return this.max() - this.min();
  }
  IQR() {
    if (this.length === 0)
      return NaN;
    return this.upperQuartile() - this.lowerQuartile();
  }
}
data$1.Data = Data;
function data(...elements) {
  let dt = new Data();
  dt.push(...elements);
  return dt;
}
data$1.data = data;
function toData$1(elements) {
  return data(...elements);
}
data$1.toData = toData$1;
var shape$1 = {};
var vector$2 = {};
Object.defineProperty(vector$2, "__esModule", { value: true });
vector$2.toVector = vector$2.vector = vector$2.Vector = void 0;
const numbers_1$2 = numbers$2;
class Vector extends numbers_1$2.Numbers {
  magnitude() {
    let squares = this.square();
    let sum2 = squares.sum();
    return Math.sqrt(sum2);
  }
  unit() {
    let mag = this.magnitude();
    return this.divide(mag);
  }
  scaledTo(magnitude2) {
    return this.unit().times(magnitude2);
  }
  dot(vec2) {
    let terms = this.zip(vec2, (a2, b2) => a2 * b2);
    return this.create(terms).sum();
  }
  angleWith(vec2) {
    let m1 = this.magnitude();
    let m2 = this.create(vec2).magnitude();
    let dot = this.dot(vec2);
    let cos2 = dot / m1 / m2;
    let angle2 = Math.acos(cos2) * 180 / Math.PI;
    return angle2;
  }
  projectOn(vec2) {
    let unit = this.create(vec2).unit();
    let dot = this.dot(unit);
    return unit.times(dot);
  }
  normalTo(vec2) {
    let parallel = this.projectOn(vec2);
    return this.minus(parallel);
  }
  distanceWith(vec2) {
    let d2 = this.minus(vec2);
    return d2.magnitude();
  }
  extrudeTo(vertex, scale) {
    let v2 = this.create(vertex);
    let d2 = this.minus(v2);
    d2 = d2.times(scale);
    return v2.add(d2);
  }
}
vector$2.Vector = Vector;
function vector$1(...elements) {
  let vec2 = new Vector();
  vec2.push(...elements);
  return vec2;
}
vector$2.vector = vector$1;
function toVector(elements) {
  return vector$1(...elements);
}
vector$2.toVector = toVector;
Object.defineProperty(shape$1, "__esModule", { value: true });
shape$1.toShape = shape$1.shape = shape$1.Shape = void 0;
const list_1$5 = list$2;
const numbers_1$1 = numbers$2;
const vector_1$2 = vector$2;
class Shape extends list_1$5.List {
  distances() {
    let ds = this.pairs().map(([A2, B2]) => A2.distanceWith(B2));
    return (0, numbers_1$1.numbers)(...ds);
  }
  distancesFrom(point) {
    let ds = this.map(($) => $.distanceWith(point));
    return (0, numbers_1$1.numbers)(...ds);
  }
  mean() {
    let sum2 = this.reduce((A2, B2) => A2.add(B2));
    return sum2.divide(this.length);
  }
  translate(vec2) {
    let translated = this.map(($) => $.add(vec2));
    return this.create(translated);
  }
  scale(scale) {
    let scaled = this.map(($) => $.times(scale));
    return this.create(scaled);
  }
  extrudeTo(vertex, scale) {
    let extruded = this.map(($) => $.extrudeTo(vertex, scale));
    return this.create(extruded);
  }
  extrudeToShape(shape2, scale) {
    let extruded = this.map((v2, i2) => v2.extrudeTo(shape2[i2], scale));
    return this.create(extruded);
  }
}
shape$1.Shape = Shape;
function shape(...elements) {
  let shp = new Shape();
  shp.push(...elements.map(($) => (0, vector_1$2.vector)(...$)));
  return shp;
}
shape$1.shape = shape;
function toShape(elements) {
  return shape(...elements);
}
shape$1.toShape = toShape;
var shape2D$2 = {};
var shape3D$1 = {};
var vector3D$2 = {};
var vector2D$1 = {};
Object.defineProperty(vector2D$1, "__esModule", { value: true });
vector2D$1.vec2D = vector2D$1.vector2D = vector2D$1.Vector2D = void 0;
const vector_1$1 = vector$2;
class Vector2D extends vector_1$1.Vector {
  toArray() {
    let [x2, y2] = this;
    return [x2, y2];
  }
  argument() {
    let [x2, y2] = this;
    if (x2 === 0 && y2 === 0)
      return 0;
    let angle2 = Math.atan2(y2, x2) * 180 / Math.PI;
    if (angle2 < 0)
      angle2 += 360;
    return angle2;
  }
  rotate(angle2) {
    let a2 = angle2 * Math.PI / 180;
    let s2 = Math.sin(a2);
    let c2 = Math.cos(a2);
    let [x2, y2] = this;
    let x1 = x2 * c2 - y2 * s2;
    let y1 = x2 * s2 + y2 * c2;
    return this.create([x1, y1]);
  }
  cross2D(vec2) {
    let [x1, y1] = this;
    let [x2, y2] = vec2;
    return x1 * y2 - y1 * x2;
  }
}
vector2D$1.Vector2D = Vector2D;
function vector2D(x2, y2) {
  let vec2 = new Vector2D();
  vec2.push(x2, y2);
  return vec2;
}
vector2D$1.vector2D = vector2D;
function vec2D$1(p1, p2) {
  if (p2 === void 0) {
    let [x2, y2] = p1;
    return vector2D(x2, y2);
  } else {
    let [x1, y1] = p1;
    let [x2, y2] = p2;
    return vector2D(x2 - x1, y2 - y1);
  }
}
vector2D$1.vec2D = vec2D$1;
Object.defineProperty(vector3D$2, "__esModule", { value: true });
vector3D$2.vec3D = vector3D$2.vector3D = vector3D$2.Vector3D = void 0;
const vector_1 = vector$2;
const vector2D_1$4 = vector2D$1;
class Vector3D extends vector_1.Vector {
  toArray() {
    let [x2, y2, z2] = this;
    return [x2, y2, z2];
  }
  cross(vec2) {
    let [x1, y1, z1] = this;
    let [x2, y2, z2] = vec2;
    let x3 = y1 * z2 - z1 * y2;
    let y3 = z1 * x2 - x1 * z2;
    let z3 = x1 * y2 - y1 * x2;
    return this.create([x3, y3, z3]);
  }
  rotate(axis, angle2) {
    let a2 = angle2 * Math.PI / 180;
    let s2 = Math.sin(a2);
    let c2 = Math.cos(a2);
    let k2 = this.create(axis).unit();
    let term1 = this.times(c2);
    let term2 = k2.cross(this).times(s2);
    let term3 = k2.times(k2.dot(this)).times(1 - c2);
    return term1.add(term2).add(term3);
  }
  projectOnPlane(vec1, vec2) {
    let normal = this.normalToPlane(vec1, vec2);
    return this.minus(normal);
  }
  normalToPlane(vec1, vec2) {
    let v1 = this.create(vec1);
    let v2 = this.create(vec2);
    let normal = v1.cross(v2);
    return this.projectOn(normal);
  }
  projectTo2D(angle2 = 60, depth = 0.5) {
    let a2 = angle2 * Math.PI / 180;
    let s2 = Math.sin(a2);
    let c2 = Math.cos(a2);
    let [x2, y2, z2] = this;
    let x_new = x2 + depth * y2 * c2;
    let y_new = z2 + depth * y2 * s2;
    return (0, vector2D_1$4.vector2D)(x_new, y_new);
  }
}
vector3D$2.Vector3D = Vector3D;
function vector3D$1(x2, y2, z2) {
  let vec2 = new Vector3D();
  vec2.push(x2, y2, z2);
  return vec2;
}
vector3D$2.vector3D = vector3D$1;
function vec3D$1(p1, p2) {
  if (p2 === void 0) {
    let [x2, y2, z2] = p1;
    return vector3D$1(x2, y2, z2);
  } else {
    let [x1, y1, z1] = p1;
    let [x2, y2, z2] = p2;
    return vector3D$1(x2 - x1, y2 - y1, z2 - z1);
  }
}
vector3D$2.vec3D = vec3D$1;
Object.defineProperty(shape3D$1, "__esModule", { value: true });
shape3D$1.toShape3D = shape3D$1.shape3D = shape3D$1.Shape3D = void 0;
const shape_1$1 = shape$1;
const shape2D_1$2 = shape2D$2;
const vector3D_1$2 = vector3D$2;
class Shape3D extends shape_1$1.Shape {
  toArray() {
    return [...this.map(($) => $.toArray())];
  }
  projectTo2D(angle2 = 60, depth = 0.5) {
    let projected = this.map(($) => $.projectTo2D(angle2, depth));
    return (0, shape2D_1$2.shape2D)(...projected);
  }
}
shape3D$1.Shape3D = Shape3D;
function shape3D(...elements) {
  let shp = new Shape3D();
  shp.push(...elements.map(($) => (0, vector3D_1$2.vec3D)($)));
  return shp;
}
shape3D$1.shape3D = shape3D;
function toShape3D$1(elements) {
  return shape3D(...elements);
}
shape3D$1.toShape3D = toShape3D$1;
Object.defineProperty(shape2D$2, "__esModule", { value: true });
shape2D$2.toShape2D = shape2D$2.shape2D = shape2D$2.Shape2D = void 0;
const shape_1 = shape$1;
const shape3D_1 = shape3D$1;
const vector3D_1$1 = vector3D$2;
const vector2D_1$3 = vector2D$1;
class Shape2D extends shape_1.Shape {
  toArray() {
    return [...this.map(($) => $.toArray())];
  }
  sortAroundMean() {
    let mean = this.mean();
    this.sortBy(($) => $.minus(mean).argument());
  }
  isConvex() {
    if (this.length <= 3)
      return true;
    let clone2 = this.clone();
    clone2.sortAroundMean();
    let cross = [];
    for (let i2 = 0; i2 < clone2.length; i2++) {
      let p1 = clone2.cyclicAt(i2 - 1);
      let p2 = clone2.cyclicAt(i2);
      let p3 = clone2.cyclicAt(i2 + 1);
      let u2 = (0, vector2D_1$3.vec2D)(p1, p2);
      let v2 = (0, vector2D_1$3.vec2D)(p2, p3);
      cross.push(u2.cross2D(v2));
    }
    return cross.every(($) => $ > 0) || cross.every(($) => $ < 0);
  }
  erect(vecX, vecY) {
    let vx = (0, vector3D_1$1.vec3D)(vecX);
    let vy = (0, vector3D_1$1.vec3D)(vecY);
    let erected = this.map(($) => {
      let [x2, y2] = $;
      let vx3D = vx.times(x2);
      let vy3D = vy.times(y2);
      return vx3D.add(vy3D);
    });
    return (0, shape3D_1.shape3D)(...erected);
  }
}
shape2D$2.Shape2D = Shape2D;
function shape2D$1(...elements) {
  let shp = new Shape2D();
  shp.push(...elements.map(($) => (0, vector2D_1$3.vec2D)($)));
  return shp;
}
shape2D$2.shape2D = shape2D$1;
function toShape2D$1(elements) {
  return shape2D$1(...elements);
}
shape2D$2.toShape2D = toShape2D$1;
var sheet$1 = {};
Object.defineProperty(sheet$1, "__esModule", { value: true });
sheet$1.toSheet = sheet$1.sheet = sheet$1.Sheet = void 0;
const list_1$4 = list$2;
function isLike(item, criteria) {
  for (const key in criteria) {
    if (!(key in item))
      return false;
    const actualValue = item[key];
    const requiredValue = criteria[key];
    if (Array.isArray(requiredValue)) {
      if (!requiredValue.includes(actualValue))
        return false;
    } else {
      if (actualValue !== requiredValue)
        return false;
    }
  }
  return true;
}
function assignProperty(target, source) {
  for (const k2 in source) {
    target[k2] = source[k2];
  }
}
class Sheet extends list_1$4.List {
  match(criteria) {
    return this.filter(($) => isLike($, criteria));
  }
  unmatch(criteria) {
    return this.filter(($) => !isLike($, criteria));
  }
  get(criteria) {
    return this.find(($) => isLike($, criteria));
  }
  exist(criteria) {
    return this.get(criteria) !== void 0;
  }
  count(criteria) {
    return this.match(criteria).length;
  }
  pluck(field2) {
    const values = this.map(($) => $[field2]);
    const ls = new list_1$4.List();
    ls.set(values);
    return ls;
  }
  scan(field2) {
    return this.pluck(field2).unique();
  }
  distill(criteria) {
    this.set(this.match(criteria));
  }
  discard(criteria) {
    this.set(this.unmatch(criteria));
  }
  order(...ordering) {
    this.sort((a2, b2) => {
      for (let ord of ordering) {
        if (typeof ord === "string") {
          if (a2[ord] > b2[ord])
            return 1;
          if (a2[ord] < b2[ord])
            return -1;
        } else {
          for (let k2 in ord) {
            let v2 = ord[k2];
            if (v2 === true) {
              if (a2[k2] > b2[k2])
                return 1;
              if (a2[k2] < b2[k2])
                return -1;
            }
            if (v2 === false) {
              if (a2[k2] < b2[k2])
                return 1;
              if (a2[k2] > b2[k2])
                return -1;
            }
            if (Array.isArray(v2)) {
              let i2 = v2.indexOf(a2[k2]);
              let j2 = v2.indexOf(b2[k2]);
              if (i2 === -1)
                i2 = Infinity;
              if (j2 === -1)
                j2 = Infinity;
              if (i2 > j2)
                return 1;
              if (i2 < j2)
                return -1;
            }
            break;
          }
        }
      }
      return 0;
    });
  }
  merge(elements, idField) {
    for (const newbie of elements) {
      for (const oldie of this) {
        if (!(idField in oldie))
          continue;
        if (!(idField in newbie))
          continue;
        if (newbie[idField] === oldie[idField])
          assignProperty(oldie, newbie);
      }
    }
  }
  absorb(elements, idField) {
    for (const newbie of elements) {
      let found = false;
      for (const oldie of this) {
        if (!(idField in oldie))
          continue;
        if (!(idField in newbie))
          continue;
        if (newbie[idField] === oldie[idField]) {
          assignProperty(oldie, newbie);
          found = true;
        }
      }
      if (!found)
        this.push(newbie);
    }
  }
}
sheet$1.Sheet = Sheet;
function sheet(...elements) {
  let sh = new Sheet();
  sh.push(...elements);
  return sh;
}
sheet$1.sheet = sheet;
function toSheet(elements) {
  return sheet(...elements);
}
sheet$1.toSheet = toSheet;
var pencil = {};
var frame = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Frame = exports.PEN_QUALITY = void 0;
  exports.PEN_QUALITY = 3;
  class Frame {
    constructor() {
      this.wPixel = 0;
      this.hPixel = 0;
      this.xmin = 0;
      this.xmax = 0;
      this.ymin = 0;
      this.ymax = 0;
      this.axisOffset = 5 * exports.PEN_QUALITY;
    }
    setSize(wPixel, hPixel) {
      this.wPixel = wPixel;
      this.hPixel = hPixel;
    }
    setXRange(xRange) {
      [this.xmin, this.xmax] = xRange;
    }
    setYRange(yRange) {
      [this.ymin, this.ymax] = yRange;
    }
    xWidth() {
      return this.xmax - this.xmin;
    }
    yHeight() {
      return this.ymax - this.ymin;
    }
    xUnit() {
      return this.wPixel / this.xWidth();
    }
    yUnit() {
      return this.hPixel / this.yHeight();
    }
    toPix(point2D2) {
      const x2 = point2D2[0];
      const y2 = point2D2[1];
      const xPixel = (x2 - this.xmin) * this.xUnit();
      const yPixel = (this.ymax - y2) * this.yUnit();
      return [xPixel, yPixel];
    }
    toPixs(point2Ds2) {
      return point2Ds2.map(($) => this.toPix($));
    }
    toCoord(pixel2D) {
      const xPixel = pixel2D[0];
      const yPixel = pixel2D[1];
      const x2 = this.xmin + xPixel / this.xUnit();
      const y2 = this.ymax - yPixel / this.yUnit();
      return [x2, y2];
    }
    toCoords(pixel2Ds) {
      return pixel2Ds.map(($) => this.toCoord($));
    }
    xTicks(interval2) {
      return getTicks2(this.xmin, this.xmax, interval2);
    }
    yTicks(interval2) {
      return getTicks2(this.ymin, this.ymax, interval2);
    }
    xRange() {
      return [this.xmin, this.xmax];
    }
    yRange() {
      return [this.ymin, this.ymax];
    }
    xCenter() {
      return (this.xmin + this.xmax) / 2;
    }
    yCenter() {
      return (this.ymin + this.ymax) / 2;
    }
    xyCenter() {
      return [this.xCenter(), this.yCenter()];
    }
    xOffset() {
      return this.axisOffset / this.yUnit();
    }
    yOffset() {
      return this.axisOffset / this.xUnit();
    }
  }
  exports.Frame = Frame;
  function getTicks2(min2, max2, interval2, includeZero = false) {
    const start = Math.floor(min2 / interval2) * interval2;
    const arr = [];
    for (let i2 = start; i2 <= max2; i2 += interval2) {
      i2 = parseFloat(i2.toPrecision(3));
      if (i2 === min2 || i2 === max2)
        continue;
      if (!includeZero && i2 === 0)
        continue;
      arr.push(i2);
    }
    return arr;
  }
})(frame);
var support = {};
Object.defineProperty(support, "__esModule", { value: true });
support.midPoint = support.atan2 = support.cos = support.sin = support.force2D = support.IsReflex = support.AnglePolar = void 0;
const vector2D_1$2 = vector2D$1;
const vector3D_1 = vector3D$2;
function AnglePolar$1(A2, O2, B2) {
  let a2 = (0, vector2D_1$2.vec2D)(O2, A2).argument();
  let b2 = (0, vector2D_1$2.vec2D)(O2, B2).argument();
  return a2 <= b2 ? b2 - a2 : 360 + b2 - a2;
}
support.AnglePolar = AnglePolar$1;
function IsReflex$2(A2, O2, B2) {
  return AnglePolar$1(A2, O2, B2) > 180;
}
support.IsReflex = IsReflex$2;
function force2D(point, angle2, depth) {
  if (point.length === 3) {
    return (0, vector3D_1.vec3D)(point).projectTo2D(angle2, depth).toArray();
  } else {
    return point;
  }
}
support.force2D = force2D;
function sin$2(degree) {
  return Math.sin(degree / 180 * Math.PI);
}
support.sin = sin$2;
function cos$2(degree) {
  return Math.cos(degree / 180 * Math.PI);
}
support.cos = cos$2;
function atan2(dy, dx) {
  return Math.atan2(dy, dx) * 180 / Math.PI;
}
support.atan2 = atan2;
function midPoint(A2, B2) {
  return [(A2[0] + B2[0]) / 2, (A2[1] + B2[1]) / 2];
}
support.midPoint = midPoint;
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  Object.defineProperty(o2, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result2 = {};
  if (mod2 != null) {
    for (var k2 in mod2)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
        __createBinding$1(result2, mod2, k2);
  }
  __setModuleDefault$1(result2, mod2);
  return result2;
};
Object.defineProperty(pencil, "__esModule", { value: true });
pencil.Pencil = void 0;
const frame_1 = frame;
const support_1 = support;
const cal$2 = __importStar$1(cal$3);
const list_1$3 = list$2;
const shape2D_1$1 = shape2D$2;
const vector2D_1$1 = vector2D$1;
const REM_PIXEL$2 = parseFloat(getComputedStyle(document.documentElement).fontSize);
const SIZE_SCALE = 10;
const DEFAULT_SHADE_ALPHA = 0.1;
const DEFAULT_AXIS_LABEL_OFFSET_PIXEL = 15;
const DEFAULT_XAXIS_MARK_OFFSET_PIXEL = 15;
const DEFAULT_YAXIS_MARK_OFFSET_PIXEL = 10;
const DEFAULT_AXIS_TICK_LENGTH_PIXEL = 5;
class Pencil {
  constructor() {
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.frame = new frame_1.Frame();
    this.imgStore = null;
    this.INIT_RANGE_ALREADY = false;
    this.INIT_SIZE_ALREADY = false;
    this.backgroundImgUrl = "";
    this.$TEXT_SIZE = 1;
    this.$TEXT_DIR = 0;
    this.$TEXT_LATEX = false;
    this.$LABEL_CENTER = 0;
    this.$ANGLE_MODE = "normal";
    this.$LENGTH_UNIT = void 0;
    this.$3D_ANGLE = 60;
    this.$3D_DEPTH = 0.5;
    this.$BORDER = 0.2;
    this.$LINE_LABEL = "auto";
  }
  initRange(xRange, yRange) {
    this.frame.setXRange(xRange);
    this.frame.setYRange(yRange);
    this.INIT_RANGE_ALREADY = true;
  }
  initSize(width, height) {
    if (!this.INIT_RANGE_ALREADY)
      throw "[Pencil Error] Range must be set before Size";
    const wPixel = width * SIZE_SCALE * REM_PIXEL$2 * frame_1.PEN_QUALITY;
    const hPixel = height * SIZE_SCALE * REM_PIXEL$2 * frame_1.PEN_QUALITY;
    let $3D_ANGLE = this.$3D_ANGLE;
    let $3D_DEPTH = this.$3D_DEPTH;
    let $BORDER = this.$BORDER;
    this.canvas.width = wPixel;
    this.canvas.height = hPixel;
    this.frame.setSize(wPixel, hPixel);
    this.setAllDefault();
    this.setProjector3D($3D_ANGLE, $3D_DEPTH);
    this.setBorder($BORDER);
    this.INIT_SIZE_ALREADY = true;
  }
  initOuterBorder() {
    if (!this.INIT_RANGE_ALREADY)
      throw "[Pencil Error] Range must be set before setting range border";
    if (!this.INIT_SIZE_ALREADY)
      throw "[Pencil Error] Size must be set before setting range border";
    const borderPix = this.$BORDER * SIZE_SCALE * REM_PIXEL$2 * frame_1.PEN_QUALITY;
    let [xmin, xmax] = this.frame.xRange();
    let [ymin, ymax] = this.frame.yRange();
    const wPixel = this.frame.wPixel;
    const hPixel = this.frame.hPixel;
    let borderXUnit = (xmax - xmin) * borderPix / wPixel;
    let borderYUnit = (ymax - ymin) * borderPix / hPixel;
    xmin -= borderXUnit;
    xmax += borderXUnit;
    ymin -= borderYUnit;
    ymax += borderYUnit;
    this.initRange([xmin, xmax], [ymin, ymax]);
    const width = wPixel / SIZE_SCALE / REM_PIXEL$2 / frame_1.PEN_QUALITY;
    const height = hPixel / SIZE_SCALE / REM_PIXEL$2 / frame_1.PEN_QUALITY;
    this.initSize(width + 2 * this.$BORDER, height + 2 * this.$BORDER);
  }
  pj(point) {
    return (0, support_1.force2D)(point, this.$3D_ANGLE, this.$3D_DEPTH);
  }
  pjs(points) {
    return points.map(($) => this.pj($));
  }
  setWeight(weight = 1) {
    this.ctx.lineWidth = weight * frame_1.PEN_QUALITY;
  }
  setStrokeColor(color = "black") {
    this.ctx.strokeStyle = color;
  }
  setFillColor(color = "black") {
    this.ctx.fillStyle = color;
  }
  setColor(color = "black") {
    this.setStrokeColor(color);
    this.setFillColor(color);
  }
  setAlpha(opaque = 1) {
    this.ctx.globalAlpha = opaque;
  }
  setDash(segments = []) {
    if (Array.isArray(segments))
      this.ctx.setLineDash(segments.map((x2) => x2 * frame_1.PEN_QUALITY));
    if (typeof segments === "number")
      this.setDash([segments, segments]);
    if (typeof segments === "boolean")
      this.setDash(segments ? [5, 5] : []);
  }
  setTextAlign(align = "center") {
    this.ctx.textAlign = align;
  }
  setTextBaseline(baseline = "middle") {
    this.ctx.textBaseline = baseline;
  }
  setTextSize(size = 1) {
    this.$TEXT_SIZE = size;
    size = Math.round(size * REM_PIXEL$2 * frame_1.PEN_QUALITY);
    this.ctx.font = this.ctx.font.replace(/\d+px/g, size + "px");
  }
  setTextItalic(italic = false) {
    if (italic) {
      if (!this.ctx.font.includes("italic"))
        this.ctx.font = "italic " + this.ctx.font;
    } else {
      this.ctx.font = this.ctx.font.replace("italic ", "");
    }
  }
  setTextDir(angle2 = 0) {
    this.$TEXT_DIR = angle2;
  }
  setTextLatex(on = false) {
    this.$TEXT_LATEX = on;
  }
  setLabelCenter(...centers) {
    if (centers.length === 0) {
      this.$LABEL_CENTER = this.frame.xyCenter();
      return;
    }
    if (centers[0] === true) {
      this.$LABEL_CENTER = this.frame.xyCenter();
      return;
    }
    if (typeof centers[0] === "number") {
      this.$LABEL_CENTER = centers[0];
      return;
    }
    if (Array.isArray(centers[0])) {
      let cens = centers;
      this.$LABEL_CENTER = (0, shape2D_1$1.toShape2D)(this.pjs(cens)).mean().toArray();
    }
  }
  setLengthUnit(text2 = void 0) {
    this.$LENGTH_UNIT = text2;
  }
  setAngleMode(mode = "normal") {
    this.$ANGLE_MODE = mode;
  }
  setProjector3D(angle2 = 60, depth = 0.5) {
    this.$3D_ANGLE = angle2;
    this.$3D_DEPTH = depth;
  }
  setBorder(border = 0.2) {
    this.$BORDER = border;
  }
  setLineLabel(setting = "auto") {
    this.$LINE_LABEL = setting;
  }
  setAllDefault() {
    this.setWeight();
    this.setStrokeColor();
    this.setFillColor();
    this.setAlpha();
    this.setDash();
    this.setTextAlign();
    this.setTextBaseline();
    this.ctx.font = "normal 10px Times New Roman";
    this.setTextSize();
    this.setTextItalic();
    this.setTextDir();
    this.setTextLatex();
    this.setLabelCenter();
    this.setLengthUnit();
    this.setAngleMode();
    this.setProjector3D();
    this.setBorder();
    this.setLineLabel();
  }
  moveTo(point) {
    let pt = this.pj(point);
    let pixels = this.frame.toPix(pt);
    let [x2, y2] = pixels;
    this.ctx.beginPath();
    this.ctx.moveTo(x2, y2);
  }
  lineTo(point) {
    let pt = this.pj(point);
    let pixels = this.frame.toPix(pt);
    let [x2, y2] = pixels;
    this.ctx.lineTo(x2, y2);
  }
  path(points) {
    if (points.length === 0) {
      this.ctx.beginPath();
      return;
    }
    let pts = this.pjs(points);
    this.moveTo(pts[0]);
    for (let i2 = 1; i2 < pts.length; i2++) {
      this.lineTo(pts[i2]);
    }
  }
  drawStroke(points) {
    this.path(points);
    this.ctx.stroke();
  }
  drawShape(points) {
    this.path(points);
    this.ctx.closePath();
    this.ctx.stroke();
  }
  drawFill(points) {
    this.path(points);
    this.ctx.closePath();
    this.ctx.fill();
  }
  drawShade(points) {
    let alpha = this.ctx.globalAlpha;
    this.setAlpha(DEFAULT_SHADE_ALPHA);
    this.drawFill(points);
    this.setAlpha(alpha);
  }
  pathArc(center, radiusPixel, angleRange) {
    let cen = this.pj(center);
    let [x2, y2] = this.frame.toPix(cen);
    let [q1, q2] = angleRange;
    q1 = -q1 / 180 * Math.PI;
    q2 = -q2 / 180 * Math.PI;
    this.ctx.beginPath();
    this.ctx.arc(x2, y2, radiusPixel * frame_1.PEN_QUALITY, q1, q2, true);
  }
  drawArc(center, radiusPixel, angleRange) {
    this.pathArc(center, radiusPixel, angleRange);
    this.ctx.stroke();
  }
  drawSegment(center, radiusPixel, angleRange) {
    this.pathArc(center, radiusPixel, angleRange);
    this.ctx.fill();
  }
  drawCircle(center, radiusPixel) {
    this.drawArc(center, radiusPixel, [0, 360]);
  }
  drawDot(center, radiusPixel) {
    this.pathArc(center, radiusPixel, [0, 360]);
    this.ctx.fill();
  }
  pathSectoroid(center, pStart, pEnd, vertices) {
    let v1 = (0, vector2D_1$1.vec2D)(center, pStart);
    let v2 = (0, vector2D_1$1.vec2D)(center, pEnd);
    let r2 = (0, vector2D_1$1.vec2D)(center, pStart).magnitude();
    let q1 = v1.argument();
    let q2 = v2.argument();
    if (q2 < q1)
      q2 += 360;
    let points = cal$2.traceCircle(center, r2, [q1, q2]);
    this.path([pStart, ...points, pEnd, ...vertices]);
  }
  drawStrokeSectoroid(center, pStart, pEnd, vertices) {
    this.pathSectoroid(center, pStart, pEnd, vertices);
    this.ctx.stroke();
  }
  drawFillSectoroid(center, pStart, pEnd, vertices) {
    this.pathSectoroid(center, pStart, pEnd, vertices);
    this.ctx.closePath();
    this.ctx.fill();
  }
  drawShadeSectoroid(center, pStart, pEnd, vertices) {
    let alpha = this.ctx.globalAlpha;
    this.setAlpha(DEFAULT_SHADE_ALPHA);
    this.drawFillSectoroid(center, pStart, pEnd, vertices);
    this.setAlpha(alpha);
  }
  drawArrowHead(startPoint, endPoint, { arrowLength, arrowWidth, arrowOffset } = {}) {
    let p1 = this.pj(startPoint);
    let p2 = this.pj(endPoint);
    const [x0, y0] = this.frame.toPix(p1);
    const [x1, y1] = this.frame.toPix(p2);
    const dx = x1 - x0;
    const dy = y1 - y0;
    const angle2 = Math.atan2(dy, dx);
    const length = Math.sqrt(dx * dx + dy * dy);
    arrowLength != null ? arrowLength : arrowLength = 10;
    arrowWidth != null ? arrowWidth : arrowWidth = arrowLength / 2;
    arrowOffset != null ? arrowOffset : arrowOffset = 0;
    arrowLength *= frame_1.PEN_QUALITY;
    arrowWidth *= frame_1.PEN_QUALITY;
    arrowOffset *= frame_1.PEN_QUALITY;
    this.ctx.save();
    this.ctx.translate(x0, y0);
    this.ctx.rotate(angle2);
    this.ctx.beginPath();
    this.ctx.moveTo(length + arrowOffset - arrowLength, -arrowWidth);
    this.ctx.lineTo(length + arrowOffset, 0);
    this.ctx.lineTo(length + arrowOffset - arrowLength, arrowWidth);
    this.ctx.stroke();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.restore();
  }
  drawAngle(point1, vertex, point2, radiusPixel, arcCount, spacePixel) {
    let [A2, O2, B2] = this.pjs([point1, vertex, point2]);
    let mode = this.$ANGLE_MODE;
    if (mode === "normal" && (0, support_1.IsReflex)(A2, O2, B2))
      [A2, B2] = [B2, A2];
    if (mode === "reflex" && !(0, support_1.IsReflex)(A2, O2, B2))
      [A2, B2] = [B2, A2];
    let [pixelA, pixelO, pixelB] = this.frame.toPixs([A2, O2, B2]);
    let a1 = (0, support_1.atan2)(-(pixelA[1] - pixelO[1]), pixelA[0] - pixelO[0]);
    let a2 = (0, support_1.atan2)(-(pixelB[1] - pixelO[1]), pixelB[0] - pixelO[0]);
    const mark = (position) => {
      this.drawArc(O2, radiusPixel + position * spacePixel, [a1, a2]);
    };
    if (arcCount % 2 === 1) {
      mark(0);
      for (let i2 = 1; i2 <= (arcCount - 1) / 2; i2++) {
        mark(i2);
        mark(-i2);
      }
    } else {
      for (let i2 = 1; i2 <= arcCount / 2; i2++) {
        mark(i2 - 0.5);
        mark(-(i2 - 0.5));
      }
    }
  }
  drawRightAngle(point1, vertex, point2, sizePixel) {
    let pts = this.pjs([point1, vertex, point2]);
    let [A2, O2, B2] = this.frame.toPixs(pts);
    let size = sizePixel * frame_1.PEN_QUALITY;
    let angleA = (0, support_1.atan2)(A2[1] - O2[1], A2[0] - O2[0]);
    let angleB = (0, support_1.atan2)(B2[1] - O2[1], B2[0] - O2[0]);
    let P2 = [O2[0] + size * (0, support_1.cos)(angleA), O2[1] + size * (0, support_1.sin)(angleA)];
    let Q2 = [O2[0] + size * (0, support_1.cos)(angleB), O2[1] + size * (0, support_1.sin)(angleB)];
    let R2 = [
      O2[0] + size * (0, support_1.cos)(angleA) + size * (0, support_1.cos)(angleB),
      O2[1] + size * (0, support_1.sin)(angleA) + size * (0, support_1.sin)(angleB)
    ];
    let draw = (A3, B3) => {
      this.ctx.beginPath();
      this.ctx.moveTo(A3[0], A3[1]);
      this.ctx.lineTo(B3[0], B3[1]);
      this.ctx.stroke();
    };
    draw(P2, R2);
    draw(Q2, R2);
  }
  drawParallelMark(startPoint, endPoint, sizePixel, tickCount, spacePixel) {
    let A2 = this.pj(startPoint);
    let B2 = this.pj(endPoint);
    let M2 = (0, support_1.midPoint)(A2, B2);
    sizePixel != null ? sizePixel : sizePixel = 4;
    spacePixel != null ? spacePixel : spacePixel = 6;
    for (let i2 = 0; i2 < tickCount; i2++) {
      this.drawArrowHead(A2, M2, {
        arrowLength: sizePixel * 2,
        arrowWidth: sizePixel,
        arrowOffset: i2 * spacePixel
      });
    }
  }
  drawTick(startPoint, tickPoint, lengthPixel, offsetPixel) {
    let p1 = this.pj(startPoint);
    let p2 = this.pj(tickPoint);
    const [x0, y0] = this.frame.toPix(p1);
    const [x1, y1] = this.frame.toPix(p2);
    const dx = x1 - x0;
    const dy = y1 - y0;
    const angle2 = Math.atan2(dy, dx);
    const length = Math.sqrt(dx * dx + dy * dy);
    lengthPixel != null ? lengthPixel : lengthPixel = 5;
    offsetPixel != null ? offsetPixel : offsetPixel = 0;
    lengthPixel *= frame_1.PEN_QUALITY;
    offsetPixel *= frame_1.PEN_QUALITY;
    this.ctx.save();
    this.ctx.translate(x0, y0);
    this.ctx.rotate(angle2);
    this.ctx.beginPath();
    this.ctx.moveTo(length + offsetPixel, -lengthPixel);
    this.ctx.lineTo(length + offsetPixel, lengthPixel);
    this.ctx.stroke();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.restore();
  }
  drawTickVertical(position, lengthPixel) {
    let p2 = this.pj(position);
    const [x2, y2] = this.frame.toPix(p2);
    lengthPixel *= frame_1.PEN_QUALITY;
    this.ctx.beginPath();
    this.ctx.moveTo(x2, y2 - lengthPixel);
    this.ctx.lineTo(x2, y2 + lengthPixel);
    this.ctx.stroke();
  }
  drawTickHorizontal(position, lengthPixel) {
    let p2 = this.pj(position);
    const [x2, y2] = this.frame.toPix(p2);
    lengthPixel *= frame_1.PEN_QUALITY;
    this.ctx.beginPath();
    this.ctx.moveTo(x2 - lengthPixel, y2);
    this.ctx.lineTo(x2 + lengthPixel, y2);
    this.ctx.stroke();
  }
  drawEqualMark(startPoint, endPoint, lengthPixel, tickCount, spacePixel) {
    let A2 = this.pj(startPoint);
    let B2 = this.pj(endPoint);
    let M2 = (0, support_1.midPoint)(A2, B2);
    lengthPixel != null ? lengthPixel : lengthPixel = 5;
    spacePixel != null ? spacePixel : spacePixel = 3;
    const mark = (position) => {
      this.drawTick(A2, M2, lengthPixel, position * spacePixel);
    };
    if (tickCount % 2 === 1) {
      mark(0);
      for (let i2 = 1; i2 <= (tickCount - 1) / 2; i2++) {
        mark(i2);
        mark(-i2);
      }
    } else {
      for (let i2 = 1; i2 <= tickCount / 2; i2++) {
        mark(i2 - 0.5);
        mark(-(i2 - 0.5));
      }
    }
  }
  drawCompass(center, xSizePixel, ySizePixel, arrowLength, arrowWidth) {
    let cen = this.pj(center);
    let [x2, y2] = this.frame.toPix(cen);
    xSizePixel != null ? xSizePixel : xSizePixel = 17;
    ySizePixel != null ? ySizePixel : ySizePixel = 20;
    arrowLength != null ? arrowLength : arrowLength = 7;
    arrowWidth != null ? arrowWidth : arrowWidth = arrowLength / 2;
    xSizePixel *= frame_1.PEN_QUALITY;
    ySizePixel *= frame_1.PEN_QUALITY;
    arrowLength *= frame_1.PEN_QUALITY;
    arrowWidth *= frame_1.PEN_QUALITY;
    this.ctx.save();
    this.ctx.translate(x2, y2);
    this.ctx.beginPath();
    this.ctx.moveTo(0, -ySizePixel);
    this.ctx.lineTo(0, ySizePixel);
    this.ctx.moveTo(-arrowWidth, -ySizePixel + arrowLength);
    this.ctx.lineTo(0, -ySizePixel);
    this.ctx.lineTo(arrowWidth, -ySizePixel + arrowLength);
    this.ctx.stroke();
    this.ctx.moveTo(-xSizePixel, 0);
    this.ctx.lineTo(xSizePixel, 0);
    this.ctx.stroke();
    this.ctx.restore();
  }
  drawPlot(func, tStart, tEnd, dots = 1e3) {
    let points = cal$2.trace(func, [tStart, tEnd], dots);
    function outOfRange(num2) {
      return num2.some(($) => Math.abs($) > 1e4);
    }
    let filteredPoints = points.map((pt) => {
      let [x2, y2] = pt;
      if (!Number.isFinite(x2))
        return null;
      if (!Number.isFinite(y2))
        return null;
      if (outOfRange(pt))
        return null;
      return pt;
    });
    let segments = (0, list_1$3.toList)(filteredPoints).split(null);
    for (let seg of segments) {
      if (seg.length === 0)
        continue;
      this.drawStroke(seg);
    }
  }
  plainTextAtPixel(text2, position) {
    text2 = String(text2);
    if (text2 === "")
      return;
    let [x2, y2] = position;
    let ANGLE = -this.$TEXT_DIR * Math.PI / 180;
    this.ctx.save();
    this.ctx.translate(x2, y2);
    this.ctx.rotate(ANGLE);
    this.ctx.fillText(text2, 0, 0);
    this.ctx.restore();
  }
  latexAtPixel(text2, position) {
    text2 = String(text2);
    if (text2 === "")
      return;
    let [x2, y2] = position;
    let ANGLE = -this.$TEXT_DIR * Math.PI / 180;
    let size = Math.round(this.$TEXT_SIZE * REM_PIXEL$2 * frame_1.PEN_QUALITY);
    let color = this.ctx.fillStyle;
    text2 = `\\color{${color}} ` + text2;
    this.ctx.save();
    const widget = new CanvasLatex.default(text2, { displayMode: true, debugBounds: false, baseSize: size });
    const bounds = widget.getBounds();
    if (bounds !== null) {
      this.ctx.translate(x2, y2);
      this.ctx.rotate(ANGLE);
      let xTune = 2 - bounds.width / 2 - bounds.x;
      if (this.ctx.textAlign === "left")
        xTune = 2 - bounds.x;
      if (this.ctx.textAlign === "right")
        xTune = 2 - bounds.width - bounds.x;
      if (this.ctx.textAlign === "center")
        xTune = 2 - bounds.width / 2 - bounds.x;
      let yTune = -bounds.y / 2;
      if (this.ctx.textBaseline === "top")
        yTune = -bounds.y;
      if (this.ctx.textBaseline === "bottom")
        yTune = -bounds.y - bounds.height;
      if (this.ctx.textBaseline === "middle")
        yTune = -bounds.y - bounds.height / 2;
      this.ctx.translate(xTune, yTune);
      widget.draw(this.ctx);
    } else {
      console.error("[CanvasLatex] bounds === null! This is an unexpected error.");
    }
    this.ctx.restore();
  }
  drawText(text2, position, xOffset, yOffset) {
    text2 = String(text2);
    if (text2 === "")
      return;
    let pos = this.pj(position);
    let [x2, y2] = this.frame.toPix(pos);
    x2 += xOffset * frame_1.PEN_QUALITY;
    y2 -= yOffset * frame_1.PEN_QUALITY;
    if (this.$TEXT_LATEX) {
      this.latexAtPixel(text2, [x2, y2]);
    } else {
      this.plainTextAtPixel(text2, [x2, y2]);
    }
  }
  getDirInPixel(pStart, pEnd) {
    let [OPoint, APoint] = this.pjs([pStart, pEnd]);
    let [O2, A2] = this.frame.toPixs([OPoint, APoint]);
    return (0, support_1.atan2)(-(A2[1] - O2[1]), A2[0] - O2[0]);
  }
  getDirInPixelByAngle(point1, vertex, point2) {
    let [A2, O2, B2] = this.pjs([point1, vertex, point2]);
    let mode = this.$ANGLE_MODE;
    if (mode === "normal" && (0, support_1.IsReflex)(A2, O2, B2))
      [A2, B2] = [B2, A2];
    if (mode === "reflex" && !(0, support_1.IsReflex)(A2, O2, B2))
      [A2, B2] = [B2, A2];
    let [pixelA, pixelO, pixelB] = this.frame.toPixs([A2, O2, B2]);
    let a1 = (0, support_1.atan2)(-(pixelA[1] - pixelO[1]), pixelA[0] - pixelO[0]);
    let a2 = (0, support_1.atan2)(-(pixelB[1] - pixelO[1]), pixelB[0] - pixelO[0]);
    if (a2 < a1)
      a2 = a2 + 360;
    return (a1 + a2) / 2;
  }
  getDirInPixelByLine(pStart, pEnd) {
    let mode = this.$LINE_LABEL;
    let left2 = this.getDirInPixel(pStart, pEnd) + 90;
    let right = this.getDirInPixel(pStart, pEnd) - 90;
    if (mode === "left")
      return left2;
    if (mode === "right")
      return right;
    if (mode === "auto") {
      let cen = this.$LABEL_CENTER;
      if (typeof cen === "number")
        return right;
      let p1 = this.pj(pStart);
      let p2 = this.pj(pEnd);
      let v2 = (0, vector2D_1$1.vec2D)(p1, p2);
      let leftDistance = v2.rotate(90).add(p1).distanceWith(cen);
      let rightDistance = v2.rotate(-90).add(p1).distanceWith(cen);
      return leftDistance > rightDistance ? left2 : right;
    }
    console.warn("$LINE_LABEL must be 'left' | 'right' | 'auto'");
    return right;
  }
  getLabelCenterDirInPixel(point) {
    let pt = this.pj(point);
    let center = this.$LABEL_CENTER;
    if (typeof center === "number") {
      return center;
    } else {
      if (center[0] === pt[0] && center[1] === pt[1])
        return 0;
      return this.getDirInPixel(center, pt);
    }
  }
  getTextWidthInPixel(text2) {
    if (this.$TEXT_LATEX) {
      let size = Math.round(this.$TEXT_SIZE * REM_PIXEL$2 * frame_1.PEN_QUALITY);
      let color = this.ctx.fillStyle;
      text2 = `\\color{${color}} ` + text2;
      const widget = new CanvasLatex.default(text2, { displayMode: true, debugBounds: false, baseSize: size });
      const bounds = widget.getBounds();
      if (bounds === null)
        return 0;
      return bounds.width / 2 / frame_1.PEN_QUALITY;
    } else {
      return this.ctx.measureText(text2).width / 2 / frame_1.PEN_QUALITY;
    }
  }
  getTextWithLengthUnit(text2) {
    text2 = String(text2);
    let unit = this.$LENGTH_UNIT;
    if (unit === void 0)
      return text2;
    if (this.$TEXT_LATEX) {
      return text2 + `~\\text{${unit}}`;
    } else {
      return text2 + " " + unit;
    }
  }
  drawLabel(text2, position, direction, radiusPixel) {
    direction != null ? direction : direction = this.getLabelCenterDirInPixel(position);
    let textWidth = this.getTextWidthInPixel(text2);
    let xOffset = (radiusPixel + textWidth - 5) * (0, support_1.cos)(direction);
    let yOffset = radiusPixel * (0, support_1.sin)(direction);
    this.drawText(text2, position, xOffset, yOffset);
  }
  makePolarAngle(point1, vertex, point2) {
    let [A2, O2, B2] = this.pjs([point1, vertex, point2]);
    let mode = this.$ANGLE_MODE;
    if (mode === "normal" && (0, support_1.IsReflex)(A2, O2, B2))
      return [point2, vertex, point1];
    if (mode === "reflex" && !(0, support_1.IsReflex)(A2, O2, B2))
      return [point2, vertex, point1];
    return [point1, vertex, point2];
  }
  getAngleInPixel(point1, vertex, point2) {
    let [A2, O2, B2] = this.makePolarAngle(point1, vertex, point2);
    let a2 = this.getDirInPixel(O2, A2);
    let b2 = this.getDirInPixel(O2, B2);
    return a2 <= b2 ? b2 - a2 : 360 + b2 - a2;
  }
  getSmallAngleExtraPixel(point1, vertex, point2, angleThreshold, pixelPerDegree) {
    let angle2 = this.getAngleInPixel(point1, vertex, point2);
    let angleUnderThreshold = Math.max(angleThreshold - angle2, 0);
    return angleUnderThreshold * pixelPerDegree;
  }
  getCircleCorners(center, radius) {
    let [h2, k2] = center;
    let r2 = radius;
    return [
      [h2 + r2, k2 + r2],
      [h2 + r2, k2 - r2],
      [h2 - r2, k2 + r2],
      [h2 - r2, k2 - r2]
    ];
  }
  getSphereCorners(center, radius) {
    let [a2, b2, c2] = center;
    let r2 = radius;
    return [
      [a2 + r2, b2 + r2, c2 + r2],
      [a2 + r2, b2 + r2, c2 - r2],
      [a2 + r2, b2 - r2, c2 + r2],
      [a2 + r2, b2 - r2, c2 - r2],
      [a2 - r2, b2 + r2, c2 + r2],
      [a2 - r2, b2 + r2, c2 - r2],
      [a2 - r2, b2 - r2, c2 + r2],
      [a2 - r2, b2 - r2, c2 - r2]
    ];
  }
  drawXAxis() {
    const [xmin, xmax] = this.frame.xRange();
    this.drawStroke([[xmin, 0], [xmax, 0]]);
    this.drawArrowHead([xmin, 0], [xmax, 0]);
  }
  drawXAxisLabel(text2) {
    text2 = String(text2);
    const [xmin, xmax] = this.frame.xRange();
    this.ctx.save();
    this.setTextAlign("right");
    this.setTextBaseline("middle");
    this.drawText(text2, [xmax, 0], 0, DEFAULT_AXIS_LABEL_OFFSET_PIXEL);
    this.ctx.restore();
  }
  drawYAxis() {
    const [ymin, ymax] = this.frame.yRange();
    this.drawStroke([[0, ymin], [0, ymax]]);
    this.drawArrowHead([0, ymin], [0, ymax]);
  }
  drawYAxisLabel(text2) {
    text2 = String(text2);
    const [ymin, ymax] = this.frame.yRange();
    this.ctx.save();
    this.setTextAlign("left");
    this.setTextBaseline("top");
    this.drawText(text2, [0, ymax], DEFAULT_AXIS_LABEL_OFFSET_PIXEL, 0);
    this.ctx.restore();
  }
  drawXAxisTick(interval2) {
    for (let x2 of this.frame.xTicks(interval2)) {
      this.drawTickVertical([x2, 0], DEFAULT_AXIS_TICK_LENGTH_PIXEL);
    }
  }
  drawYAxisTick(interval2) {
    for (let y2 of this.frame.yTicks(interval2)) {
      this.drawTickHorizontal([0, y2], DEFAULT_AXIS_TICK_LENGTH_PIXEL);
    }
  }
  drawXAxisTickMark(interval2) {
    this.ctx.save();
    this.setTextItalic();
    this.setTextAlign("center");
    this.setTextBaseline("middle");
    for (let x2 of this.frame.xTicks(interval2)) {
      this.drawText(String(x2), [x2, 0], 0, -DEFAULT_XAXIS_MARK_OFFSET_PIXEL);
    }
    this.ctx.restore();
  }
  drawYAxisTickMark(interval2) {
    this.ctx.save();
    this.setTextItalic();
    this.setTextAlign("right");
    this.setTextBaseline("middle");
    for (let y2 of this.frame.yTicks(interval2)) {
      this.drawText(String(y2), [0, y2], -DEFAULT_YAXIS_MARK_OFFSET_PIXEL, 0);
    }
    this.ctx.restore();
  }
  drawXAxisGrid(interval2) {
    this.ctx.save();
    this.ctx.strokeStyle = "#d3d5db";
    let [ymin, ymax] = this.frame.yRange();
    const drawLine = (x2) => {
      this.drawStroke([[x2, ymin], [x2, ymax]]);
    };
    drawLine(0);
    for (let x2 of this.frame.xTicks(interval2)) {
      drawLine(x2);
    }
    this.ctx.restore();
  }
  drawYAxisGrid(interval2) {
    this.ctx.save();
    this.ctx.strokeStyle = "#d3d5db";
    let [xmin, xmax] = this.frame.xRange();
    const drawLine = (y2) => {
      this.drawStroke([[xmin, y2], [xmax, y2]]);
    };
    drawLine(0);
    for (let y2 of this.frame.yTicks(interval2)) {
      drawLine(y2);
    }
    this.ctx.restore();
  }
  setBackgroundImgUrl(url) {
    this.backgroundImgUrl = url;
  }
  backgroundImageAttr() {
    if (this.backgroundImgUrl.length === 0)
      return "";
    return ` style="background-image:url('${this.backgroundImgUrl}');background-size:100% 100%;" `;
  }
  toDataUrl(canvas = this.canvas) {
    return canvas.toDataURL();
  }
  displayWidth(canvas = this.canvas) {
    return Math.floor(canvas.width / frame_1.PEN_QUALITY);
  }
  displayHeight(canvas = this.canvas) {
    return Math.floor(canvas.height / frame_1.PEN_QUALITY);
  }
  cloneCanvas(canvas = this.canvas) {
    let oldCanvas = canvas;
    let newCanvas = document.createElement("canvas");
    let context2 = newCanvas.getContext("2d");
    newCanvas.width = oldCanvas.width;
    newCanvas.height = oldCanvas.height;
    context2.drawImage(oldCanvas, 0, 0);
    return newCanvas;
  }
  trimCanvas(canvas = this.canvas) {
    function rowBlank2(imageData2, width2, y2) {
      for (var x2 = 0; x2 < width2; ++x2) {
        if (imageData2.data[y2 * width2 * 4 + x2 * 4 + 3] !== 0)
          return false;
      }
      return true;
    }
    function columnBlank(imageData2, width2, x2, top2, bottom2) {
      for (var y2 = top2; y2 < bottom2; ++y2) {
        if (imageData2.data[y2 * width2 * 4 + x2 * 4 + 3] !== 0)
          return false;
      }
      return true;
    }
    var ctx = canvas.getContext("2d");
    var width = canvas.width;
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    var top = 0, bottom = imageData.height, left2 = 0, right = imageData.width;
    while (top < bottom && rowBlank2(imageData, width, top))
      ++top;
    while (bottom - 1 > top && rowBlank2(imageData, width, bottom - 1))
      --bottom;
    while (left2 < right && columnBlank(imageData, width, left2, top, bottom))
      ++left2;
    while (right - 1 > left2 && columnBlank(imageData, width, right - 1, top, bottom))
      --right;
    var trimmed = ctx.getImageData(left2, top, right - left2, bottom - top);
    canvas.width = trimmed.width;
    canvas.height = trimmed.height;
    ctx.putImageData(trimmed, 0, 0);
  }
  clearCanvas() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  saveCanvasImg() {
    this.imgStore = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
  }
  restoreCanvasImg() {
    if (this.imgStore !== null)
      this.ctx.putImageData(this.imgStore, 0, 0);
  }
  save() {
    this.ctx.save();
  }
  restore() {
    this.ctx.restore();
  }
}
pencil.Pencil = Pencil;
var inequal = {};
Object.defineProperty(inequal, "__esModule", { value: true });
inequal.ineq = void 0;
function toCode(ineq2) {
  if (ineq2 === "\\ge")
    return [true, true];
  if (ineq2 === "\\gt")
    return [true, false];
  if (ineq2 === "\\le")
    return [false, true];
  if (ineq2 === "\\lt")
    return [false, false];
  if (ineq2 === ">=")
    return [true, true];
  if (ineq2 === ">")
    return [true, false];
  if (ineq2 === "<=")
    return [false, true];
  if (ineq2 === "<")
    return [false, false];
  throw "cannot recognise ineq symbol!";
}
function toIneq(code2) {
  let [g2, e2] = code2;
  if (g2 && e2)
    return "\\ge";
  if (g2 && !e2)
    return "\\gt";
  if (!g2 && e2)
    return "\\le";
  if (!g2 && !e2)
    return "\\lt";
  throw "cannot recognise code!";
}
class InequalSign {
  constructor(sign2) {
    this.code = [true, true];
    this.code = toCode(sign2);
  }
  greaterThan() {
    return this.code[0];
  }
  lessThan() {
    return !this.code[0];
  }
  canEqual() {
    return this.code[1];
  }
  print() {
    return toIneq(this.code);
  }
  strict() {
    let [g2, e2] = this.code;
    return toIneq([g2, false]);
  }
  loose() {
    let [g2, e2] = this.code;
    return toIneq([g2, true]);
  }
  flip() {
    let [g2, e2] = this.code;
    return toIneq([!g2, e2]);
  }
  compare(a2, b2) {
    let [g2, e2] = this.code;
    if (g2 && e2)
      return a2 >= b2;
    if (g2 && !e2)
      return a2 > b2;
    if (!g2 && e2)
      return a2 <= b2;
    if (!g2 && !e2)
      return a2 < b2;
    throw "never, cannot recognise code!";
  }
}
function ineq$2(sign2) {
  return new InequalSign(sign2);
}
inequal.ineq = ineq$2;
var optimizer$2 = {};
var reins$1 = {};
var rein$2 = {};
Object.defineProperty(rein$2, "__esModule", { value: true });
rein$2.rein = rein$2.Rein = void 0;
const cal_1 = cal$3;
const inequal_1 = inequal;
class Rein {
  constructor(constraint2) {
    this.constraint = constraint2;
  }
  clone() {
    return new Rein(this.constraint);
  }
  contains(point) {
    let [a2, b2, i2, c2] = this.constraint;
    let [x2, y2] = point;
    return (0, inequal_1.ineq)(i2).compare(a2 * x2 + b2 * y2, c2);
  }
  canEqual() {
    let [a2, b2, i2, c2] = this.constraint;
    return (0, inequal_1.ineq)(i2).canEqual();
  }
  strict() {
    let [a2, b2, i2, c2] = this.constraint;
    let j2 = (0, inequal_1.ineq)(i2).strict();
    return new Rein([a2, b2, j2, c2]);
  }
  loose() {
    let [a2, b2, i2, c2] = this.constraint;
    let j2 = (0, inequal_1.ineq)(i2).loose();
    return new Rein([a2, b2, j2, c2]);
  }
  flip() {
    let [a2, b2, i2, c2] = this.constraint;
    let j2 = (0, inequal_1.ineq)(i2).flip();
    return new Rein([a2, b2, j2, c2]);
  }
  intersectWith(another) {
    let [a1, b1, i1, c1] = this.constraint;
    let [a2, b2, i2, c2] = another.constraint;
    if (a1 / b1 === a2 / b2)
      return void 0;
    return (0, cal_1.crammer)(a1, b1, c1, a2, b2, c2);
  }
  shake() {
    return Math.random() > 0.5 ? this.clone() : this.flip();
  }
  toLinear() {
    let [a2, b2, i2, c2] = this.constraint;
    return [a2, b2, -c2];
  }
  toStandard() {
    let [a2, b2, i2, c2] = this.constraint;
    return [a2, b2, c2];
  }
}
rein$2.Rein = Rein;
function rein$1(constraint2) {
  return new Rein(constraint2);
}
rein$2.rein = rein$1;
Object.defineProperty(reins$1, "__esModule", { value: true });
reins$1.toReins = reins$1.reins = reins$1.Reins = void 0;
const rein_1 = rein$2;
const list_1$2 = list$2;
const shape2D_1 = shape2D$2;
const vector2D_1 = vector2D$1;
class Reins extends list_1$2.List {
  constructor() {
    super(...arguments);
    this.EDGE = 100;
    this.EDGE_CONSTRAINTS = [
      new rein_1.Rein([1, 0, "<=", this.EDGE]),
      new rein_1.Rein([1, 0, ">=", -this.EDGE]),
      new rein_1.Rein([0, 1, "<=", this.EDGE]),
      new rein_1.Rein([0, 1, ">=", -this.EDGE])
    ];
  }
  fullConstraints() {
    let cons = this.clone();
    cons.push(...this.EDGE_CONSTRAINTS);
    return cons;
  }
  constraints() {
    return this.map(($) => $.constraint);
  }
  onEdge(point) {
    let [x2, y2] = point;
    return Math.abs(x2) + 1 >= this.EDGE || Math.abs(y2) + 1 >= this.EDGE;
  }
  contains(point) {
    return this.every(($) => $.contains(point));
  }
  looseContains(point) {
    return this.map(($) => $.loose()).every(($) => $.contains(point));
  }
  polygon() {
    let cons = this.fullConstraints();
    let vs = (0, shape2D_1.shape2D)();
    for (let i2 = 0; i2 < cons.length; i2++) {
      for (let j2 = i2 + 1; j2 < cons.length; j2++) {
        let p2 = cons[i2].intersectWith(cons[j2]);
        if (p2 === void 0)
          continue;
        let others = cons.clone();
        others.pull(j2);
        others.pull(i2);
        if (others.looseContains(p2))
          vs.push((0, vector2D_1.vec2D)(p2));
      }
    }
    vs = vs.uniqueDeep();
    vs.sortAroundMean();
    return vs.toArray();
  }
  vertices() {
    return this.polygon().filter(($) => !this.onEdge($));
  }
  isBounded() {
    return this.polygon().every(($) => !this.onEdge($));
  }
  isConsistent() {
    return this.polygon().length > 2;
  }
  integrals() {
    let vs = (0, list_1$2.toList)(this.polygon());
    let ymax = Math.ceil(vs.maxOf(([x2, y2]) => y2));
    let xmax = Math.ceil(vs.maxOf(([x2, y2]) => x2));
    let xmin = Math.floor(vs.minOf(([x2, y2]) => x2));
    let ymin = Math.floor(vs.minOf(([x2, y2]) => y2));
    let points = [];
    for (let i2 = xmin; i2 <= xmax; i2++) {
      for (let j2 = ymin; j2 <= ymax; j2++) {
        let p2 = [i2, j2];
        if (this.contains(p2))
          points.push(p2);
      }
    }
    return points;
  }
  shake() {
    let cons = this.map(($) => $.shake());
    return this.create(cons);
  }
}
reins$1.Reins = Reins;
function reins(...constraints2) {
  let cs = new Reins();
  cs.push(...constraints2.map(($) => new rein_1.Rein($)));
  return cs;
}
reins$1.reins = reins;
function toReins$1(constraints2) {
  return reins(...constraints2);
}
reins$1.toReins = toReins$1;
Object.defineProperty(optimizer$2, "__esModule", { value: true });
optimizer$2.optimizer = optimizer$2.Optimizer = void 0;
const reins_1 = reins$1;
const list_1$1 = list$2;
class Optimizer {
  constructor({ field: field2, feasiblePoints = [] }) {
    this.field = [0, 0, 0];
    this.feasiblePoints = (0, list_1$1.list)();
    this.field = field2;
    this.feasiblePoints = (0, list_1$1.toList)(feasiblePoints);
  }
  onEdge(point) {
    return new reins_1.Reins().onEdge(point);
  }
  fieldAt(point) {
    const [a2, b2, c2] = this.field;
    const [x2, y2] = point;
    return a2 * x2 + b2 * y2 + c2;
  }
  maxPoints() {
    return this.feasiblePoints.maxsBy(($) => this.fieldAt($)).uniqueDeep().violate(($) => this.onEdge($));
  }
  minPoints() {
    return this.feasiblePoints.minsBy(($) => this.fieldAt($)).uniqueDeep().violate(($) => this.onEdge($));
  }
  optimalPoints(max2) {
    return max2 ? this.maxPoints() : this.minPoints();
  }
  max() {
    let pts = this.maxPoints();
    if (pts.length === 0)
      return null;
    return this.fieldAt(pts[0]);
  }
  min() {
    let pts = this.minPoints();
    if (pts.length === 0)
      return null;
    return this.fieldAt(pts[0]);
  }
  optimal(max2) {
    return max2 ? this.max() : this.min();
  }
}
optimizer$2.Optimizer = Optimizer;
function optimizer$1({ field: field2, feasiblePoints = [] }) {
  return new Optimizer({ field: field2, feasiblePoints });
}
optimizer$2.optimizer = optimizer$1;
var linear = {};
Object.defineProperty(linear, "__esModule", { value: true });
linear.lin = linear.Linear = void 0;
const numbers_1 = numbers$2;
function slope(A2, B2) {
  let [x1, y1] = A2;
  let [x2, y2] = B2;
  return (y2 - y1) / (x2 - x1);
}
function midpoint(A2, B2) {
  let [x1, y1] = A2;
  let [x2, y2] = B2;
  return [(x1 + x2) / 2, (y1 + y2) / 2];
}
class Linear {
  constructor() {
    this._linear = [NaN, NaN, NaN];
    this.defined = false;
  }
  byLinear(linear2) {
    this._linear = linear2;
    this.defined = true;
    return this;
  }
  byStandard(standard) {
    let [a2, b2, _c] = standard;
    this.byLinear([a2, b2, -_c]);
    return this;
  }
  byTwoPoints(p1, p2) {
    let [x1, y1] = p1;
    let [x2, y2] = p2;
    let dx = x1 - x2;
    let dy = y1 - y2;
    if (dx === 0 && dy === 0)
      return this;
    let [a2, b2, c2] = [dy, -dx, dx * y1 - dy * x1];
    let s2 = Math.sign(a2) || Math.sign(b2) || 1;
    [a2, b2, c2] = (0, numbers_1.numbers)(a2, b2, c2).times(s2).ratio();
    this.byLinear([a2, b2, c2]);
    return this;
  }
  byPointSlope(p2, m2) {
    let p22 = [p2[0] + 1, p2[1] + m2];
    this.byTwoPoints(p2, p22);
    return this;
  }
  byIntercepts(x2, y2) {
    if (x2 === 0 || y2 === 0)
      return this;
    this.byTwoPoints([x2, 0], [0, y2]);
    return this;
  }
  byBisector(A2, B2) {
    let [x1, y1] = A2;
    let [x2, y2] = B2;
    if (x1 === x2 && y1 === y2)
      return this;
    if (x1 === x2) {
      this.byLinear([0, 1, -(y1 + y2) / 2]);
    } else if (y1 === y2) {
      this.byLinear([1, 0, -(x1 + x2) / 2]);
    } else {
      let m2 = -1 / slope(A2, B2);
      let M2 = midpoint(A2, B2);
      this.byPointSlope(M2, m2);
    }
    return this;
  }
  slope() {
    let [a2, b2, c2] = this._linear;
    return b2 === 0 ? NaN : -a2 / b2;
  }
  xInt() {
    let [a2, b2, c2] = this._linear;
    return a2 === 0 ? NaN : -c2 / a2;
  }
  yInt() {
    let [a2, b2, c2] = this._linear;
    return b2 === 0 ? NaN : -c2 / b2;
  }
  toLinear() {
    if (!this.defined)
      return [NaN, NaN, NaN];
    return this._linear;
  }
  toLine() {
    if (!this.defined)
      return [NaN, NaN];
    return [this.slope(), this.yInt()];
  }
  toStandard() {
    if (!this.defined)
      return [NaN, NaN, NaN];
    let [a2, b2, c2] = this._linear;
    return [a2, b2, -c2];
  }
  toConstraint(ineq2) {
    let [a2, b2, c2] = this.toStandard();
    return [a2, b2, ineq2, c2];
  }
}
linear.Linear = Linear;
function lin$1() {
  return new Linear();
}
linear.lin = lin$1;
var contract$2 = {};
var blood = {};
Object.defineProperty(blood, "__esModule", { value: true });
blood.Blood = void 0;
class Blood extends Error {
  constructor(name, message) {
    super(message);
    this.name = name + "Error";
  }
}
blood.Blood = Blood;
Object.defineProperty(contract$2, "__esModule", { value: true });
contract$2.contract = void 0;
const blood_1$2 = blood;
class ContractErrorFactory {
  constructor(host) {
    this.name = host.name;
    this.signature = this.getSignature(host);
  }
  getSignature(func) {
    const fnStr = func.toString();
    return fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")"));
  }
  ArgBlood(argIndex, argValue, predicate) {
    let i2 = String(argIndex);
    let v2 = JSON.stringify(argValue);
    let p2 = predicate.name || predicate.toString();
    return new blood_1$2.Blood("Contract", "(" + this.name + ")\narg(" + this.signature + ")[" + i2 + "] = " + v2 + "\nviolate: " + p2);
  }
  ArgGrpBlood(argValues, predicate) {
    let a2 = argValues.map((_) => JSON.stringify(_)).join(",");
    let p2 = predicate.name || predicate.toString();
    return new blood_1$2.Blood("Contract", "(" + this.name + ")\narg(" + this.signature + ") = (" + a2 + ")\nviolate: " + p2);
  }
  ReturnBlood(argValues, returnValue, predicate) {
    let v2 = returnValue;
    let a2 = argValues.map((_) => JSON.stringify(_)).join(",");
    let p2 = predicate.name || predicate.toString();
    return new blood_1$2.Blood("Contract", "(" + this.name + ")\nfrom arg(" + this.signature + ") = (" + a2 + ")\n=> return = " + v2 + "\nviolate: " + p2);
  }
  CatchBlood(argValues, e2) {
    let a2 = argValues.map((_) => JSON.stringify(_)).join(",");
    if (typeof e2 === "string") {
      return new blood_1$2.Blood("Contract", "(" + this.name + ")\nfrom arg(" + this.signature + ") = (" + a2 + ")\nthrow:\n" + e2);
    }
    if (typeof e2 === "object" && e2 !== null && "name" in e2 && "message" in e2) {
      let { name, message } = e2;
      return new blood_1$2.Blood("Contract", "(" + this.name + ")\nfrom arg(" + this.signature + ") = (" + a2 + ")\nthrow:\n" + name + "\nwith message:\n" + message);
    }
    return new blood_1$2.Blood("Contract", "(" + this.name + ")\nfrom arg(" + this.signature + ") = (" + a2 + ")\nthrow:\n" + JSON.stringify(e2));
  }
}
class Contract {
  constructor(host) {
    this.host = host;
    this.Err = new ContractErrorFactory(host);
  }
  validateArg(f2, rules) {
    let policy = shieldArrays(rules);
    function rule(index) {
      const n2 = policy.length - 1;
      return policy[Math.min(index, n2)];
    }
    const newFunc = (...args) => {
      for (let i2 = 0; i2 < args.length; i2++) {
        const arg = args[i2];
        for (let pd of rule(i2)) {
          if (!pd(arg))
            throw this.Err.ArgBlood(i2, arg, pd);
        }
      }
      return f2(...args);
    };
    return newFunc;
  }
  validateArgGrp(f2, argRule) {
    let r2 = shieldArray(argRule);
    const newFunc = (...args) => {
      for (let pd of r2) {
        if (!pd(...args))
          throw this.Err.ArgGrpBlood(args, pd);
      }
      return f2(...args);
    };
    return newFunc;
  }
  validateReturn(f2, rule) {
    let r2 = shieldArray(rule);
    const newFunc = (...args) => {
      const result2 = f2(...args);
      for (let pd of r2) {
        if (!pd(result2))
          throw this.Err.ReturnBlood(args, result2, pd);
      }
      return result2;
    };
    return newFunc;
  }
  validateCatch(f2) {
    const newFunc = (...args) => {
      try {
        return f2(...args);
      } catch (e2) {
        throw this.Err.CatchBlood(args, e2);
      }
    };
    return newFunc;
  }
  sign(arg, ret) {
    return this.seal({ arg, ret });
  }
  seal({ arg, args, ret }) {
    let f2 = this.host;
    f2 = this.validateCatch(f2);
    if (ret !== void 0)
      f2 = this.validateReturn(f2, ret);
    if (args !== void 0)
      f2 = this.validateArgGrp(f2, args);
    if (arg !== void 0 && arg.length > 0)
      f2 = this.validateArg(f2, arg);
    return f2;
  }
}
function shieldArray(item) {
  return Array.isArray(item) ? item : [item];
}
function shieldArrays(items) {
  return items.map(shieldArray);
}
function contract$1(f2) {
  return new Contract(f2);
}
contract$2.contract = contract$1;
var poker$1 = {};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  Object.defineProperty(o2, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result2 = {};
  if (mod2 != null) {
    for (var k2 in mod2)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
        __createBinding(result2, mod2, k2);
  }
  __setModuleDefault(result2, mod2);
  return result2;
};
Object.defineProperty(poker$1, "__esModule", { value: true });
poker$1.bool = poker$1.she = poker$1.he = poker$1.prime = poker$1.real = poker$1.integer = void 0;
const blood_1$1 = blood;
const cal$1 = __importStar(cal$3);
const list_1 = list$2;
function integer(min2, max2) {
  min2 = Math.ceil(min2);
  max2 = Math.floor(max2);
  if (min2 > max2)
    throw new blood_1$1.Blood("Poker", "min must be less than max!");
  return Math.floor(Math.random() * (max2 - min2 + 1) + min2);
}
poker$1.integer = integer;
function real(min2, max2) {
  if (min2 > max2)
    throw new blood_1$1.Blood("Poker", "min must be less than max!");
  return Math.random() * (max2 - min2) + min2;
}
poker$1.real = real;
function prime(min2, max2) {
  if (min2 > max2)
    throw new blood_1$1.Blood("Poker", "min must be less than max!");
  let primes2 = (0, list_1.list)(...cal$1.primes(max2));
  primes2.sieve(($) => $ >= min2);
  return primes2.draw();
}
poker$1.prime = prime;
function he() {
  const boys = (0, list_1.list)("Aaron", "Adam", "Alan", "Alexander", "Andrew", "Ben", "Brian", "Cameron", "Charlie", "Colin", "Daniel", "David", "Derek", "Donald", "Edward", "Eric", "Ethan", "Frank", "Gary", "George", "Gordon", "Harris", "Harry", "Jack", "Jacob", "James", "Jamie", "Jason", "John", "Jordan", "Joseph", "Kevin", "Kyle", "Leo", "Lewis", "Lucas", "Martin", "Mason", "Matthew", "Michael", "Nathan", "Nicholas", "Noah", "Oliver", "Patrick", "Paul", "Peter", "Philip", "Riley", "Robert", "Rory", "Ryan", "Samuel", "Scott", "Stephen", "Steven", "Thomas", "Timothy", "William");
  return boys.draw();
}
poker$1.he = he;
function she() {
  const girls = (0, list_1.list)("Abbie", "Alice", "Alison", "Amanda", "Amelia", "Amy", "Angela", "Ann", "Anna", "Ashley", "Cara", "Carol", "Caroline", "Charlotte", "Cheryl", "Chloe", "Christine", "Claire", "Donna", "Elaine", "Ella", "Ellie", "Emily", "Emma", "Eva", "Fiona", "Gillian", "Grace", "Hazel", "Helen", "Holly", "Ivy", "Jacqueline", "Jade", "Janet", "Jennifer", "Jessica", "Julie", "Karen", "Kate", "Katie", "Kelly", "Kirsty", "Lily", "Linda", "Lisa", "Lorraine", "Louise", "Lucy", "Mandy", "Mary", "Michelle", "Natalie", "Nicole", "Olivia", "Pamela", "Pauline", "Rachel", "Rebecca", "Rosie", "Samantha", "Sarah", "Shannon", "Sharon", "Sophia", "Sophie", "Stephanie", "Susan", "Tracey", "Tracy", "Valerie", "Victoria", "Wendy", "Zoe");
  return girls.draw();
}
poker$1.she = she;
function bool$1(trueChance = 0.5) {
  return real(0, 1) < trueChance;
}
poker$1.bool = bool$1;
var dice$2 = {};
Object.defineProperty(dice$2, "__esModule", { value: true });
dice$2.dice = dice$2.Dice = void 0;
const blood_1 = blood;
class Dice {
  constructor(func) {
    this.TRIAL = 1e4;
    this.shields = [];
    this.uniques = [];
    this.distincts = [];
    this.coherents = [];
    this.func = func;
  }
  shield(predicate) {
    this.shields.push(predicate);
    return this;
  }
  forbid(...items) {
    for (let item of items)
      this.shield(($) => JSON.stringify($) !== JSON.stringify(item));
    return this;
  }
  unique(mapper = ($) => $) {
    let map = ($) => JSON.stringify(mapper($));
    this.uniques.push(map);
    return this;
  }
  distinct(equality) {
    this.distincts.push(equality);
    return this;
  }
  coherent(predicate) {
    this.coherents.push(predicate);
    return this;
  }
  roll() {
    let counter = 0;
    while (true) {
      counter++;
      if (counter > this.TRIAL) {
        throw new blood_1.Blood("Dice", "No items can satisfy predicate after " + this.TRIAL + " trials!");
      }
      let item = this.func();
      if (this.shields.every(($) => $(item)))
        return item;
    }
  }
  rolls(count) {
    let counter = 0;
    const genRandomCohort = () => {
      let arr = [];
      let mappeds = [];
      for (let i2 = 0; i2 < this.uniques.length; i2++) {
        mappeds.push([]);
      }
      const pushMap = (itemMap) => {
        mappeds.forEach((mapped, i2) => mapped.push(itemMap[i2]));
      };
      const mapInclude = (itemMap) => {
        return mappeds.some((mapped, i2) => mapped.includes(itemMap[i2]));
      };
      const someEqual = (item) => {
        return this.distincts.some((equal2) => arr.some(($) => equal2($, item)));
      };
      while (arr.length < count) {
        counter++;
        if (counter > this.TRIAL) {
          throw new blood_1.Blood("Dice", "rolls count is likely too large for sample set");
        }
        let item = this.roll();
        let map = this.uniques.map(($) => $(item));
        if (mapInclude(map))
          continue;
        if (someEqual(item))
          continue;
        arr.push(item);
        pushMap(map);
      }
      return arr;
    };
    const isCoherent = (cohort) => {
      return this.coherents.every(($) => $(cohort));
    };
    while (true) {
      let cohort = genRandomCohort();
      if (isCoherent(cohort))
        return cohort;
    }
  }
}
dice$2.Dice = Dice;
function dice$1(func) {
  return new Dice(func);
}
dice$2.dice = dice$1;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result2 = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding2(result2, mod2, k2);
    }
    __setModuleDefault2(result2, mod2);
    return result2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dice = exports.poker = exports.contract = exports.lin = exports.cal = exports.rein = exports.Rein = exports.reins = exports.toReins = exports.Reins = exports.optimizer = exports.Optimizer = exports.ineq = exports.Pencil = exports.vec3D = exports.vector3D = exports.Vector3D = exports.vec2D = exports.vector2D = exports.Vector2D = exports.toVector = exports.vector = exports.Vector = exports.toSheet = exports.sheet = exports.Sheet = exports.toShape3D = exports.shape3D = exports.Shape3D = exports.toShape2D = exports.shape2D = exports.Shape2D = exports.toShape = exports.shape = exports.Shape = exports.toNumbers = exports.numbers = exports.Numbers = exports.toList = exports.list = exports.List = exports.toData = exports.data = exports.Data = void 0;
  var data_1 = data$1;
  Object.defineProperty(exports, "Data", { enumerable: true, get: function() {
    return data_1.Data;
  } });
  Object.defineProperty(exports, "data", { enumerable: true, get: function() {
    return data_1.data;
  } });
  Object.defineProperty(exports, "toData", { enumerable: true, get: function() {
    return data_1.toData;
  } });
  var list_12 = list$2;
  Object.defineProperty(exports, "List", { enumerable: true, get: function() {
    return list_12.List;
  } });
  Object.defineProperty(exports, "list", { enumerable: true, get: function() {
    return list_12.list;
  } });
  Object.defineProperty(exports, "toList", { enumerable: true, get: function() {
    return list_12.toList;
  } });
  var numbers_12 = numbers$2;
  Object.defineProperty(exports, "Numbers", { enumerable: true, get: function() {
    return numbers_12.Numbers;
  } });
  Object.defineProperty(exports, "numbers", { enumerable: true, get: function() {
    return numbers_12.numbers;
  } });
  Object.defineProperty(exports, "toNumbers", { enumerable: true, get: function() {
    return numbers_12.toNumbers;
  } });
  var shape_12 = shape$1;
  Object.defineProperty(exports, "Shape", { enumerable: true, get: function() {
    return shape_12.Shape;
  } });
  Object.defineProperty(exports, "shape", { enumerable: true, get: function() {
    return shape_12.shape;
  } });
  Object.defineProperty(exports, "toShape", { enumerable: true, get: function() {
    return shape_12.toShape;
  } });
  var shape2D_12 = shape2D$2;
  Object.defineProperty(exports, "Shape2D", { enumerable: true, get: function() {
    return shape2D_12.Shape2D;
  } });
  Object.defineProperty(exports, "shape2D", { enumerable: true, get: function() {
    return shape2D_12.shape2D;
  } });
  Object.defineProperty(exports, "toShape2D", { enumerable: true, get: function() {
    return shape2D_12.toShape2D;
  } });
  var shape3D_12 = shape3D$1;
  Object.defineProperty(exports, "Shape3D", { enumerable: true, get: function() {
    return shape3D_12.Shape3D;
  } });
  Object.defineProperty(exports, "shape3D", { enumerable: true, get: function() {
    return shape3D_12.shape3D;
  } });
  Object.defineProperty(exports, "toShape3D", { enumerable: true, get: function() {
    return shape3D_12.toShape3D;
  } });
  var sheet_1 = sheet$1;
  Object.defineProperty(exports, "Sheet", { enumerable: true, get: function() {
    return sheet_1.Sheet;
  } });
  Object.defineProperty(exports, "sheet", { enumerable: true, get: function() {
    return sheet_1.sheet;
  } });
  Object.defineProperty(exports, "toSheet", { enumerable: true, get: function() {
    return sheet_1.toSheet;
  } });
  var vector_12 = vector$2;
  Object.defineProperty(exports, "Vector", { enumerable: true, get: function() {
    return vector_12.Vector;
  } });
  Object.defineProperty(exports, "vector", { enumerable: true, get: function() {
    return vector_12.vector;
  } });
  Object.defineProperty(exports, "toVector", { enumerable: true, get: function() {
    return vector_12.toVector;
  } });
  var vector2D_12 = vector2D$1;
  Object.defineProperty(exports, "Vector2D", { enumerable: true, get: function() {
    return vector2D_12.Vector2D;
  } });
  Object.defineProperty(exports, "vector2D", { enumerable: true, get: function() {
    return vector2D_12.vector2D;
  } });
  Object.defineProperty(exports, "vec2D", { enumerable: true, get: function() {
    return vector2D_12.vec2D;
  } });
  var vector3D_12 = vector3D$2;
  Object.defineProperty(exports, "Vector3D", { enumerable: true, get: function() {
    return vector3D_12.Vector3D;
  } });
  Object.defineProperty(exports, "vector3D", { enumerable: true, get: function() {
    return vector3D_12.vector3D;
  } });
  Object.defineProperty(exports, "vec3D", { enumerable: true, get: function() {
    return vector3D_12.vec3D;
  } });
  var pencil_1 = pencil;
  Object.defineProperty(exports, "Pencil", { enumerable: true, get: function() {
    return pencil_1.Pencil;
  } });
  var inequal_12 = inequal;
  Object.defineProperty(exports, "ineq", { enumerable: true, get: function() {
    return inequal_12.ineq;
  } });
  var optimizer_1 = optimizer$2;
  Object.defineProperty(exports, "Optimizer", { enumerable: true, get: function() {
    return optimizer_1.Optimizer;
  } });
  Object.defineProperty(exports, "optimizer", { enumerable: true, get: function() {
    return optimizer_1.optimizer;
  } });
  var reins_12 = reins$1;
  Object.defineProperty(exports, "Reins", { enumerable: true, get: function() {
    return reins_12.Reins;
  } });
  Object.defineProperty(exports, "toReins", { enumerable: true, get: function() {
    return reins_12.toReins;
  } });
  Object.defineProperty(exports, "reins", { enumerable: true, get: function() {
    return reins_12.reins;
  } });
  var rein_12 = rein$2;
  Object.defineProperty(exports, "Rein", { enumerable: true, get: function() {
    return rein_12.Rein;
  } });
  Object.defineProperty(exports, "rein", { enumerable: true, get: function() {
    return rein_12.rein;
  } });
  exports.cal = __importStar2(cal$3);
  var linear_1 = linear;
  Object.defineProperty(exports, "lin", { enumerable: true, get: function() {
    return linear_1.lin;
  } });
  var contract_1 = contract$2;
  Object.defineProperty(exports, "contract", { enumerable: true, get: function() {
    return contract_1.contract;
  } });
  exports.poker = __importStar2(poker$1);
  var dice_1 = dice$2;
  Object.defineProperty(exports, "dice", { enumerable: true, get: function() {
    return dice_1.dice;
  } });
})(lib);
const num = (_) => Number.isFinite(_);
const whole = (_) => Number.isInteger(_);
const int = (_) => num(_) && Number.isInteger(cal.blur(_));
const dec = (_) => num(_) && !int(_);
const terminating = (_) => num(_) && cal.sigfig(_) < 10;
const rational = (_) => num(_) && cal.isRational(_);
const irrational = (_) => num(_) && !cal.isRational(_);
const odd = (_) => int(_) && Math.abs(cal.blur(_)) % 2 === 1;
const even = (_) => int(_) && Math.abs(cal.blur(_)) % 2 === 0;
const prob = (_) => num(_) && _ >= 0 && _ <= 1;
const sq$1 = (_) => int(_) && int(Math.sqrt(_));
const positive = (_) => num(_) && _ > 0;
const positiveInt = (_) => int(_) && _ > 0;
const nonNegative = (_) => num(_) && _ >= 0;
const nonNegativeInt = (_) => int(_) && _ >= 0;
const negative = (_) => num(_) && _ < 0;
const negativeInt = (_) => int(_) && _ < 0;
const nonPositive = (_) => num(_) && _ <= 0;
const nonPositiveInt = (_) => int(_) && _ <= 0;
const zero = (_) => num(_) && Math.abs(_) < 1e-14;
const nonZero = (_) => num(_) && !zero(_);
const nonZeroInt = (_) => int(_) && !zero(_);
const between = (min2, max2) => build(`between(${min2},${max2})`, (_) => num(_) && _ >= min2 && _ <= max2);
const absBetween = (min2, max2) => build(`absBetween(${min2},${max2})`, (_) => num(_) && Math.abs(_) >= min2 && Math.abs(_) <= max2);
const str$1 = (_) => typeof _ === "string";
const bool = (_) => typeof _ === "boolean";
const object = (_) => typeof _ === "object" && _ !== null;
const emptyObject = (_) => object(_) && !!_ && _.constructor === Object && Object.keys(_).length === 0;
const array = (_) => Array.isArray(_);
const arrayOfLength = (length) => build(`arrayOfLength(${length})`, (_) => array(_) && _.length === length);
const arrayWith = (predicate) => build(`arrayWith(${predicate.name})`, (_) => array(_) && _.every(predicate));
const couple = (_) => arrayOfLength(2)(_) && arrayWith(num)(_);
const triple = (_) => arrayOfLength(3)(_) && arrayWith(num)(_);
const combo = (_) => arrayOfLength(3)(_) && arrayWith(bool)(_);
const ntuple = (_) => arrayWith(num)(_);
const interval = (_) => couple(_) && _[0] <= _[1];
const point2D = (_) => couple(_);
const point2Ds = (_) => arrayWith(point2D)(_);
const point3D = (_) => triple(_);
const point3Ds = (_) => arrayWith(point3D)(_);
const polar = (_) => couple(_) && _[0] >= 0;
const fraction = (_) => couple(_);
const properFraction = (_) => fraction(_) && _[1] !== 0;
const vector = (_) => couple(_);
const vector3D = (_) => triple(_);
const triangleSides = (_) => {
  if (!triple(_))
    return false;
  let [a2, b2, c2] = _;
  return _.every(positive) && a2 + b2 > c2 && b2 + c2 > a2 && c2 + a2 > b2;
};
const monomial = (_) => object(_) && "coeff" in _ && "vars" in _;
const polynomial = (_) => arrayWith(monomial)(_);
const trigValue = (_) => arrayOfLength(2)(_) && trig(_[0]) && (num(_[1]) || str$1(_[1]));
const trigExp = (_) => arrayOfLength(4)(_) && trig(_[0]) && num(_[1]) && num(_[2]) && str$1(_[3]);
const labeledValue1 = (_) => arrayOfLength(2)(_) && num(_[0]) && str$1(_[1]);
const labeledValue2 = (_) => arrayOfLength(3)(_) && num(_[0]) && str$1(_[1]) && str$1(_[2]);
const labeledValue = (_) => labeledValue1(_) || labeledValue2(_);
const quantity = (_) => object(_) && "val" in _ && "unit" in _;
const pass = (_) => true;
const fail = (_) => false;
const distinct = (_) => toList(_).duplessDeep();
const alphabet = (_) => str$1(_) && _.length === 1 && _.toLowerCase() !== _.toUpperCase();
const ineq$1 = (_) => str$1(_) && [">", "<", ">=", "<=", "\\gt", "\\lt", "\\ge", "\\le"].includes(_);
const dfrac = (_) => {
  const f2 = String.raw`-?\\dfrac{(-?\d+\.?\d*)}{(-?\d+\.?\d*)}`;
  return str$1(_) && !!_.match(new RegExp(f2, "g"));
};
const constraint = (_) => arrayOfLength(4)(_) && num(_[0]) && num(_[1]) && ineq$1(_[2]) && num(_[3]);
const constraints = (_) => arrayWith(constraint)(_);
const field = (_) => triple(_);
const quadrantCode = (_) => int(_) && [1, 2, 3, 4].includes(_);
const quadrantName = (_) => str$1(_) && ["I", "II", "III", "IV"].includes(_);
const quadrant = (_) => quadrantCode(_) || quadrantName(_);
const trig = (_) => str$1(_) && ["sin", "cos", "tan"].includes(_);
const roman = (_) => str$1(_) && ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X"].includes(_);
const base = (_) => str$1(_) && _.match(/[0-9A-Z]+\_\{[0-9]+\}/g) !== null;
function build(funcName, func) {
  const holder = { [funcName](arg) {
    return func(arg);
  } };
  return holder[funcName];
}
function and(pds, name) {
  name != null ? name : name = "(" + pds.map((f2) => f2.name).join(" && ") + ")";
  return build(name, (_) => pds.every((p2) => p2(_)));
}
function or$1(pds, name) {
  name != null ? name : name = "(" + pds.map((f2) => f2.name).join(" || ") + ")";
  return build(name, (_) => pds.some((p2) => p2(_)));
}
function every(pd, name) {
  name != null ? name : name = "(every." + pd.name + ")";
  return build(name, (_) => array(_) && _.every(pd));
}
var $Owl = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  num,
  whole,
  int,
  dec,
  terminating,
  rational,
  irrational,
  odd,
  even,
  prob,
  sq: sq$1,
  positive,
  positiveInt,
  nonNegative,
  nonNegativeInt,
  negative,
  negativeInt,
  nonPositive,
  nonPositiveInt,
  zero,
  nonZero,
  nonZeroInt,
  between,
  absBetween,
  str: str$1,
  bool,
  object,
  emptyObject,
  array,
  arrayOfLength,
  arrayWith,
  couple,
  triple,
  combo,
  ntuple,
  interval,
  point2D,
  point2Ds,
  point3D,
  point3Ds,
  polar,
  fraction,
  properFraction,
  vector,
  vector3D,
  triangleSides,
  monomial,
  polynomial,
  trigValue,
  trigExp,
  labeledValue1,
  labeledValue2,
  labeledValue,
  quantity,
  pass,
  fail,
  distinct,
  alphabet,
  ineq: ineq$1,
  dfrac,
  constraint,
  constraints,
  field,
  quadrantCode,
  quadrantName,
  quadrant,
  trig,
  roman,
  base,
  and,
  or: or$1,
  every
});
function printDfrac(numerator, denominator, upSign = false) {
  let p2 = numerator;
  let q2 = denominator;
  if (p2 === 0)
    return "0";
  [p2, q2] = cal.toFraction(p2 / q2);
  if (q2 === 1)
    return p2.toString();
  if (upSign) {
    return "\\dfrac{" + p2 + "}{" + q2 + "}";
  } else {
    return p2 > 0 ? "\\dfrac{" + p2 + "}{" + q2 + "}" : "-\\dfrac{" + Math.abs(p2) + "}{" + q2 + "}";
  }
}
function printCombo(combo2) {
  let [a2, b2, c2] = combo2;
  if (a2 && b2 && c2)
    return "I, II and III";
  if (a2 && b2 && !c2)
    return "I and II only";
  if (a2 && !b2 && c2)
    return "I and III only";
  if (a2 && !b2 && !c2)
    return "I only";
  if (!a2 && b2 && c2)
    return "II and III only";
  if (!a2 && b2 && !c2)
    return "II only";
  if (!a2 && !b2 && c2)
    return "III only";
  if (!a2 && !b2 && !c2)
    return "None of the above";
  throw "never";
}
function printTrigValue(T2) {
  if (typeof T2[1] === "number") {
    return "\\" + T2[0] + " " + T2[1] + "\xB0";
  } else {
    return "\\" + T2[0] + " " + T2[1];
  }
}
function printTrigExp(T2) {
  return "\\" + T2[0] + "(" + T2[1] + "\xB0" + (T2[2] > 0 ? "+" : "-") + T2[3] + ")";
}
function printOrTrigRoots(roots) {
  roots = roots.filter(owl.num);
  roots = roots.map((x2) => Round(x2, 5));
  let ss = roots.map((x2) => x2 + "\xB0");
  if (ss.length === 0)
    return "no solution";
  if (ss.length === 1)
    return ss[0];
  let last = ss.pop();
  return ss.join(",") + "~\\text{or}~" + last;
}
function printSurd(num2) {
  let [p2, q2] = cal.toSurd(num2);
  let T2;
  if (p2 === 1) {
    T2 = q2 === 1 ? "1" : "\\sqrt{" + q2 + "}";
  } else if (p2 === -1) {
    T2 = q2 === 1 ? "-1" : "-\\sqrt{" + q2 + "}";
  } else {
    T2 = q2 === 1 ? p2.toString() : p2 + "\\sqrt{" + q2 + "}";
  }
  return T2;
}
function printPointPolar(point) {
  let [r2, q2] = RectToPol(point);
  q2 = cal.blur(q2);
  return `(${printSurd(r2)},${q2}\xB0)`;
}
function printConstraint(con, align = false, replaceEqual = false) {
  let [a2, b2, i2, c2] = con;
  if (i2 === ">=")
    i2 = "\\ge";
  if (i2 === ">")
    i2 = "\\gt";
  if (i2 === "<=")
    i2 = "\\le";
  if (i2 === "<")
    i2 = "\\lt";
  let j2 = i2;
  if (replaceEqual)
    j2 = "=";
  if (align)
    j2 = " & " + j2;
  if (a2 === 0 && b2 === 0)
    return ` 0 ${j2} ${c2} `;
  if (a2 !== 0 && b2 === 0)
    return ` ${a2}x ${j2} ${c2} `;
  if (a2 === 0 && b2 !== 0)
    return ` ${b2}y ${j2} ${c2} `;
  return ` ${a2}x + ${b2}y ${j2} ${c2} `;
}
function printConstraints(cons) {
  let T2 = "";
  T2 += " \\left\\{ \\begin{aligned} ";
  for (let c2 of cons) {
    T2 += printConstraint(c2, true) + " \\\\ ";
  }
  T2 += " \\end{aligned} \\right. ";
  return T2;
}
function printLabeledValue(obj, order = 1, isAngle = false) {
  let value = obj[0];
  let label = obj[order];
  let T2 = label + " = " + value;
  if (isAngle)
    T2 += "\xB0";
  return T2;
}
var $Ink = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  printDfrac,
  printCombo,
  printTrigValue,
  printTrigExp,
  printOrTrigRoots,
  printSurd,
  printPointPolar,
  printConstraint,
  printConstraints,
  printLabeledValue
});
globalThis.poker = lib.poker;
globalThis.dice = lib.dice;
globalThis.contract = lib.contract;
globalThis.cal = lib.cal;
globalThis.data = lib.data;
globalThis.list = lib.list;
globalThis.numbers = lib.numbers;
globalThis.shape = lib.shape;
globalThis.shape2D = lib.shape2D;
globalThis.shape3D = lib.shape3D;
globalThis.vector = lib.vector;
globalThis.vector2D = lib.vector2D;
globalThis.vector3D = lib.vector3D;
globalThis.toData = lib.toData;
globalThis.toList = lib.toList;
globalThis.toNumbers = lib.toNumbers;
globalThis.toShape = lib.toShape;
globalThis.toShape2D = lib.toShape2D;
globalThis.toShape3D = lib.toShape3D;
globalThis.toVector = lib.toVector;
globalThis.vec2D = lib.vec2D;
globalThis.vec3D = lib.vec3D;
globalThis.ineq = lib.ineq;
globalThis.optimizer = lib.optimizer;
globalThis.rein = lib.rein;
globalThis.toReins = lib.toReins;
globalThis.lin = lib.lin;
globalThis.owl = $Owl;
globalThis.ink = $Ink;
function error(msg) {
  const e2 = new Error(msg);
  e2.name = "ContractError";
  return e2;
}
function signature(f2) {
  const s2 = f2.toString();
  return s2.slice(s2.indexOf("(") + 1, s2.indexOf(")"));
}
function str(obj) {
  return JSON.stringify(obj);
}
function join(arr) {
  return arr.map(str).join(",");
}
function err(f2, ...msgs) {
  const h2 = `${f2.wax_name}(${f2.wax_signature})`;
  const ms = [h2, ...msgs];
  return error(ms.join("\n"));
}
function brand(f2) {
  var _a;
  if (!("wax_name" in f2))
    f2.wax_name = (_a = f2.name) != null ? _a : f2.toString();
  if (!("wax_signature" in f2))
    f2.wax_signature = signature(f2);
}
function transferBrand(source, target) {
  target.wax_name = source.wax_name;
  target.wax_signature = source.wax_signature;
}
function makeStaticDecorator(transform) {
  return function(target, key, descriptor) {
    descriptor.value = transform(descriptor.value);
    return descriptor;
  };
}
function getClassStaticNames(constructor) {
  return Object.getOwnPropertyNames(constructor).filter(($) => $ !== "length" && $ !== "prototype" && $ !== "name");
}
function catchString(f2, vals, e2) {
  return err(f2, "args = (" + join(vals) + ")", "throw: " + e2);
}
function catchErrObj(f2, vals, e2) {
  return err(f2, "args = (" + join(vals) + ")", "throw: " + e2.name, "message: " + e2.message);
}
function catchAny(f2, vals, e2) {
  return err(f2, "args = (" + join(vals) + ")", "throw: " + str(e2));
}
function isError(e2) {
  return typeof e2 === "object" && e2 !== null && "name" in e2 && "message" in e2;
}
function isContractError(e2) {
  return isError(e2) && e2.name === "ContractError";
}
function catchErr(f2, vals, e2) {
  if (isContractError(e2))
    return e2;
  if (typeof e2 === "string")
    return catchString(f2, vals, e2);
  if (isError(e2))
    return catchErrObj(f2, vals, e2);
  return catchAny(f2, vals, e2);
}
function capture(f2) {
  brand(f2);
  const nf = (...args) => {
    try {
      return f2(...args);
    } catch (e2) {
      throw catchErr(f2, args, e2);
    }
  };
  transferBrand(f2, nf);
  return nf;
}
function captureAll() {
  return function(constructor) {
    for (let key of getClassStaticNames(constructor)) {
      let descriptor = Object.getOwnPropertyDescriptor(constructor, key);
      if (descriptor !== void 0) {
        descriptor.value = capture(descriptor.value);
        Object.defineProperty(constructor, key, descriptor);
      }
    }
  };
}
function nameOf$1(f2) {
  var _a;
  return (_a = f2.name) != null ? _a : f2.toString();
}
function matchOne$1(val, rule) {
  return rule(val) ? true : nameOf$1(rule);
}
function matchAnd$1(val, rule) {
  for (let p2 of rule)
    if (!p2(val))
      return nameOf$1(p2);
  return true;
}
function matchObj(val, rule) {
  for (let k2 in rule) {
    const has = k2 in val;
    if (!has)
      return "should have property: " + k2;
    const p2 = rule[k2];
    const pass2 = p2(val[k2]);
    if (!pass2)
      return k2 + " -> " + nameOf$1(p2);
  }
  return true;
}
function isOne$1(rule) {
  return typeof rule === "function";
}
function isAnd$1(rule) {
  return Array.isArray(rule);
}
function isObj(rule) {
  return typeof rule === "object" && !Array.isArray(rule) && rule !== null;
}
function matchRule(val, rule) {
  if (isOne$1(rule))
    return matchOne$1(val, rule);
  if (isAnd$1(rule))
    return matchAnd$1(val, rule);
  if (isObj(rule))
    return matchObj(val, rule);
  return "fail to recognize the rule";
}
function nameOf(f2) {
  var _a;
  return (_a = f2.name) != null ? _a : f2.toString();
}
function matchOne(vals, treaty) {
  return treaty(...vals) ? true : nameOf(treaty);
}
function matchAnd(vals, treaty) {
  for (let p2 of treaty)
    if (!p2(...vals))
      return nameOf(p2);
  return true;
}
function isOne(treaty) {
  return typeof treaty === "function";
}
function isAnd(treaty) {
  return Array.isArray(treaty);
}
function matchTreaty(vals, treaty) {
  if (isOne(treaty))
    return matchOne(vals, treaty);
  if (isAnd(treaty))
    return matchAnd(vals, treaty);
  return "fail to recognize the rule";
}
function getToTail(arr, index) {
  const n2 = arr.length - 1;
  const i2 = Math.min(index, n2);
  return arr[i2];
}
function e$2(f2, argIndex, argValue, msg) {
  return err(f2, "arg[" + argIndex + "] = " + str(argValue), "violate: " + msg);
}
function match$1(f2, argIndex, argValue, rule) {
  const pass2 = matchRule(argValue, rule);
  if (pass2 !== true)
    throw e$2(f2, argIndex, argValue, pass2);
}
function check(f2, rules) {
  brand(f2);
  const nf = (...args) => {
    args.forEach((v2, i2) => match$1(f2, i2, v2, getToTail(rules, i2)));
    return f2(...args);
  };
  transferBrand(f2, nf);
  return nf;
}
function checkIt(...rules) {
  return makeStaticDecorator(($) => check($, rules));
}
function e$1(f2, vals, msg) {
  return err(f2, "args = (" + join(vals) + ")", "violate: " + msg);
}
function match(f2, vals, treaty) {
  const pass2 = matchTreaty(vals, treaty);
  if (pass2 !== true)
    throw e$1(f2, vals, pass2);
}
function inspect(f2, treaty) {
  brand(f2);
  const nf = (...args) => {
    match(f2, args, treaty);
    return f2(...args);
  };
  transferBrand(f2, nf);
  return nf;
}
function inspectIt(treaty) {
  return makeStaticDecorator(($) => inspect($, treaty));
}
function expose(name, f2) {
  globalThis[String(name)] = f2;
}
function exposeAll() {
  return function(constructor) {
    for (let key of getClassStaticNames(constructor)) {
      let descriptor = Object.getOwnPropertyDescriptor(constructor, key);
      if (descriptor !== void 0) {
        expose(key, descriptor.value);
      }
    }
  };
}
var __defProp$l = Object.defineProperty;
var __getOwnPropDesc$l = Object.getOwnPropertyDescriptor;
var __decorateClass$l = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$l(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$l(target, key, result2);
  return result2;
};
let Host$l = class {
  static IsNum(...items) {
    return items.every(owl.num);
  }
  static IsInteger(...items) {
    return items.every(owl.int);
  }
  static IsDecimal(...items) {
    return items.every(owl.dec);
  }
  static IsTerminating(...items) {
    return items.every(owl.terminating);
  }
  static IsRational(...items) {
    return items.every(owl.rational);
  }
  static IsOdd(...items) {
    return items.every(owl.odd);
  }
  static IsEven(...items) {
    return items.every(owl.even);
  }
  static IsProbability(...items) {
    return items.every(owl.prob);
  }
  static IsSquareNum(...items) {
    return items.every(owl.sq);
  }
  static IsPositive(...items) {
    return items.every(owl.positive);
  }
  static IsNonNegative(...items) {
    return items.every(owl.nonNegative);
  }
  static IsPositiveInteger(...items) {
    return items.every(owl.positiveInt);
  }
  static IsNonNegativeInteger(...items) {
    return items.every(owl.nonNegativeInt);
  }
  static IsNegative(...items) {
    return items.every(owl.negative);
  }
  static IsNonZero(...items) {
    return items.every(owl.nonZero);
  }
  static IsBetween(min2, max2) {
    return (...items) => items.every(owl.between(min2, max2));
  }
  static IsAbsBetween(min2, max2) {
    return (...items) => items.every(owl.absBetween(min2, max2));
  }
  static IsAroundPoint(anchor, range2) {
    return (...points) => points.every((p2) => ChessboardDistance(anchor, p2) <= range2);
  }
  static IsTriangle(...triangles) {
    return triangles.every(owl.triangleSides);
  }
};
__decorateClass$l([
  checkIt(owl.num),
  inspectIt(function is_range(min2, max2) {
    return min2 < max2;
  })
], Host$l, "IsBetween", 1);
__decorateClass$l([
  checkIt(owl.nonNegative),
  inspectIt(function is_range2(min2, max2) {
    return min2 < max2;
  })
], Host$l, "IsAbsBetween", 1);
__decorateClass$l([
  checkIt(owl.point2D, owl.positive)
], Host$l, "IsAroundPoint", 1);
__decorateClass$l([
  checkIt(owl.triple)
], Host$l, "IsTriangle", 1);
Host$l = __decorateClass$l([
  exposeAll(),
  captureAll()
], Host$l);
var __defProp$k = Object.defineProperty;
var __getOwnPropDesc$k = Object.getOwnPropertyDescriptor;
var __decorateClass$k = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$k(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$k(target, key, result2);
  return result2;
};
let Host$k = class {
  static Factorial(n2) {
    return cal.factorial(n2);
  }
  static nCr(n2, r2) {
    return cal.nCr(n2, r2);
  }
  static nPr(n2, r2) {
    return cal.nPr(n2, r2);
  }
};
__decorateClass$k([
  checkIt(owl.nonNegativeInt)
], Host$k, "Factorial", 1);
__decorateClass$k([
  checkIt(owl.nonNegativeInt),
  inspectIt(function r_less_than_n(n2, r2) {
    return n2 >= r2;
  })
], Host$k, "nCr", 1);
__decorateClass$k([
  checkIt(owl.nonNegativeInt),
  inspectIt(function r_less_than_n2(n2, r2) {
    return n2 >= r2;
  })
], Host$k, "nPr", 1);
Host$k = __decorateClass$k([
  exposeAll(),
  captureAll()
], Host$k);
var __defProp$j = Object.defineProperty;
var __getOwnPropDesc$j = Object.getOwnPropertyDescriptor;
var __decorateClass$j = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$j(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$j(target, key, result2);
  return result2;
};
let Host$j = class {
  static log(b2, N2) {
    const v2 = Math.log(N2) / Math.log(b2);
    return cal.blur(v2);
  }
  static Power(a2, b2) {
    const v2 = Math.pow(a2, b2);
    return cal.blur(v2);
  }
  static Sqrt(x2) {
    const v2 = Math.sqrt(x2);
    return cal.blur(v2);
  }
  static Radian(degree) {
    const v2 = degree / 180 * Math.PI;
    return cal.blur(v2);
  }
  static Degree(radian) {
    const v2 = radian * 180 / Math.PI;
    return cal.blur(v2);
  }
  static sin(x2) {
    if (x2 % 180 === 0)
      return 0;
    let v2 = Math.sin(x2 / 180 * Math.PI);
    return cal.blur(v2);
  }
  static cos(x2) {
    if ((x2 - 90) % 180 === 0)
      return 0;
    let v2 = Math.cos(x2 / 180 * Math.PI);
    return cal.blur(v2);
  }
  static tan(x2) {
    if (x2 % 180 === 0)
      return 0;
    let v2 = Math.tan(x2 / 180 * Math.PI);
    return cal.blur(v2);
  }
  static arcsin(x2) {
    let v2 = Math.asin(x2) * 180 / Math.PI;
    return cal.blur(v2);
  }
  static arccos(x2) {
    let v2 = Math.acos(x2) * 180 / Math.PI;
    return cal.blur(v2);
  }
  static arctan(x2) {
    let v2 = Math.atan(x2) * 180 / Math.PI;
    return cal.blur(v2);
  }
};
__decorateClass$j([
  checkIt(owl.positive)
], Host$j, "log", 1);
__decorateClass$j([
  checkIt(owl.num)
], Host$j, "Power", 1);
__decorateClass$j([
  checkIt(owl.nonNegative)
], Host$j, "Sqrt", 1);
__decorateClass$j([
  checkIt(owl.num)
], Host$j, "Radian", 1);
__decorateClass$j([
  checkIt(owl.num)
], Host$j, "Degree", 1);
__decorateClass$j([
  checkIt(owl.num)
], Host$j, "sin", 1);
__decorateClass$j([
  checkIt(owl.num)
], Host$j, "cos", 1);
__decorateClass$j([
  checkIt(owl.num)
], Host$j, "tan", 1);
__decorateClass$j([
  checkIt(owl.between(-1, 1))
], Host$j, "arcsin", 1);
__decorateClass$j([
  checkIt(owl.between(-1, 1))
], Host$j, "arccos", 1);
__decorateClass$j([
  checkIt(owl.num)
], Host$j, "arctan", 1);
Host$j = __decorateClass$j([
  exposeAll(),
  captureAll()
], Host$j);
var __defProp$i = Object.defineProperty;
var __getOwnPropDesc$i = Object.getOwnPropertyDescriptor;
var __decorateClass$i = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$i(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$i(target, key, result2);
  return result2;
};
let Host$i = class {
  static Slope(A2, B2) {
    return (A2[1] - B2[1]) / (A2[0] - B2[0]);
  }
  static SlopePd(A2, B2) {
    return -1 / Slope(A2, B2);
  }
  static Distance(A2, B2) {
    return ((A2[0] - B2[0]) ** 2 + (A2[1] - B2[1]) ** 2) ** 0.5;
  }
  static ChessboardDistance(A2, B2) {
    let x2 = Abs(A2[0] - B2[0]);
    let y2 = Abs(A2[1] - B2[1]);
    return Max(x2, y2);
  }
  static Mid(...points) {
    return toShape2D(points).mean().toArray();
  }
  static Slide(A2, B2, ratio) {
    let r2 = ratio;
    let s2 = 1 - r2;
    return [A2[0] * s2 + B2[0] * r2, A2[1] * s2 + B2[1] * r2];
  }
  static Rotate(P2, q2, O2 = [0, 0]) {
    return vec2D(O2, P2).rotate(q2).add(O2).blur().toArray();
  }
  static Dir(A2, B2) {
    return vec2D(A2, B2).argument();
  }
  static PdFoot(A2, B2, P2) {
    return vec2D(A2, P2).projectOn(vec2D(A2, B2)).add(A2).toArray();
  }
  static Intersection(A2, B2, C2, D2) {
    return Crammer(B2[1] - A2[1], A2[0] - B2[0], A2[0] * B2[1] - B2[0] * A2[1], D2[1] - C2[1], C2[0] - D2[0], C2[0] * D2[1] - D2[0] * C2[1]);
  }
  static Move(P2, dir2, distance) {
    let q2 = 0;
    if (typeof dir2 === "number") {
      q2 = dir2;
    } else if (owl.point2D(dir2)) {
      q2 = Dir(P2, dir2);
    } else {
      q2 = Dir(dir2[0], dir2[1]);
    }
    let x2 = P2[0] + distance * cos(q2);
    let y2 = P2[1] + distance * sin(q2);
    return [x2, y2];
  }
  static MoveX(P2, distance) {
    let [x2, y2] = P2;
    return [x2 + distance, y2];
  }
  static MoveY(P2, distance) {
    let [x2, y2] = P2;
    return [x2, y2 + distance];
  }
  static Shift(P2, [A2, B2], scale = 1) {
    let [x2, y2] = P2;
    let [xA, yA] = A2;
    let [xB, yB] = B2;
    return [x2 + (xB - xA) * scale, y2 + (yB - yA) * scale];
  }
  static ReflectX(P2) {
    return [P2[0], -P2[1]];
  }
  static ReflectY(P2) {
    return [-P2[0], P2[1]];
  }
  static IntersectAngle(slope1, slope2) {
    let A1 = arctan(slope1);
    let A2 = arctan(slope2);
    let d2 = Abs(A1 - A2);
    if (d2 > 90)
      d2 = 180 - d2;
    return d2;
  }
  static Angle(A2, O2, B2) {
    let anglePolar = AnglePolar(A2, O2, B2);
    let a2 = IsReflex(A2, O2, B2) ? 360 - anglePolar : anglePolar;
    return cal.blur(a2);
  }
  static AnglePolar(A2, O2, B2) {
    let a2 = vec2D(O2, A2).argument();
    let b2 = vec2D(O2, B2).argument();
    return a2 <= b2 ? b2 - a2 : 360 + b2 - a2;
  }
  static IsReflex(A2, O2, B2) {
    let angle2 = AnglePolar(A2, O2, B2);
    return angle2 > 180;
  }
  static RegularPolygon(n2, center, radius, startAngle) {
    let a2 = 360 / n2;
    let arr = [];
    for (let i2 = 0; i2 < n2; i2++) {
      let p2 = PolToRect([radius, startAngle + i2 * a2]);
      p2[0] += center[0];
      p2[1] += center[1];
      p2[0] = cal.blur(p2[0]);
      p2[1] = cal.blur(p2[1]);
      arr.push(p2);
    }
    return arr;
  }
  static ArcLength(radius, theta) {
    return 2 * Math.PI * radius * theta / 360;
  }
  static SectorArea(radius, theta) {
    return Math.PI * radius * radius * theta / 360;
  }
  static IsConvexPolygon(...points) {
    Should(points.length >= 3, "must have at least 3 points to be a polygon");
    return toShape2D(points).isConvex();
  }
  static ArrangePoints(...points) {
    let ss = toShape2D(points);
    ss.sortAroundMean();
    return ss.toArray();
  }
  static OnCircle(angle2) {
    return PolToRect([1, angle2]);
  }
};
__decorateClass$i([
  checkIt(owl.point2D),
  inspectIt(function not_vertical(A2, B2) {
    return !cal.eq(A2[0], B2[0]);
  })
], Host$i, "Slope", 1);
__decorateClass$i([
  checkIt(owl.point2D),
  inspectIt(function not_horizontal(A2, B2) {
    return !cal.eq(A2[1], B2[1]);
  })
], Host$i, "SlopePd", 1);
__decorateClass$i([
  checkIt(owl.point2D)
], Host$i, "Distance", 1);
__decorateClass$i([
  checkIt(owl.point2D)
], Host$i, "ChessboardDistance", 1);
__decorateClass$i([
  checkIt(owl.point2D)
], Host$i, "Mid", 1);
__decorateClass$i([
  checkIt(owl.point2D, owl.point2D, owl.num)
], Host$i, "Slide", 1);
__decorateClass$i([
  checkIt(owl.point2D, owl.num, owl.point2D)
], Host$i, "Rotate", 1);
__decorateClass$i([
  checkIt(owl.point2D),
  inspectIt(function distinct_points(A2, B2) {
    return owl.distinct([A2, B2]);
  })
], Host$i, "Dir", 1);
__decorateClass$i([
  checkIt(owl.point2D),
  inspectIt(function distinct_points2(A2, B2, P2) {
    return owl.distinct([A2, B2]);
  })
], Host$i, "PdFoot", 1);
__decorateClass$i([
  checkIt(owl.point2D),
  inspectIt(function distinct_points3(A2, B2, C2, D2) {
    return owl.distinct([A2, B2]) && owl.distinct([C2, D2]);
  })
], Host$i, "Intersection", 1);
__decorateClass$i([
  checkIt(owl.point2D, owl.or([owl.num, owl.point2D, owl.arrayWith(owl.point2D)]), owl.num)
], Host$i, "Move", 1);
__decorateClass$i([
  checkIt(owl.point2D, owl.num)
], Host$i, "MoveX", 1);
__decorateClass$i([
  checkIt(owl.point2D, owl.num)
], Host$i, "MoveY", 1);
__decorateClass$i([
  checkIt(owl.point2D, owl.point2Ds, owl.num)
], Host$i, "Shift", 1);
__decorateClass$i([
  checkIt(owl.point2D)
], Host$i, "ReflectX", 1);
__decorateClass$i([
  checkIt(owl.point2D)
], Host$i, "ReflectY", 1);
__decorateClass$i([
  checkIt(owl.num)
], Host$i, "IntersectAngle", 1);
__decorateClass$i([
  checkIt(owl.point2D),
  inspectIt(function distinct_points4(A2, O2, B2) {
    return owl.distinct([A2, O2]) && owl.distinct([B2, O2]);
  })
], Host$i, "Angle", 1);
__decorateClass$i([
  checkIt(owl.point2D),
  inspectIt(function distinct_points5(A2, O2, B2) {
    return owl.distinct([A2, O2]) && owl.distinct([B2, O2]);
  })
], Host$i, "AnglePolar", 1);
__decorateClass$i([
  checkIt(owl.point2D),
  inspectIt(function distinct_points6(A2, O2, B2) {
    return owl.distinct([A2, O2]) && owl.distinct([B2, O2]);
  })
], Host$i, "IsReflex", 1);
__decorateClass$i([
  checkIt(owl.num, owl.point2D, owl.num, owl.num)
], Host$i, "RegularPolygon", 1);
__decorateClass$i([
  checkIt(owl.nonNegative, owl.nonNegative)
], Host$i, "ArcLength", 1);
__decorateClass$i([
  checkIt(owl.nonNegative, owl.nonNegative)
], Host$i, "SectorArea", 1);
__decorateClass$i([
  checkIt(owl.point2D)
], Host$i, "IsConvexPolygon", 1);
__decorateClass$i([
  checkIt(owl.point2D)
], Host$i, "ArrangePoints", 1);
__decorateClass$i([
  checkIt(owl.num)
], Host$i, "OnCircle", 1);
Host$i = __decorateClass$i([
  exposeAll(),
  captureAll()
], Host$i);
var __defProp$h = Object.defineProperty;
var __getOwnPropDesc$h = Object.getOwnPropertyDescriptor;
var __decorateClass$h = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$h(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$h(target, key, result2);
  return result2;
};
let Host$h = class {
  static StemAndLeaf({ data: data2, labels, stem = "(tens)", leaf = "(units)" }) {
    let T2 = "";
    T2 += "\\begin{array}{r|l}";
    T2 += `\\text{Stem} & \\text{Leaf} \\\\ `;
    T2 += `\\text{${stem}} & \\text{${leaf}} \\\\ \\hline `;
    function ten(num2) {
      return Math.floor(num2 / 10 + Number.EPSILON);
    }
    function unit(num2) {
      return num2 - ten(num2) * 10;
    }
    function parse(label) {
      if (typeof label === "number")
        return unit(label).toString();
      return label;
    }
    labels != null ? labels : labels = [...data2];
    let parsedLabels = labels.map(parse);
    let initTen = ten(Math.min(...data2));
    let endTen = ten(Math.max(...data2));
    for (let t2 = initTen; t2 <= endTen; t2++) {
      T2 += t2 + " & { \\begin{array}{} ";
      let units = [];
      for (let i2 = 0; i2 < data2.length; i2++) {
        if (ten(data2[i2]) === t2)
          units.push(parsedLabels[i2]);
      }
      T2 += units.join(" & ");
      T2 += " \\end{array} } \\\\ ";
    }
    T2 += " \\end{array}";
    return T2;
  }
  static Table({ content, columns, rows, stretch }) {
    var _a, _b;
    let nCol = Math.max(...content.map(($) => $.length));
    columns != null ? columns : columns = Array(nCol + 1).fill("|").join("c");
    let nRow = content.length;
    rows != null ? rows : rows = Array(nRow + 1).fill("|").join("r");
    let rowsArr = rows.split("r").map(($) => $.replace(/\|/g, " \\hline ").replace(/\:/g, " \\hdashline "));
    let T2 = "";
    if (stretch)
      T2 += "\\def \\arraystretch{1.5} ";
    T2 += `\\begin{array}{${columns}}`;
    function parseCell(cell) {
      if (typeof cell === "number")
        return String(cell);
      return cell.startsWith("$") ? cell.substring(1) : `\\text{${cell}}`;
    }
    let i2 = 0;
    for (let row of content) {
      T2 += (_a = rowsArr[i2]) != null ? _a : "";
      T2 += row.map(parseCell).join(" & ") + " \\\\ ";
      i2++;
    }
    T2 += (_b = rowsArr[i2]) != null ? _b : "";
    T2 += ` \\end{array}`;
    return T2;
  }
  static FreqTable({ data: data2, dataLabel, freqLabel }) {
    let values = ListIntegers(Math.min(...data2), Math.max(...data2));
    let freqs = Freqs(data2, values);
    return Table({
      content: [
        [dataLabel, ...values],
        [freqLabel, ...freqs]
      ]
    });
  }
  static PairTable({
    rowTitle,
    colTitle,
    rows,
    cols,
    cell
  }) {
    function parseCell(cell2) {
      if (typeof cell2 === "number")
        return String(cell2);
      return cell2.startsWith("$") ? cell2.substring(1) : `\\text{${cell2}}`;
    }
    colTitle = parseCell(colTitle);
    rowTitle = parseCell(rowTitle);
    function cellMap(r2, c2) {
      let val = cell(r2, c2);
      if (typeof val === "number")
        return String(val);
      if (typeof val === "string")
        return val;
      if (typeof val === "boolean")
        return val ? "\u2714" : "\u2718";
      return String(val);
    }
    let T2 = "";
    T2 += "\\begin{matrix}";
    T2 += ` & ${colTitle} \\\\`;
    T2 += ` ${rowTitle} & {`;
    T2 += `\\begin{array}{c|ccc}`;
    T2 += ` & ` + cols.join(" & ") + " \\\\ \\hline ";
    for (let r2 of rows) {
      T2 += " " + String(r2) + " & ";
      T2 += cols.map((c2) => cellMap(r2, c2)).join(" & ");
      T2 += " \\\\";
    }
    T2 += " \\end{array}";
    T2 += ` } `;
    T2 += `\\end{matrix}`;
    return T2;
  }
  static CheckVertices({ constraints: constraints2, field: field2, label }) {
    let T2 = "";
    let vs = toReins(constraints2).vertices();
    for (let v2 of vs) {
      T2 += "\\text{At } " + Coord(v2) + ":~~~";
      T2 += label + " = " + optimizer({ field: field2 }).fieldAt(v2) + " \\\\ ";
    }
    return T2;
  }
};
Host$h = __decorateClass$h([
  exposeAll(),
  captureAll()
], Host$h);
var __defProp$g = Object.defineProperty;
var __getOwnPropDesc$g = Object.getOwnPropertyDescriptor;
var __decorateClass$g = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$g(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$g(target, key, result2);
  return result2;
};
let Host$g = class {
  static FieldAt(point, field2) {
    return optimizer({ field: field2 }).fieldAt(point);
  }
  static isConstrained(cons, point) {
    return toReins(cons).contains(point);
  }
  static isLooseConstrained(cons, point) {
    return toReins(cons).looseContains(point);
  }
  static FeasiblePolygon(...cons) {
    let vs = toReins(cons).polygon();
    Should(vs.length > 2, "No feasible region.");
    return vs;
  }
  static FeasibleVertices(...cons) {
    let vs = toReins(cons).vertices();
    Should(vs.length > 0, "no feasible vertex");
    return vs;
  }
  static FeasibleIsBounded(...cons) {
    return toReins(cons).isBounded();
  }
  static FeasibleIntegral(...cons) {
    return toReins(cons).integrals();
  }
  static MaximizePoint(points, field2) {
    Should(points.length > 0, "No feasible point");
    let pts = optimizer({
      field: field2,
      feasiblePoints: points
    }).maxPoints();
    Should(pts.length > 0, "No max point");
    Should(pts.length < 2, "Multiple max points");
    return pts[0];
  }
  static MinimizePoint(points, field2) {
    Should(points.length > 0, "No feasible point");
    let pts = optimizer({
      field: field2,
      feasiblePoints: points
    }).minPoints();
    Should(pts.length > 0, "No min point");
    Should(pts.length < 2, "Multiple min points");
    return pts[0];
  }
  static OptimizePoint(points, field2, max2) {
    return max2 ? MaximizePoint(points, field2) : MinimizePoint(points, field2);
  }
  static MaximizeField(points, field2) {
    let op2 = optimizer({
      field: field2,
      feasiblePoints: points
    });
    let val = op2.max();
    Should(val !== null, "No optimal value for this field!");
    return val;
  }
  static MinimizeField(points, field2) {
    let op2 = optimizer({
      field: field2,
      feasiblePoints: points
    });
    let val = op2.min();
    Should(val !== null, "No optimal value for this field!");
    return val;
  }
  static OptimizeField(points, field2, max2) {
    return max2 ? MaximizeField(points, field2) : MinimizeField(points, field2);
  }
  static ConstraintsFromPoints(...points) {
    Should(IsConvexPolygon(...points), "Not a convex region");
    let mean = toShape2D(points).mean().toArray();
    let pts = ArrangePoints(...points);
    pts = [...pts, pts[0]];
    let constraints2 = [];
    for (let i2 = 0; i2 < points.length; i2++) {
      let A2 = pts[i2];
      let B2 = pts[i2 + 1];
      let [a2, b2, c2] = LinearFromTwoPoints(A2, B2);
      let sign2 = FieldAt(mean, [a2, b2, c2]) > 0 ? "\\ge" : "\\le";
      constraints2.push([a2, b2, sign2, -c2]);
    }
    return constraints2;
  }
};
__decorateClass$g([
  checkIt(owl.point2D, owl.field)
], Host$g, "FieldAt", 1);
__decorateClass$g([
  checkIt(owl.constraints, owl.point2D)
], Host$g, "isConstrained", 1);
__decorateClass$g([
  checkIt(owl.constraints, owl.point2D)
], Host$g, "isLooseConstrained", 1);
__decorateClass$g([
  checkIt(owl.constraint)
], Host$g, "FeasiblePolygon", 1);
__decorateClass$g([
  checkIt(owl.constraint)
], Host$g, "FeasibleVertices", 1);
__decorateClass$g([
  checkIt(owl.constraint)
], Host$g, "FeasibleIsBounded", 1);
__decorateClass$g([
  checkIt(owl.constraint)
], Host$g, "FeasibleIntegral", 1);
__decorateClass$g([
  checkIt(owl.point2Ds, owl.field)
], Host$g, "MaximizePoint", 1);
__decorateClass$g([
  checkIt(owl.point2Ds, owl.field)
], Host$g, "MinimizePoint", 1);
__decorateClass$g([
  checkIt(owl.point2Ds, owl.field, owl.bool)
], Host$g, "OptimizePoint", 1);
__decorateClass$g([
  checkIt(owl.point2Ds, owl.field)
], Host$g, "MaximizeField", 1);
__decorateClass$g([
  checkIt(owl.point2Ds, owl.field)
], Host$g, "MinimizeField", 1);
__decorateClass$g([
  checkIt(owl.point2Ds, owl.field, owl.bool)
], Host$g, "OptimizeField", 1);
__decorateClass$g([
  checkIt(owl.point2D)
], Host$g, "ConstraintsFromPoints", 1);
Host$g = __decorateClass$g([
  exposeAll(),
  captureAll()
], Host$g);
var __defProp$f = Object.defineProperty;
var __getOwnPropDesc$f = Object.getOwnPropertyDescriptor;
var __decorateClass$f = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$f(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$f(target, key, result2);
  return result2;
};
let Host$f = class {
  static Divide(dividend, divisor) {
    return dividend / divisor;
  }
  static Abs(num2) {
    return Math.abs(num2);
  }
  static Sign(num2) {
    if (num2 > 0)
      return 1;
    if (num2 < 0)
      return -1;
    return 0;
  }
  static SigFig(num2) {
    return cal.sigfig(cal.blur(num2));
  }
  static Round(num2, sigfig2 = 3) {
    num2 = num2 * (1 + Number.EPSILON);
    return cal.round(num2, sigfig2).off();
  }
  static RoundUp(num2, sigfig2 = 3) {
    num2 = num2 * (1 - Number.EPSILON);
    return cal.round(num2, sigfig2).up();
  }
  static RoundDown(num2, sigfig2 = 3) {
    num2 = num2 * (1 + Number.EPSILON);
    return cal.round(num2, sigfig2).down();
  }
  static Fix(num2, dp2 = 0) {
    num2 = num2 * (1 + Number.EPSILON);
    return cal.fix(num2, dp2).off();
  }
  static FixUp(num2, dp2 = 0) {
    num2 = num2 * (1 - Number.EPSILON);
    return cal.fix(num2, dp2).up();
  }
  static FixDown(num2, dp2 = 0) {
    num2 = num2 * (1 + Number.EPSILON);
    return cal.fix(num2, dp2).down();
  }
  static Ceil(num2) {
    return Math.ceil(num2);
  }
  static Floor(num2) {
    return Math.floor(num2);
  }
  static Ratio(...nums) {
    return toNumbers(nums).ratio();
  }
  static HCF(...nums) {
    return toNumbers(nums).hcf();
  }
  static LCM(...nums) {
    return toNumbers(nums).lcm();
  }
  static ToFrac(num2) {
    return cal.toFraction(num2);
  }
};
__decorateClass$f([
  checkIt(owl.num, owl.nonZero)
], Host$f, "Divide", 1);
__decorateClass$f([
  checkIt(owl.num)
], Host$f, "Abs", 1);
__decorateClass$f([
  checkIt(owl.num)
], Host$f, "Sign", 1);
__decorateClass$f([
  checkIt(owl.num)
], Host$f, "SigFig", 1);
__decorateClass$f([
  checkIt(owl.num, owl.positiveInt)
], Host$f, "Round", 1);
__decorateClass$f([
  checkIt(owl.num, owl.positiveInt)
], Host$f, "RoundUp", 1);
__decorateClass$f([
  checkIt(owl.num, owl.positiveInt)
], Host$f, "RoundDown", 1);
__decorateClass$f([
  checkIt(owl.num, owl.int)
], Host$f, "Fix", 1);
__decorateClass$f([
  checkIt(owl.num, owl.int)
], Host$f, "FixUp", 1);
__decorateClass$f([
  checkIt(owl.num, owl.int)
], Host$f, "FixDown", 1);
__decorateClass$f([
  checkIt(owl.num)
], Host$f, "Ceil", 1);
__decorateClass$f([
  checkIt(owl.num)
], Host$f, "Floor", 1);
__decorateClass$f([
  checkIt(owl.rational)
], Host$f, "Ratio", 1);
__decorateClass$f([
  checkIt(owl.nonZeroInt)
], Host$f, "HCF", 1);
__decorateClass$f([
  checkIt(owl.nonZeroInt)
], Host$f, "LCM", 1);
__decorateClass$f([
  checkIt(owl.rational)
], Host$f, "ToFrac", 1);
Host$f = __decorateClass$f([
  exposeAll(),
  captureAll()
], Host$f);
var PhyConst$1 = {
  R: 8.31,
  N_A: 602e21,
  g: 9.81,
  G: 667e-13,
  c: 3e8,
  e: 16e-20,
  m_e: 911e-33,
  epsilon_0: 885e-14,
  mu_0: 4 * Math.PI * 1e-7,
  m_u: 1661e-30,
  au: 15e10,
  light_year: 946e13,
  parsec: 309e14,
  sigma: 567e-10,
  h: 663e-36
};
globalThis.PhyConst = PhyConst$1;
function makeFn(args, body) {
  const paras = args.join(",");
  return new Function("return (" + paras + ") => (" + body.toString() + ").apply(null,[" + args + "])")();
}
function makeLatex(args, template, units, brackets) {
  let T2 = template;
  for (let i2 = 0; i2 < args.length; i2++) {
    const [l2, r2] = brackets[i2] === "|" ? ["(", ")"] : ["", ""];
    const u2 = units[i2];
    T2 = T2.replace("@", u2 + l2 + args[i2] + r2);
  }
  return T2;
}
class PhyEqCls {
  constructor() {
    this.Motion = {
      vuat(v2 = "v", u2 = "u", a2 = "a", t2 = "t", $ = "****") {
        let args = [v2, u2, a2, t2];
        return [
          makeFn(args, (v22, u22, a22, t22) => v22 - u22 - a22 * t22),
          makeLatex(args, "@=@+@@", $, "::||")
        ];
      },
      vu2as(v2 = "v", u2 = "u", a2 = "a", s2 = "s", $ = "****") {
        let args = [v2, u2, a2, s2];
        return [
          makeFn(args, (v22, u22, a22, s22) => v22 ** 2 - u22 ** 2 - 2 * a22 * s22),
          makeLatex(args, "@^2=@^2+2@@", $, "||||")
        ];
      },
      sutat2(s2 = "s", u2 = "u", t2 = "t", a2 = "a", $ = "****") {
        let args = [s2, u2, t2, a2];
        let [_s, _u, _t, _a] = $;
        return [
          makeFn(args, (s22, u22, t22, a22) => s22 - u22 * t22 - 0.5 * a22 * t22 * t22),
          makeLatex([s2, u2, t2, a2, t2], "@=@@+\\dfrac{1}{2}@@^2", [_s, _u, _t, _a, _t].join(""), ":||||")
        ];
      },
      suvt(s2 = "s", u2 = "u", v2 = "v", t2 = "t", $ = "****") {
        let args = [s2, u2, v2, t2];
        return [
          makeFn(args, (s22, u22, v22, t22) => s22 - 0.5 * (u22 + v22) * t22),
          makeLatex(args, "@=\\dfrac{1}{2}(@+@)@", $, ":::|")
        ];
      },
      sat2(s2 = "s", a2 = "a", t2 = "t", $ = "***") {
        let args = [s2, a2, t2];
        return [
          makeFn(args, (s22, a22, t22) => s22 - 0.5 * a22 * t22 * t22),
          makeLatex(args, "@=\\dfrac{1}{2}@@^2", $, ":||")
        ];
      },
      vat(v2 = "v", a2 = "a", t2 = "t", $ = "***") {
        let args = [v2, a2, t2];
        return [
          makeFn(args, (v22, a22, t22) => v22 - a22 * t22),
          makeLatex(args, "@=@@", $, ":||")
        ];
      },
      v2as(v2 = "v", a2 = "a", s2 = "s", $ = "***") {
        let args = [v2, a2, s2];
        return [
          makeFn(args, (v22, a22, s22) => v22 ** 2 - 2 * a22 * s22),
          makeLatex(args, "@^2=2@@", $, "|||")
        ];
      }
    };
    this.CircularMotion = {
      svt(s2 = "s", v2 = "v", t2 = "t", $ = "***") {
        let args = [s2, v2, t2];
        return [
          makeFn(args, (s22, v22, t22) => s22 - v22 * t22),
          makeLatex(args, "@=@@", $, ":||")
        ];
      },
      \u03B8\u03C9t(\u03B8 = "\u03B8", \u03C9 = "\u03C9", t2 = "t", $ = "$$$") {
        let args = [\u03B8, \u03C9, t2];
        return [
          makeFn(args, (\u03B82, \u03C92, t22) => \u03B82 - \u03C92 * t22),
          makeLatex(args, "@=@@", $, ":||")
        ];
      },
      \u03C9T(\u03C9 = "\u03C9", T2 = "T", $ = "$$") {
        let args = [\u03C9, T2];
        return [
          makeFn(args, (\u03C92, T22) => \u03C92 - 2 * Math.PI / T22),
          makeLatex(args, "@=\\dfrac{2\u03C0}{@}", $, "::")
        ];
      },
      sr\u03B8(s2 = "s", r2 = "r", \u03B8 = "\u03B8", $ = "**$") {
        let args = [s2, r2, \u03B8];
        return [
          makeFn(args, (s22, r22, \u03B82) => s22 - r22 * \u03B82),
          makeLatex(args, "@=@@", $, ":||")
        ];
      },
      vr\u03C9(v2 = "v", r2 = "r", \u03C9 = "\u03C9", $ = "***") {
        let args = [v2, r2, \u03C9];
        return [
          makeFn(args, (v22, r22, \u03C92) => v22 - r22 * \u03C92),
          makeLatex(args, "@=@@", $, ":||")
        ];
      },
      av\u03C9(a2 = "a", v2 = "v", \u03C9 = "\u03C9", $ = "***") {
        let args = [a2, v2, \u03C9];
        return [
          makeFn(args, (a22, v22, \u03C92) => a22 - v22 * \u03C92),
          makeLatex(args, "@=@@", $, ":||")
        ];
      },
      avr(a2 = "a", v2 = "v", r2 = "r", $ = "***") {
        let args = [a2, v2, r2];
        return [
          makeFn(args, (a22, v22, r22) => a22 - v22 * v22 / r22),
          makeLatex(args, "@=\\dfrac{@^2}{@}", $, ":|:")
        ];
      },
      ar\u03C9(a2 = "a", r2 = "r", \u03C9 = "\u03C9", $ = "***") {
        let args = [a2, r2, \u03C9];
        return [
          makeFn(args, (a22, r22, \u03C92) => a22 - r22 * \u03C92 * \u03C92),
          makeLatex(args, "@=@@^2", $, ":||")
        ];
      },
      Fmv\u03C9(F2 = "F", m2 = "m", v2 = "v", \u03C9 = "\u03C9", $ = "****") {
        let args = [F2, m2, v2, \u03C9];
        return [
          makeFn(args, (F22, m22, v22, \u03C92) => F22 - m22 * v22 * \u03C92),
          makeLatex(args, "@=@@@", $, ":|||")
        ];
      },
      Fmvr(F2 = "F", m2 = "m", v2 = "v", r2 = "r", $ = "****") {
        let args = [F2, m2, v2, r2];
        return [
          makeFn(args, (F22, m22, v22, r22) => F22 - m22 * v22 * v22 / r22),
          makeLatex(args, "@=\\dfrac{@@^2}{@}", $, ":||:")
        ];
      },
      Fmr\u03C9(F2 = "F", m2 = "m", r2 = "r", \u03C9 = "\u03C9", $ = "****") {
        let args = [F2, m2, r2, \u03C9];
        return [
          makeFn(args, (F22, m22, r22, \u03C92) => F22 - m22 * r22 * \u03C92 * \u03C92),
          makeLatex(args, "@=@@@^2", $, ":|||")
        ];
      }
    };
    this.Gravitation = {
      FGMmr2(F2 = "F", M2 = "M", m2 = "m", r2 = "r", $ = "****") {
        let args = [F2, M2, m2, r2];
        return [
          makeFn(args, (F22, M22, m22, r22) => F22 - PhyConst.G * M22 * m22 / r22 ** 2),
          makeLatex(args, "@=\\dfrac{G@@}{@^2}", $, ":|||")
        ];
      },
      FGMmRh2(F2 = "F", M2 = "M", m2 = "m", R2 = "R", h2 = "h", $ = "*****") {
        let args = [F2, M2, m2, R2, h2];
        return [
          makeFn(args, (F22, M22, m22, R22, h22) => F22 - PhyConst.G * M22 * m22 / (R22 + h22) ** 2),
          makeLatex(args, "@=\\dfrac{G@@}{(@+@)^2}", $, ":||::")
        ];
      },
      gGMr2(g2 = "g", M2 = "M", r2 = "r", $ = "***") {
        let args = [g2, M2, r2];
        return [
          makeFn(args, (g22, M22, r22) => g22 - PhyConst.G * M22 / r22 ** 2),
          makeLatex(args, "@=\\dfrac{G@}{@^2}", $, ":||")
        ];
      },
      gGMRh2(g2 = "g", M2 = "M", R2 = "R", h2 = "h", $ = "****") {
        let args = [g2, M2, R2, h2];
        return [
          makeFn(args, (g22, M22, R22, h22) => g22 - PhyConst.G * M22 / (R22 + h22) ** 2),
          makeLatex(args, "@=\\dfrac{G@}{(@+@)^2}", $, ":|::")
        ];
      },
      Fmg(F2 = "F", m2 = "m", g2 = "g", $ = "***") {
        let args = [F2, m2, g2];
        return [
          makeFn(args, (F22, m22, g22) => F22 - m22 * g22),
          makeLatex(args, "@=@@", $, ":||")
        ];
      },
      GMmr2v2r(M2 = "M", r2 = "r", v2 = "v", $ = "***") {
        let args = [M2, r2, v2];
        let [_M, _r, _v] = $;
        $ = [_M, _r, _v, _r].join("");
        return [
          makeFn(args, (M22, r22, v22) => PhyConst.G * M22 / r22 / r22 - v22 * v22 / r22),
          makeLatex([M2, r2, v2, r2], "\\dfrac{G@m}{@^2}=\\dfrac{m@^2}{@}", $, "|||:")
        ];
      },
      GMmr2r\u03C92(M2 = "M", r2 = "r", \u03C9 = "\u03C9", $ = "***") {
        let args = [M2, r2, \u03C9];
        let [_M, _r, _\u03C9] = $;
        $ = [_M, _r, _r, _\u03C9].join("");
        return [
          makeFn(args, (M22, r22, \u03C92) => PhyConst.G * M22 / r22 / r22 - r22 * \u03C92 * \u03C92),
          makeLatex([M2, r2, r2, \u03C9], "\\dfrac{G@m}{@^2}=m@@^2", $, "||||")
        ];
      }
    };
  }
}
globalThis.PhyEq = new PhyEqCls();
var __defProp$e = Object.defineProperty;
var __getOwnPropDesc$e = Object.getOwnPropertyDescriptor;
var __decorateClass$e = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$e(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$e(target, key, result2);
  return result2;
};
let Host$e = class {
  static RndN(min2, max2) {
    return poker.integer(min2, max2);
  }
  static RndNs(min2, max2, n2 = 10) {
    n2 = Math.min(Math.floor(max2 - min2 + 1), n2);
    return dice(() => RndN(min2, max2)).unique().rolls(n2);
  }
  static RndR(min2, max2) {
    return poker.real(min2, max2);
  }
  static RndRs(min2, max2, n2 = 10) {
    return dice(() => RndR(min2, max2)).unique().rolls(n2);
  }
  static RndQ(largest = 9, range2) {
    let L2 = Math.abs(largest);
    let sign2 = largest > 0 ? 1 : RndU();
    let f2 = () => RndN(1, L2) / RndN(2, L2) * sign2;
    let d2 = dice(f2).shield((_) => owl.dec(_));
    if (range2) {
      d2.shield((_) => _ >= range2[0]).shield((_) => _ <= range2[1]);
    }
    return d2.roll();
  }
  static RndQs(largest = 9, range2, n2 = 10) {
    n2 = Math.min(Math.abs(largest) + 1, n2);
    return dice(() => RndQ(largest, range2)).unique().rolls(n2);
  }
  static RndU() {
    return list(1, -1).draw();
  }
  static RndT() {
    return poker.bool();
  }
  static RndZ(min2, max2) {
    return RndN(min2, max2) * RndU();
  }
  static RndZs(min2, max2, n2 = 10) {
    n2 = Math.min(Math.floor(max2 - min2 + 1), n2);
    return dice(() => RndN(min2, max2)).unique().rolls(n2).map((x2) => x2 * RndU());
  }
  static RndP(max2) {
    return poker.prime(2, max2);
  }
  static RndOdd(min2, max2) {
    min2 = Math.ceil((min2 + 1) / 2);
    max2 = Math.floor((max2 + 1) / 2);
    return 2 * RndN(min2, max2) - 1;
  }
  static RndEven(min2, max2) {
    min2 = Math.ceil(min2 / 2);
    max2 = Math.floor(max2 / 2);
    return 2 * RndN(min2, max2);
  }
  static RndPoly(...coeff) {
    let arr = coeff.map((x2) => RndZ(1, x2));
    arr[0] = Math.abs(arr[0]);
    return arr;
  }
  static RndPyth(max2 = 100) {
    let arr = [];
    for (let m2 = 1; m2 < 10; m2++) {
      for (let n2 = 1; n2 < m2; n2++) {
        for (let k2 = 1; k2 < 10; k2++) {
          let a2 = m2 * m2 - n2 * n2;
          let b2 = 2 * m2 * n2;
          let c2 = m2 * m2 + n2 * n2;
          if (c2 <= max2)
            arr.push([a2, b2, c2]);
        }
      }
    }
    return toList(arr).draw();
  }
  static RndPoint(xRange, yRange = xRange) {
    if (typeof xRange === "number")
      xRange = [-xRange, xRange];
    if (typeof yRange === "number")
      yRange = [-yRange, yRange];
    let [x1, x2] = xRange;
    let [y1, y2] = yRange;
    let f2 = () => [RndN(x1, x2), RndN(y1, y2)];
    return dice(f2).shield(([x3, y3]) => x3 !== 0).shield(([x3, y3]) => y3 !== 0).shield(([x3, y3]) => x3 !== y3).roll();
  }
  static RndPoints(xRange, yRange = xRange, n2 = 10) {
    return dice(() => RndPoint(xRange, yRange)).unique(([x2, y2]) => x2).unique(([x2, y2]) => y2).coherent(($) => toList($).combinations(3).every(([A2, B2, C2]) => Slope(A2, B2) !== Slope(B2, C2))).rolls(n2);
  }
  static RndAngles(n2, separation) {
    let angles = dice(() => RndN(0, 360)).coherent((angles2) => toNumbers(angles2).gapsMod(360).min() > separation).unique().rolls(n2);
    return [...toList(angles).ascending()];
  }
  static RndOnCircle(n2, separation) {
    let t2 = RndN(0, 360);
    return RndAngles(n2, separation).map(($) => OnCircle($ + t2));
  }
  static RndConvexPolygon(n2, center, radius, separation) {
    let [h2, k2] = center;
    let r2 = radius;
    let angles = RndAngles(n2, separation);
    let vertices = angles.map((a2) => [h2 + r2 * cos(a2), k2 + r2 * sin(a2)]);
    vertices = vertices.map(([x2, y2]) => [Fix(x2), Fix(y2)]);
    return vertices;
  }
  static RndData(min2, max2, n2) {
    let data2 = dice(() => RndN(min2, max2)).coherent((d2) => toData(d2).isSingleMode()).rolls(n2);
    return toList(data2).ascending();
  }
  static RndTriangle(xRange, yRange, {
    minAngle = 0,
    maxAngle = 180,
    minLength = 0,
    obtuse = false
  } = {}) {
    let [x1, x2] = xRange;
    let [y1, y2] = yRange;
    let arr = [];
    for (let i2 = x1; i2 <= x2; i2++) {
      for (let j2 = y1; j2 <= y2; j2++) {
        arr.push([i2, j2]);
      }
    }
    arr = RndShuffle(...arr);
    for (let i2 = 0; i2 < arr.length; i2++) {
      for (let j2 = i2 + 1; j2 < arr.length; j2++) {
        for (let k2 = j2 + 1; k2 < arr.length; k2++) {
          let A2 = arr[i2];
          let B2 = arr[j2];
          let C2 = arr[k2];
          if (A2[0] === B2[0])
            continue;
          if (B2[0] === C2[0])
            continue;
          if (C2[0] === A2[0])
            continue;
          if (A2[1] === B2[1])
            continue;
          if (B2[1] === C2[1])
            continue;
          if (C2[1] === A2[1])
            continue;
          if (Slope(A2, B2) === Slope(B2, C2))
            continue;
          let A_ = Angle(C2, A2, B2);
          let B_ = Angle(A2, B2, C2);
          let C_ = Angle(B2, C2, A2);
          let smallestAngle = Min(A_, B_, C_);
          let largestAngle = Max(A_, B_, C_);
          if (smallestAngle < minAngle)
            continue;
          if (largestAngle > maxAngle)
            continue;
          if (Distance(A2, B2) < minLength)
            continue;
          if (Distance(B2, C2) < minLength)
            continue;
          if (Distance(C2, A2) < minLength)
            continue;
          if (obtuse && largestAngle <= 90)
            continue;
          return [A2, B2, C2];
        }
      }
    }
    throw "RndTriangle fail to find a suitable triangle.";
  }
  static RndTrigValue(func, angle2) {
    let trig2 = (funcName, q2) => {
      if (funcName === "sin")
        return sin(q2);
      if (funcName === "cos")
        return cos(q2);
      if (funcName === "tan")
        return tan(q2);
      throw "never";
    };
    let atrig = (funcName, val) => {
      if (funcName === "sin")
        return arcsin(val);
      if (funcName === "cos")
        return arccos(val);
      if (funcName === "tan")
        return arctan(val);
      throw "never";
    };
    let v2 = trig2(func, angle2);
    angle2 = atrig(func, Abs(trig2(func, angle2)));
    angle2 = cal.blur(angle2);
    let arr = [];
    for (let f2 of ["sin", "cos", "tan"]) {
      for (let a2 of [0, 90, 180, 270, 360]) {
        for (let s2 of [angle2, -angle2]) {
          if (a2 === 360 && s2 > 0)
            continue;
          if (a2 === 0 && s2 < 0)
            continue;
          if (cal.eq(trig2(f2, a2 + s2), v2))
            arr.push([f2, a2 + s2]);
        }
      }
    }
    return RndPick(...arr);
  }
  static RndTrigEqv(result2, label) {
    let trig2 = (funcName, angle2) => {
      if (funcName === "sin")
        return sin(angle2);
      if (funcName === "cos")
        return cos(angle2);
      if (funcName === "tan")
        return tan(angle2);
      throw "never";
    };
    let v2 = 0;
    if (result2 === "sin")
      v2 = sin(1);
    if (result2 === "-sin")
      v2 = -sin(1);
    if (result2 === "cos")
      v2 = cos(1);
    if (result2 === "-cos")
      v2 = -cos(1);
    if (result2 === "tan")
      v2 = tan(1);
    if (result2 === "-tan")
      v2 = -tan(1);
    if (result2 === "1/tan")
      v2 = 1 / tan(1);
    if (result2 === "-1/tan")
      v2 = -1 / tan(1);
    let arr = [];
    for (let f2 of ["sin", "cos", "tan"]) {
      for (let a2 of [90, 180, 270, 360]) {
        for (let s2 of [1, -1]) {
          if (a2 === 360 && s2 > 0)
            continue;
          if (cal.eq(trig2(f2, a2 + s2), v2))
            arr.push([f2, a2, s2, label]);
        }
      }
    }
    return RndPick(...arr);
  }
  static RndPointPolar() {
    let angle2 = RndPick(30, 45, 60, 120, 135, 150, 210, 225, 240, 300, 315, 330);
    let a2 = RndEven(2, 6);
    let b2 = RndPick(1, 2, 3);
    let r2 = a2 * Math.sqrt(b2);
    return PolToRect([r2, angle2]);
  }
  static RndRatio(min2, max2, n2 = 10) {
    let nums = RndNs(min2, max2, n2);
    return toNumbers(nums).ratio();
  }
};
__decorateClass$e([
  checkIt(owl.num)
], Host$e, "RndN", 1);
__decorateClass$e([
  checkIt(owl.num, owl.num, owl.positiveInt)
], Host$e, "RndNs", 1);
__decorateClass$e([
  checkIt(owl.num)
], Host$e, "RndR", 1);
__decorateClass$e([
  checkIt(owl.num, owl.num, owl.positiveInt)
], Host$e, "RndRs", 1);
__decorateClass$e([
  checkIt(owl.nonZeroInt, owl.interval)
], Host$e, "RndQ", 1);
__decorateClass$e([
  checkIt(owl.nonZeroInt, owl.interval, owl.positiveInt)
], Host$e, "RndQs", 1);
__decorateClass$e([
  checkIt(owl.num)
], Host$e, "RndZ", 1);
__decorateClass$e([
  checkIt(owl.nonNegative, owl.nonNegative, owl.positiveInt)
], Host$e, "RndZs", 1);
__decorateClass$e([
  checkIt(owl.positive)
], Host$e, "RndP", 1);
__decorateClass$e([
  checkIt(owl.num)
], Host$e, "RndOdd", 1);
__decorateClass$e([
  checkIt(owl.num)
], Host$e, "RndEven", 1);
__decorateClass$e([
  checkIt(owl.positive)
], Host$e, "RndPoly", 1);
__decorateClass$e([
  checkIt(owl.positive)
], Host$e, "RndPyth", 1);
__decorateClass$e([
  checkIt(owl.or([owl.num, owl.interval]))
], Host$e, "RndPoint", 1);
__decorateClass$e([
  checkIt(owl.or([owl.num, owl.interval]), owl.or([owl.num, owl.interval]), owl.num)
], Host$e, "RndPoints", 1);
__decorateClass$e([
  checkIt(owl.positiveInt, owl.positive)
], Host$e, "RndAngles", 1);
__decorateClass$e([
  checkIt(owl.positiveInt, owl.positive)
], Host$e, "RndOnCircle", 1);
__decorateClass$e([
  checkIt(owl.positiveInt, owl.point2D, owl.positive, owl.positive)
], Host$e, "RndConvexPolygon", 1);
__decorateClass$e([
  checkIt(owl.num, owl.num, owl.positiveInt)
], Host$e, "RndData", 1);
__decorateClass$e([
  checkIt(owl.interval, owl.interval, owl.object)
], Host$e, "RndTriangle", 1);
__decorateClass$e([
  checkIt(owl.trig, owl.num)
], Host$e, "RndTrigValue", 1);
__decorateClass$e([
  checkIt(owl.str, owl.str)
], Host$e, "RndTrigEqv", 1);
__decorateClass$e([
  checkIt(owl.positive, owl.positive, owl.positiveInt)
], Host$e, "RndRatio", 1);
Host$e = __decorateClass$e([
  exposeAll(),
  captureAll()
], Host$e);
var __defProp$d = Object.defineProperty;
var __getOwnPropDesc$d = Object.getOwnPropertyDescriptor;
var __decorateClass$d = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$d(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$d(target, key, result2);
  return result2;
};
let Host$d = class {
  static RndShake(anchor) {
    if (typeof anchor === "string") {
      if (owl.dfrac(anchor)) {
        Should(false, "RndShakeDfrac is not supported anymore");
      }
      if (owl.ineq(anchor)) {
        return RndShakeIneq(anchor);
      }
      if (owl.trig(anchor)) {
        return RndShakeTrig(anchor);
      }
      if (Number(anchor)) {
        anchor = Number(anchor);
      }
    }
    if (owl.quantity(anchor)) {
      return RndShakeQuantity(anchor);
    }
    if (owl.point2D(anchor)) {
      return RndShakePoint(anchor);
    }
    if (owl.combo(anchor)) {
      return RndShakeCombo(anchor);
    }
    if (owl.trigValue(anchor)) {
      return RndShakeTrigValue(anchor);
    }
    if (owl.constraint(anchor)) {
      return RndShakeConstraint(anchor);
    }
    if (owl.constraints(anchor)) {
      return RndShakeConstraints(anchor);
    }
    if (typeof anchor === "number" && owl.num(anchor)) {
      anchor = cal.blur(anchor);
      if (owl.int(anchor)) {
        return RndShakeN(anchor);
      }
      if (owl.num(anchor)) {
        return RndShakeR(anchor);
      }
      if (isNaN(anchor)) {
        return [];
      }
    }
    if (anchor === void 0)
      return [];
    throw MathError("Fail to RndShake: " + anchor);
  }
  static RndShakeN(anchor) {
    anchor = cal.blur(anchor);
    let a2 = Abs(anchor);
    let s2 = Sign(anchor);
    let f2;
    if (anchor === 0) {
      f2 = () => RndN(1, 3);
    } else {
      let range2 = Max(3, a2 * 0.1);
      let max2 = Min(Floor(a2 + range2), cal.logCeil(a2) - 1);
      let min2 = Max(Ceil(a2 - range2), 1, cal.logFloor(a2));
      f2 = () => RndN(min2, max2) * s2;
    }
    return dice(f2).shield((x2) => x2 !== anchor).unique().rolls(3);
  }
  static RndShakeR(anchor) {
    let exp2 = cal.e(anchor);
    let m2 = cal.blur(cal.mantissa(anchor));
    if (IsInteger(m2))
      return RndShakeN(m2).map((x2) => Number(x2 + "e" + exp2));
    let dp2 = cal.dp(m2);
    return dice(() => Fix(m2 * (1 + RndR(0, 0.5) * RndU()), dp2)).shield((x2) => x2 * m2 > 0).shield((x2) => cal.e(x2) === cal.e(m2)).shield((x2) => x2 !== m2).unique().rolls(3).map((x2) => Number(x2 + "e" + exp2));
  }
  static RndShakeQ(anchor) {
    if (owl.int(anchor))
      return RndShakeN(anchor);
    let [p2, q2] = ToFrac(anchor);
    [p2, q2] = [p2, q2].map(cal.blur);
    Should(IsInteger(p2, q2), "input should be integral fraction");
    return dice(() => {
      const h2 = RndShakeN(p2)[0];
      const k2 = RndShakeN(q2)[0];
      let a2 = RndR(0, 1) < 1 / Math.abs(p2) ? p2 : h2;
      let b2 = RndR(0, 1) < 1 / Math.abs(q2) ? q2 : k2;
      if (a2 === p2 && b2 === q2)
        return [h2, k2];
      return [a2, b2];
    }).shield(([a2, b2]) => AreCoprime(a2, b2)).shield(([a2, b2]) => a2 !== 0).shield(([a2, b2]) => b2 !== 0).shield(([a2, b2]) => b2 !== 1).shield(([a2, b2]) => b2 !== 1).shield(([a2, b2]) => IsProbability(p2 / q2) ? IsProbability(a2 / b2) : true).unique(([p22, q22]) => p22 / q22).rolls(3).map(([p22, q22]) => p22 / q22);
  }
  static RndShakeIneq(anchor) {
    let i2 = ineq(anchor);
    let me = i2.print();
    let flip = i2.flip();
    return list(me, flip, flip).shuffled();
  }
  static RndShakePoint(anchor) {
    let [x2, y2] = anchor;
    let func = () => {
      const h2 = IsInteger(x2) ? RndShakeN(x2)[0] : RndShakeR(x2)[0];
      const k2 = IsInteger(y2) ? RndShakeN(y2)[0] : RndShakeR(y2)[0];
      return [h2, k2];
    };
    return dice(func).unique(([x22, y22]) => x22).unique(([x22, y22]) => y22).rolls(3);
  }
  static RndShakeCombo(anchor) {
    let [a2, b2, c2] = anchor;
    let func = () => {
      return [
        RndT() ? a2 : !a2,
        RndT() ? b2 : !b2,
        RndT() ? c2 : !c2
      ];
    };
    let diff = (bools) => {
      return bools.some(($) => $) && bools.some(($) => !$);
    };
    return dice(func).unique().coherent((all) => diff([a2, ...all.map(($) => $[0])])).coherent((all) => diff([b2, ...all.map(($) => $[1])])).coherent((all) => diff([c2, ...all.map(($) => $[2])])).rolls(3);
  }
  static RndShakeTrig(anchor) {
    return [...list("sin", "cos", "tan").draws(3)];
  }
  static RndShakeTrigValue(anchor) {
    return RndShakeTrig(anchor[0]).map((x2) => [x2, anchor[1]]);
  }
  static RndShakeRatio(anchor) {
    anchor = [...toNumbers(anchor).ratio()];
    let func = () => {
      return anchor.map((x2) => RndR(0, 1) < 1 / (Math.abs(x2) + 1) ? x2 : RndShakeN(x2)[0]);
    };
    return dice(func).shield((r2) => toNumbers(r2).hcf() === 1).shield((r2) => AreDifferent(anchor, r2)).unique().rolls(3);
  }
  static RndShakeBase(anchor) {
    let [num2, base2] = anchor.split("_");
    base2 = base2.replace("{", "").replace("}", "");
    let digits = "0123456789ABCDEF".substring(0, Number(base2)).split("");
    function shake(d2) {
      let x2 = digits.indexOf(d2) + RndU();
      if (x2 < 0)
        x2 = 0;
      if (x2 > digits.length - 1)
        x2 = digits.length - 1;
      return digits[x2];
    }
    function mutate(str2) {
      let s2 = [];
      let nonzero = str2.split("").filter((_) => _ !== "0").length;
      for (let d2 of str2.split("")) {
        if (d2 === "0") {
          let go = poker.bool(0.1);
          s2.push(go ? toList(digits).draw() : "0");
        } else {
          let go = poker.bool(1 / (nonzero + 2));
          s2.push(go ? shake(d2) : d2);
        }
      }
      let T2 = s2.join("");
      if (poker.bool(0.2))
        T2 += "0";
      return T2;
    }
    function dress2(str2) {
      str2 = str2.replace(/^0+/, "");
      return str2 + "_{" + base2 + "}";
    }
    let f2 = () => {
      let middle = Math.ceil(num2.length / 2);
      let s1 = num2.slice(0, middle);
      let s2 = num2.slice(middle);
      let t1 = mutate(s1);
      let t2 = mutate(s2);
      let B1 = dress2(s1 + t2);
      let B2 = dress2(t1 + s2);
      let B3 = dress2(t1 + t2);
      return [B1, B2, B3];
    };
    return dice(f2).shield((_) => toList([num2, ..._]).dupless()).roll();
  }
  static RndShakePointPolar(anchor) {
    let [r1, q1] = RectToPol(anchor);
    let [a2, b2] = cal.toSurd(r1);
    let r2 = b2 === 1 ? a2 * Math.sqrt(RndPick(2, 3)) : a2;
    let angles = list(30, 45, 60, 120, 135, 150, 210, 225, 240, 300, 315, 330);
    let q2 = angles.except([q1]).draw();
    return RndShuffle([r1, q2], [r2, q1], [r2, q2]).map(($) => PolToRect($));
  }
  static RndShakeConstraint(anchor) {
    let flip = rein(anchor).flip().constraint;
    return list(anchor, flip, flip).shuffled();
  }
  static RndShakeConstraints(anchor) {
    let func = () => [...toReins(anchor).shake().map(($) => $.constraint)];
    return dice(func).forbid(anchor).shield(($) => toReins($).isConsistent()).unique().rolls(3);
  }
  static RndShakeQuantity(anchor) {
    let { val, unit } = anchor;
    let vals = RndShake(val);
    return vals.map(($) => ({ val: $, unit }));
  }
};
__decorateClass$d([
  checkIt(owl.int)
], Host$d, "RndShakeN", 1);
__decorateClass$d([
  checkIt(owl.num)
], Host$d, "RndShakeR", 1);
__decorateClass$d([
  checkIt(owl.rational)
], Host$d, "RndShakeQ", 1);
__decorateClass$d([
  checkIt(owl.ineq)
], Host$d, "RndShakeIneq", 1);
__decorateClass$d([
  checkIt(owl.point2D)
], Host$d, "RndShakePoint", 1);
__decorateClass$d([
  checkIt(owl.combo)
], Host$d, "RndShakeCombo", 1);
__decorateClass$d([
  checkIt(owl.trig)
], Host$d, "RndShakeTrig", 1);
__decorateClass$d([
  checkIt(owl.trigValue)
], Host$d, "RndShakeTrigValue", 1);
__decorateClass$d([
  checkIt(owl.ntuple)
], Host$d, "RndShakeRatio", 1);
__decorateClass$d([
  checkIt(owl.base)
], Host$d, "RndShakeBase", 1);
__decorateClass$d([
  checkIt(owl.point2D)
], Host$d, "RndShakePointPolar", 1);
__decorateClass$d([
  checkIt(owl.constraint)
], Host$d, "RndShakeConstraint", 1);
__decorateClass$d([
  checkIt(owl.constraints)
], Host$d, "RndShakeConstraints", 1);
__decorateClass$d([
  checkIt(owl.quantity)
], Host$d, "RndShakeQuantity", 1);
Host$d = __decorateClass$d([
  exposeAll(),
  captureAll()
], Host$d);
var __defProp$c = Object.defineProperty;
var __getOwnPropDesc$c = Object.getOwnPropertyDescriptor;
var __decorateClass$c = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$c(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$c(target, key, result2);
  return result2;
};
let Host$c = class {
  static RndPick(...items) {
    return toList(items).draw();
  }
  static RndShuffle(...items) {
    return [...toList(items).shuffled()];
  }
  static RndPickN(items, n2) {
    return [...toList(items).sample(n2)];
  }
  static RndPickUnique(items, n2) {
    return [...toList(items).uniqueDeep().sample(n2)];
  }
  static RndHe() {
    return poker.he();
  }
  static RndShe() {
    return poker.she();
  }
  static RndLetters() {
    return RndPick(["a", "b", "c"], ["h", "k", "l"], ["m", "n", "l"], ["p", "q", "r"], ["r", "s", "t"], ["u", "v", "w"], ["x", "y", "z"]);
  }
  static RndCapitals() {
    return RndPick(["A", "B", "C"], ["H", "K", "L"], ["M", "N", "L"], ["P", "Q", "R"], ["R", "S", "T"], ["U", "V", "W"], ["X", "Y", "Z"]);
  }
};
__decorateClass$c([
  checkIt(owl.array, owl.positiveInt)
], Host$c, "RndPickN", 1);
__decorateClass$c([
  checkIt(owl.array, owl.positiveInt)
], Host$c, "RndPickUnique", 1);
Host$c = __decorateClass$c([
  exposeAll(),
  captureAll()
], Host$c);
var __defProp$b = Object.defineProperty;
var __getOwnPropDesc$b = Object.getOwnPropertyDescriptor;
var __decorateClass$b = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$b(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$b(target, key, result2);
  return result2;
};
let Host$b = class {
  static AreDistinct(...nums) {
    nums = nums.map(cal.blur);
    return new Set(nums).size === nums.length;
  }
  static AreAbsDistinct(...nums) {
    return AreDistinct(...nums.map(Math.abs));
  }
  static AreSameSign(...nums) {
    return [...new Set(nums.map(Math.sign))].length === 1;
  }
  static AreCoprime(...nums) {
    nums = nums.map(cal.blur);
    if (!IsInteger(...nums))
      return true;
    if (!IsNonZero(...nums))
      return true;
    return toList(nums).pairs().every(([a2, b2]) => HCF(a2, b2) === 1);
  }
  static AreDistantPoint(distance) {
    let AreDistant = function(...points) {
      return toShape2D(points).distances().min() >= distance;
    };
    return contract(AreDistant).sign([owl.point2D]);
  }
  static AreOblique(minAngle) {
    let areOblique = function(...slopes) {
      return toList(slopes).pairs().every(([a2, b2]) => IntersectAngle(a2, b2) >= minAngle);
    };
    return contract(areOblique).sign([owl.num]);
  }
  static AreDifferent(...items) {
    return toList(items).duplessDeep();
  }
};
__decorateClass$b([
  checkIt(owl.num)
], Host$b, "AreDistinct", 1);
__decorateClass$b([
  checkIt(owl.num)
], Host$b, "AreAbsDistinct", 1);
__decorateClass$b([
  checkIt(owl.num)
], Host$b, "AreSameSign", 1);
__decorateClass$b([
  checkIt(owl.num)
], Host$b, "AreCoprime", 1);
__decorateClass$b([
  checkIt(owl.positive)
], Host$b, "AreDistantPoint", 1);
__decorateClass$b([
  checkIt(owl.positive)
], Host$b, "AreOblique", 1);
Host$b = __decorateClass$b([
  exposeAll(),
  captureAll()
], Host$b);
var __defProp$a = Object.defineProperty;
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __decorateClass$a = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$a(target, key, result2);
  return result2;
};
let Host$a = class {
  static ListIntegers(start, end) {
    return cal.range(start, end);
  }
  static ASterm(a2, d2, n2) {
    return a2 + (n2 - 1) * d2;
  }
  static ASsum(a2, d2, n2) {
    return 0.5 * n2 * (2 * a2 + (n2 - 1) * d2);
  }
  static ASequence(a2, d2, n2 = 10) {
    let arr = [];
    for (let i2 = 1; i2 <= n2; i2++) {
      arr.push(ASterm(a2, d2, i2));
    }
    return arr;
  }
  static GSterm(a2, r2, n2) {
    return a2 * r2 ** (n2 - 1);
  }
  static GSsum(a2, r2, n2 = -1) {
    return n2 > 0 ? a2 * (r2 ** n2 - 1) / (r2 - 1) : a2 / (1 - r2);
  }
  static GSequence(a2, r2, n2 = 10) {
    let arr = [];
    for (let i2 = 1; i2 <= n2; i2++) {
      arr.push(GSterm(a2, r2, i2));
    }
    return arr;
  }
  static QuadraticSequence(a2, p2, q2, n2) {
    let c2 = a2;
    for (let i2 = 2; i2 <= n2; i2++) {
      c2 += p2 * (i2 - 1) + q2;
    }
    return c2;
  }
  static LucasSequence(first, second, p2, q2, n2) {
    if (n2 === 1)
      return first;
    if (n2 === 2)
      return second;
    let S2 = [first, second];
    for (let i2 = 3; i2 <= n2; i2++) {
      S2.push(p2 * S2[i2 - 2] + q2 * S2[i2 - 3]);
    }
    return S2[n2 - 1];
  }
};
__decorateClass$a([
  checkIt(owl.num),
  inspectIt(function is_range3(start, end) {
    return start < end;
  })
], Host$a, "ListIntegers", 1);
__decorateClass$a([
  checkIt(owl.num, owl.num, owl.positiveInt)
], Host$a, "ASterm", 1);
__decorateClass$a([
  checkIt(owl.num, owl.num, owl.positiveInt)
], Host$a, "ASsum", 1);
__decorateClass$a([
  checkIt(owl.num, owl.num, owl.positiveInt)
], Host$a, "ASequence", 1);
__decorateClass$a([
  checkIt(owl.num, owl.num, owl.positiveInt)
], Host$a, "GSterm", 1);
__decorateClass$a([
  checkIt(owl.num, owl.num, owl.int)
], Host$a, "GSsum", 1);
__decorateClass$a([
  checkIt(owl.num, owl.num, owl.positiveInt)
], Host$a, "GSequence", 1);
__decorateClass$a([
  checkIt(owl.num, owl.num, owl.num, owl.positiveInt)
], Host$a, "QuadraticSequence", 1);
__decorateClass$a([
  checkIt(owl.num, owl.num, owl.num, owl.num, owl.positiveInt)
], Host$a, "LucasSequence", 1);
Host$a = __decorateClass$a([
  exposeAll(),
  captureAll()
], Host$a);
var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorateClass$9 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$9(target, key, result2);
  return result2;
};
let Host$9 = class {
  static Min(...nums) {
    return Math.min(...nums);
  }
  static Max(...nums) {
    return Math.max(...nums);
  }
  static Sort(...nums) {
    return [...nums].sort((a2, b2) => a2 - b2);
  }
  static SortBy(items, valueFunc) {
    return [...items].sort((a2, b2) => valueFunc(a2) - valueFunc(b2));
  }
  static Sum(...nums) {
    return toData(nums).sum();
  }
  static Mean(...nums) {
    return toData(nums).mean();
  }
  static Median(...nums) {
    return toData(nums).median();
  }
  static LowerQ(...nums) {
    return toData(nums).lowerQuartile();
  }
  static UpperQ(...nums) {
    return toData(nums).upperQuartile();
  }
  static StatRange(...nums) {
    return toData(nums).range();
  }
  static IQR(...nums) {
    return toData(nums).IQR();
  }
  static Freq(array2, item) {
    return toList(array2).freq(item);
  }
  static Mode(...nums) {
    return [...toData(nums).modes()];
  }
  static UniMode(...nums) {
    return toData(nums).mode();
  }
  static StdDev(...nums) {
    return toData(nums).stdDev();
  }
  static ZScore(num2, mean, SD) {
    return (num2 - mean) / SD;
  }
  static MedianAt(total) {
    return (total + 1) / 2;
  }
  static LowerQAt(total) {
    total = Math.floor(total / 2);
    return MedianAt(total);
  }
  static UpperQAt(total) {
    return total + 1 - LowerQAt(total);
  }
  static ListRange(...data2) {
    let min2 = Math.min(...data2);
    let max2 = Math.max(...data2);
    return cal.range(min2, max2);
  }
  static Freqs(data2, nums) {
    let ls = toList(data2);
    nums != null ? nums : nums = ListRange(...data2);
    let arr = [];
    for (let v2 of nums) {
      arr.push(ls.freq(v2));
    }
    return arr;
  }
  static DataFromFreqs(values, frequencies) {
    Should(values.length === frequencies.length, "values and frequencies must be the same length");
    let data2 = [];
    for (let i2 = 0; i2 < values.length; i2++) {
      data2.push(...Array(frequencies[i2]).fill(values[i2]));
    }
    return data2;
  }
  static Summary(...data2) {
    let d2 = toData(data2);
    return [
      d2.min(),
      d2.lowerQuartile(),
      d2.median(),
      d2.upperQuartile(),
      d2.max()
    ];
  }
};
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "Min", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "Max", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "Sort", 1);
__decorateClass$9([
  checkIt(owl.array, owl.pass)
], Host$9, "SortBy", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "Sum", 1);
__decorateClass$9([
  checkIt(owl.num),
  inspectIt(function is_not_empty(...nums) {
    return nums.length > 0;
  })
], Host$9, "Mean", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "Median", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "LowerQ", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "UpperQ", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "StatRange", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "IQR", 1);
__decorateClass$9([
  checkIt(owl.array, owl.pass)
], Host$9, "Freq", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "Mode", 1);
__decorateClass$9([
  checkIt(owl.num),
  inspectIt(function has_single_mode(...nums) {
    return toData(nums).isSingleMode(1);
  })
], Host$9, "UniMode", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "StdDev", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "ZScore", 1);
__decorateClass$9([
  checkIt(owl.int)
], Host$9, "MedianAt", 1);
__decorateClass$9([
  checkIt(owl.int)
], Host$9, "LowerQAt", 1);
__decorateClass$9([
  checkIt(owl.int)
], Host$9, "UpperQAt", 1);
__decorateClass$9([
  checkIt(owl.int)
], Host$9, "ListRange", 1);
__decorateClass$9([
  checkIt(owl.ntuple, owl.ntuple)
], Host$9, "Freqs", 1);
__decorateClass$9([
  checkIt(owl.ntuple)
], Host$9, "DataFromFreqs", 1);
__decorateClass$9([
  checkIt(owl.num)
], Host$9, "Summary", 1);
Host$9 = __decorateClass$9([
  exposeAll(),
  captureAll()
], Host$9);
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorateClass$8 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$8(target, key, result2);
  return result2;
};
let Host$8 = class {
  static GrammarJoin(...items) {
    let L2 = items.length;
    if (L2 === 0)
      return "";
    if (L2 === 1)
      return String(items[0]);
    let arr = [];
    for (let i2 = 0; i2 < L2 - 1; i2++) {
      arr.push(items[i2]);
    }
    return arr.join(", ") + " and " + items[items.length - 1];
  }
  static IneqSign(greater, equal2 = false) {
    if (greater && equal2) {
      return ["\\ge", "\\le"];
    }
    if (greater && !equal2) {
      return ["\\gt", "\\lt"];
    }
    if (!greater && equal2) {
      return ["\\le", "\\ge"];
    }
    if (!greater && !equal2) {
      return ["\\lt", "\\gt"];
    }
    throw "never";
  }
  static Dfrac(numerator, denominator, upSign = false) {
    return ink.printDfrac(numerator, denominator, upSign);
  }
  static IndexToSurd(text2) {
    return text2.replace(/\{\(*([^\{\(\}\)]*)\)*\}\^\{0\.5\}/g, "\\sqrt{$1}");
  }
  static Coord(point, dp2 = 1) {
    let [a2, b2] = point.map((_) => cal.blur(_));
    a2 = Fix(a2, dp2);
    b2 = Fix(b2, dp2);
    return "(" + a2 + ", " + b2 + ")";
  }
  static Sci(num2) {
    if (num2 === 0)
      return "0";
    let m2 = cal.e(cal.blur(num2));
    if (m2 === 0)
      return num2.toString();
    num2 = num2 / 10 ** m2;
    num2 = cal.blur(num2);
    return num2.toString() + " \\times 10^{ " + m2 + "}";
  }
  static LongDivision(dividend, divisor) {
    dividend = dividend.reverse();
    divisor = divisor.reverse();
    function xTerm(power) {
      if (power === 0)
        return "";
      if (power === 1)
        return "x";
      return "x^" + power;
    }
    function printSolid(poly) {
      let arr = [];
      poly.forEach((v2, i2) => {
        if (v2 !== null)
          arr.push(v2 + xTerm(i2));
      });
      return arr.reverse().join("+");
    }
    function printUnderline(poly) {
      return "\\underline{" + printSolid(poly) + "}";
    }
    function printPhantom(poly) {
      let arr = [];
      poly.forEach((v2, i2) => {
        if (v2 === null)
          arr.push(dividend[i2] + xTerm(i2));
      });
      let T2 = arr.reverse().join("+");
      if (T2.length === 0)
        return "";
      return "\\phantom{+" + T2 + "}";
    }
    function writeSolid(poly) {
      return printSolid(poly) + printPhantom(poly);
    }
    function writeUnderline(poly) {
      return printUnderline(poly) + printPhantom(poly);
    }
    function pushDivide(dividend2, divisor2) {
      let t1 = dividend2[dividend2.length - 1];
      let t2 = divisor2[divisor2.length - 1];
      return t1 / t2;
    }
    function step(current, divisor2) {
      let q2 = pushDivide(current, divisor2);
      let under = divisor2.map((x2) => x2 * q2);
      for (let i2 = 1; i2 <= current.length - divisor2.length; i2++)
        under.unshift(null);
      let next = [];
      for (let i2 = 0; i2 < current.length - 1; i2++)
        next.push(current[i2] - Number(under[i2]));
      let nextPrint = [...next].reverse();
      for (let i2 = 0; i2 < nextPrint.length; i2++)
        if (i2 > divisor2.length - 1)
          nextPrint[i2] = null;
      nextPrint.reverse();
      return { next, nextPrint, under, q: q2 };
    }
    function compose(dividend2, divisor2) {
      let T2 = "\\begin{array}{r}";
      T2 += "QUOTIENT \\\\";
      T2 += writeSolid(divisor2);
      T2 += "{\\overline{\\smash{\\big)}";
      T2 += writeSolid(dividend2);
      T2 += "}}\\\\";
      let current = dividend2;
      let quotient = [];
      while (true) {
        let { next, nextPrint, under, q: q2 } = step(current, divisor2);
        T2 += writeUnderline(under) + "\\\\";
        T2 += writeSolid(nextPrint) + "\\\\";
        current = next;
        quotient.push(q2);
        if (current.length < divisor2.length)
          break;
      }
      T2 += "\\end{array}";
      quotient.reverse();
      T2 = T2.replace("QUOTIENT", writeSolid(quotient));
      return T2;
    }
    return compose(dividend, divisor);
  }
  static ToBase(num2, base2) {
    return num2.toString(base2).toUpperCase() + "_{" + base2 + "}";
  }
  static PrimeFactorize(val, { hcf = false, lcm = false, multiply = false }) {
    let T2 = "\\begin{matrix} ";
    function add2(variable, power) {
      let s2 = multiply ? "& \\times &" : "&";
      if (power > 1) {
        T2 += s2 + variable + "^{" + power + "}";
      } else if (power === 1) {
        T2 += s2 + variable;
      } else {
        T2 += multiply ? "& &" : " & ";
      }
    }
    let keys = Object.keys(val);
    let n2 = val[keys[0]].length;
    for (let i2 = 0; i2 < n2; i2++) {
      T2 += " & ";
      if (keys.includes("number"))
        T2 += " & " + val.number[i2];
      for (let k2 of keys) {
        if (k2 === "number")
          continue;
        add2(k2, val[k2][i2]);
      }
      T2 += " \\\\ ";
    }
    T2 += "\\hline";
    if (hcf) {
      T2 += " \\text{HCF} & = ";
      if (keys.includes("number"))
        T2 += " & " + HCF(...val.number);
      for (let k2 of keys) {
        if (k2 === "number")
          continue;
        add2(k2, Min(...val[k2]));
      }
      T2 += " \\\\ ";
    }
    if (lcm) {
      T2 += " \\text{LCM} & = ";
      if (keys.includes("number"))
        T2 += " & " + LCM(...val.number);
      for (let k2 of keys) {
        if (k2 === "number")
          continue;
        add2(k2, Max(...val[k2]));
      }
      T2 += " \\\\ ";
    }
    T2 += "\\end{matrix}";
    return T2;
  }
  static ConstraintText(constraint2, sign2 = true, xReplace = "x", yReplace = "y") {
    if (sign2 === false)
      constraint2 = rein(constraint2).flip().constraint;
    let T2 = ink.printConstraint(constraint2, false, sign2 === null);
    T2 = T2.replace(/x/g, xReplace);
    T2 = T2.replace(/y/g, yReplace);
    return T2;
  }
};
__decorateClass$8([
  checkIt(owl.bool, owl.bool)
], Host$8, "IneqSign", 1);
__decorateClass$8([
  checkIt(owl.num, owl.nonZero, owl.bool)
], Host$8, "Dfrac", 1);
__decorateClass$8([
  checkIt(owl.str)
], Host$8, "IndexToSurd", 1);
__decorateClass$8([
  checkIt(owl.point2D)
], Host$8, "Coord", 1);
__decorateClass$8([
  checkIt(owl.num)
], Host$8, "Sci", 1);
__decorateClass$8([
  checkIt(owl.ntuple, owl.ntuple)
], Host$8, "LongDivision", 1);
__decorateClass$8([
  checkIt([owl.num, Number.isSafeInteger], owl.positiveInt)
], Host$8, "ToBase", 1);
__decorateClass$8([
  checkIt(owl.object, owl.object)
], Host$8, "PrimeFactorize", 1);
__decorateClass$8([
  checkIt(owl.constraint, owl.pass, owl.str, owl.str)
], Host$8, "ConstraintText", 1);
Host$8 = __decorateClass$8([
  exposeAll(),
  captureAll()
], Host$8);
var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorateClass$7 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$7(target, key, result2);
  return result2;
};
let angle = owl.between(0, 180);
let side = owl.positive;
function triangle_ineq(a2, b2, c2) {
  return owl.triangleSides([a2, b2, c2]);
}
let Host$7 = class {
  static Pyth(a2, b2) {
    return (a2 ** 2 + b2 ** 2) ** 0.5;
  }
  static PythLeg(c2, a2) {
    return (c2 ** 2 - a2 ** 2) ** 0.5;
  }
  static CosineLawLength(a2, b2, C2) {
    return (a2 ** 2 + b2 ** 2 - 2 * a2 * b2 * cos(C2)) ** 0.5;
  }
  static CosineLawAngle(a2, b2, c2) {
    return arccos((c2 ** 2 - a2 ** 2 - b2 ** 2) / (-2 * a2 * b2));
  }
  static SineLawLength(A2, a2, B2) {
    return a2 / sin(A2) * sin(B2);
  }
  static SineLawAngle(a2, A2, b2) {
    return arcsin(sin(A2) / a2 * b2);
  }
  static Heron(a2, b2, c2) {
    let s2 = (a2 + b2 + c2) / 2;
    return (s2 * (s2 - a2) * (s2 - b2) * (s2 - c2)) ** 0.5;
  }
  static SolveSSS(a2, b2, c2) {
    let A2 = CosineLawAngle(b2, c2, a2);
    let B2 = CosineLawAngle(c2, a2, b2);
    let C2 = CosineLawAngle(a2, b2, c2);
    return [C2, A2, B2];
  }
  static SolveSAS(a2, C2, b2) {
    let c2 = CosineLawLength(a2, b2, C2);
    let [_, A2, B2] = SolveSSS(a2, b2, c2);
    return [A2, c2, B2];
  }
  static SolveAAS(A2, B2, a2) {
    let C2 = 180 - A2 - B2;
    let b2 = SineLawLength(A2, a2, B2);
    let c2 = CosineLawLength(a2, b2, C2);
    return [c2, C2, b2];
  }
  static SolveASA(A2, c2, B2) {
    let C2 = 180 - A2 - B2;
    let a2 = SineLawLength(C2, c2, A2);
    let b2 = SineLawLength(C2, c2, B2);
    return [a2, C2, b2];
  }
  static SolveSSA(a2, b2, A2) {
    let B2 = SineLawAngle(a2, A2, b2);
    let C2 = 180 - A2 - B2;
    let c2 = SineLawLength(A2, a2, C2);
    return [C2, c2, B2];
  }
  static HeightsBySSS(a2, b2, c2) {
    let area = Heron(a2, b2, c2);
    let Ha = 2 * area / a2;
    let Hb = 2 * area / b2;
    let Hc = 2 * area / c2;
    return [Ha, Hb, Hc];
  }
  static HeightBySSS(a2, b2, c2) {
    let area = Heron(a2, b2, c2);
    return 2 * area / a2;
  }
  static HeightsBySAS(a2, C2, b2) {
    let [A2, c2, B2] = SolveSAS(a2, C2, b2);
    return HeightsBySSS(a2, b2, c2);
  }
  static HeightBySAS(a2, C2, b2) {
    let [ha, hb, hc] = HeightsBySAS(a2, C2, b2);
    return hc;
  }
  static TriangleFromVertex(A2, B2, C2, fix2 = true) {
    let sideC = Distance(A2, B2);
    let sideA = Distance(B2, C2);
    let sideB = Distance(C2, A2);
    let angleC = CosineLawAngle(sideA, sideB, sideC);
    let angleA = CosineLawAngle(sideB, sideC, sideA);
    let angleB = CosineLawAngle(sideA, sideC, sideB);
    if (fix2) {
      sideC = Fix(sideC);
      sideA = Fix(sideA);
      sideB = Fix(sideB);
      angleC = Fix(angleC);
      angleA = Fix(angleA);
      angleB = Fix(angleB);
    }
    return { sideC, angleB, sideA, angleC, sideB, angleA };
  }
  static SolveTriangle({ sideA, sideB, sideC, angleA, angleB, angleC }) {
    let a2 = sideA;
    let b2 = sideB;
    let c2 = sideC;
    let A2 = angleA;
    let B2 = angleB;
    let C2 = angleC;
    if (a2 === null)
      throw "SolveTriangle not accept null now";
    if (b2 === null)
      throw "SolveTriangle not accept null now";
    if (c2 === null)
      throw "SolveTriangle not accept null now";
    if (A2 === null)
      throw "SolveTriangle not accept null now";
    if (B2 === null)
      throw "SolveTriangle not accept null now";
    if (C2 === null)
      throw "SolveTriangle not accept null now";
    function angleSum() {
      if (A2 === void 0 && B2 !== void 0 && C2 !== void 0)
        A2 = 180 - B2 - C2;
      if (B2 === void 0 && A2 !== void 0 && C2 !== void 0)
        B2 = 180 - A2 - C2;
      if (C2 === void 0 && B2 !== void 0 && A2 !== void 0)
        C2 = 180 - A2 - B2;
    }
    function SSS() {
      if (a2 !== void 0 && b2 !== void 0 && c2 !== void 0) {
        A2 = CosineLawAngle(b2, c2, a2);
        B2 = CosineLawAngle(c2, a2, b2);
        C2 = CosineLawAngle(a2, b2, c2);
      }
    }
    function SAS() {
      if (a2 !== void 0 && b2 !== void 0 && C2 !== void 0 && c2 === void 0)
        c2 = CosineLawLength(a2, b2, C2);
      if (b2 !== void 0 && c2 !== void 0 && A2 !== void 0 && a2 === void 0)
        a2 = CosineLawLength(b2, c2, A2);
      if (c2 !== void 0 && a2 !== void 0 && B2 !== void 0 && b2 === void 0)
        b2 = CosineLawLength(c2, a2, B2);
    }
    function AAS() {
      let r2 = void 0;
      if (A2 !== void 0 && a2 !== void 0 && r2 === void 0)
        r2 = sin(A2) / a2;
      if (B2 !== void 0 && b2 !== void 0 && r2 === void 0)
        r2 = sin(B2) / b2;
      if (C2 !== void 0 && c2 !== void 0 && r2 === void 0)
        r2 = sin(C2) / c2;
      if (r2 !== void 0 && A2 !== void 0 && a2 === void 0)
        a2 = sin(A2) / r2;
      if (r2 !== void 0 && B2 !== void 0 && b2 === void 0)
        b2 = sin(B2) / r2;
      if (r2 !== void 0 && C2 !== void 0 && c2 === void 0)
        c2 = sin(C2) / r2;
    }
    for (let i2 = 0; i2 < 10; i2++) {
      if (a2 !== void 0 && b2 !== void 0 && c2 !== void 0 && A2 !== void 0 && B2 !== void 0 && C2 !== void 0) {
        return { sideA: a2, sideB: b2, sideC: c2, angleA: A2, angleB: B2, angleC: C2 };
      }
      angleSum();
      SSS();
      SAS();
      AAS();
    }
    Should(false, "Solve Triangle Fail!");
    throw "never";
  }
  static Orthocentre(A2, B2, C2) {
    let H2 = PdFoot(A2, B2, C2);
    let G2 = PdFoot(B2, C2, A2);
    let [x2, y2] = Intersection(C2, H2, A2, G2);
    return [cal.blur(x2), cal.blur(y2)];
  }
  static Circumcentre(A2, B2, C2) {
    let [a1, b1, c1] = LinearFromBisector(A2, B2);
    let [a2, b2, c2] = LinearFromBisector(B2, C2);
    let [x2, y2] = Crammer(a1, b1, -c1, a2, b2, -c2);
    return [cal.blur(x2), cal.blur(y2)];
  }
  static Centroid(A2, B2, C2) {
    let [x2, y2] = [(A2[0] + B2[0] + C2[0]) / 3, (A2[1] + B2[1] + C2[1]) / 3];
    return [cal.blur(x2), cal.blur(y2)];
  }
  static Incentre(A2, B2, C2) {
    let a2 = Distance(B2, C2);
    let b2 = Distance(A2, C2);
    let c2 = Distance(A2, B2);
    let p2 = a2 + b2 + c2;
    let x2 = (a2 * A2[0] + b2 * B2[0] + c2 * C2[0]) / p2;
    let y2 = (a2 * A2[1] + b2 * B2[1] + c2 * C2[1]) / p2;
    return [cal.blur(x2), cal.blur(y2)];
  }
  static ScaleOrthocentreToInt(A2, B2, C2) {
    let [x2, y2] = Orthocentre(A2, B2, C2);
    let q2 = numbers(x2, y2, ...A2, ...B2, ...C2).ratioFactor();
    Should(owl.num(q2), "original orthocentre must be rational");
    return shape2D(A2, B2, C2).scale(q2).toArray();
  }
  static ScaleCircumcentreToInt(A2, B2, C2) {
    let [x2, y2] = Circumcentre(A2, B2, C2);
    let q2 = numbers(x2, y2, ...A2, ...B2, ...C2).ratioFactor();
    Should(owl.num(q2), "original circumcentre must be rational");
    return shape2D(A2, B2, C2).scale(q2).toArray();
  }
  static ScaleCentroidToInt(A2, B2, C2) {
    let [x2, y2] = Centroid(A2, B2, C2);
    let q2 = numbers(x2, y2, ...A2, ...B2, ...C2).ratioFactor();
    Should(owl.num(q2), "original centroid must be rational");
    return shape2D(A2, B2, C2).scale(q2).toArray();
  }
  static ScaleIncentreToInt(A2, B2, C2) {
    let [x2, y2] = Incentre(A2, B2, C2);
    let q2 = numbers(x2, y2, ...A2, ...B2, ...C2).ratioFactor();
    Should(owl.num(q2), "original incentre must be rational");
    return shape2D(A2, B2, C2).scale(q2).toArray();
  }
};
__decorateClass$7([
  checkIt(side)
], Host$7, "Pyth", 1);
__decorateClass$7([
  checkIt(side),
  inspectIt(function is_triangle(c2, a2) {
    return c2 >= a2;
  })
], Host$7, "PythLeg", 1);
__decorateClass$7([
  checkIt(side, side, angle)
], Host$7, "CosineLawLength", 1);
__decorateClass$7([
  checkIt(side),
  inspectIt(triangle_ineq)
], Host$7, "CosineLawAngle", 1);
__decorateClass$7([
  checkIt(angle, side, angle)
], Host$7, "SineLawLength", 1);
__decorateClass$7([
  checkIt(side, angle, side),
  inspectIt(function is_triangle2(a2, A2, b2) {
    return sin(A2) / a2 * b2 >= 0 && sin(A2) / a2 * b2 <= 1;
  })
], Host$7, "SineLawAngle", 1);
__decorateClass$7([
  checkIt(side),
  inspectIt(triangle_ineq)
], Host$7, "Heron", 1);
__decorateClass$7([
  checkIt(side),
  inspectIt(triangle_ineq)
], Host$7, "SolveSSS", 1);
__decorateClass$7([
  checkIt(side, angle, side)
], Host$7, "SolveSAS", 1);
__decorateClass$7([
  checkIt(angle, angle, side)
], Host$7, "SolveAAS", 1);
__decorateClass$7([
  checkIt(angle, side, angle)
], Host$7, "SolveASA", 1);
__decorateClass$7([
  checkIt(side, side, angle)
], Host$7, "SolveSSA", 1);
__decorateClass$7([
  checkIt(side),
  inspectIt(triangle_ineq)
], Host$7, "HeightsBySSS", 1);
__decorateClass$7([
  checkIt(side),
  inspectIt(triangle_ineq)
], Host$7, "HeightBySSS", 1);
__decorateClass$7([
  checkIt(side, angle, side)
], Host$7, "HeightsBySAS", 1);
__decorateClass$7([
  checkIt(side, angle, side)
], Host$7, "HeightBySAS", 1);
__decorateClass$7([
  checkIt(owl.point2D, owl.point2D, owl.point2D, owl.bool)
], Host$7, "TriangleFromVertex", 1);
__decorateClass$7([
  checkIt(owl.point2D)
], Host$7, "Orthocentre", 1);
__decorateClass$7([
  checkIt(owl.point2D)
], Host$7, "Circumcentre", 1);
__decorateClass$7([
  checkIt(owl.point2D)
], Host$7, "Centroid", 1);
__decorateClass$7([
  checkIt(owl.point2D)
], Host$7, "Incentre", 1);
__decorateClass$7([
  checkIt(owl.point2D)
], Host$7, "ScaleOrthocentreToInt", 1);
__decorateClass$7([
  checkIt(owl.point2D)
], Host$7, "ScaleCircumcentreToInt", 1);
__decorateClass$7([
  checkIt(owl.point2D)
], Host$7, "ScaleCentroidToInt", 1);
__decorateClass$7([
  checkIt(owl.point2D)
], Host$7, "ScaleIncentreToInt", 1);
Host$7 = __decorateClass$7([
  exposeAll(),
  captureAll()
], Host$7);
var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$6(target, key, result2);
  return result2;
};
let Host$6 = class {
  static Quadrant(rect) {
    if (!Array.isArray(rect))
      rect = PolToRect([1, rect]);
    const q2 = RectToPol(rect)[1];
    if (q2 >= 0 && q2 < 90)
      return "I";
    if (q2 >= 90 && q2 < 180)
      return "II";
    if (q2 >= 180 && q2 < 270)
      return "III";
    if (q2 >= 270 && q2 < 360)
      return "IV";
    Should(false, "fail to parse quadrant!");
    throw "never";
  }
  static PolToRect([r2, q2]) {
    return [r2 * cos(q2), r2 * sin(q2)];
  }
  static RectToPol([x2, y2]) {
    const r2 = Math.sqrt(x2 * x2 + y2 * y2);
    let q2 = Math.atan2(y2, x2) * 180 / Math.PI;
    if (q2 < 0)
      q2 = q2 + 360;
    return [r2, q2];
  }
  static ASTC(quadrant2, func) {
    if (quadrant2 == "I")
      quadrant2 = 1;
    if (quadrant2 == "II")
      quadrant2 = 2;
    if (quadrant2 == "III")
      quadrant2 = 3;
    if (quadrant2 == "IV")
      quadrant2 = 4;
    if (quadrant2 == 1)
      return 1;
    if (quadrant2 == 2)
      return func === "sin" ? 1 : -1;
    if (quadrant2 == 3)
      return func === "tan" ? 1 : -1;
    if (quadrant2 == 4)
      return func === "cos" ? 1 : -1;
    return 0;
  }
  static TrigRoot(func, k2) {
    if (func == "sin") {
      if (k2 > 1 || k2 < -1)
        return [void 0, void 0, void 0];
      if (k2 == 0)
        return [0, 180, 360];
      if (k2 == 1)
        return [90, void 0, void 0];
      if (k2 == -1)
        return [270, void 0, void 0];
      if (k2 > 0) {
        let a2 = arcsin(k2);
        let b2 = 180 - a2;
        return [a2, b2, void 0];
      }
      if (k2 < 0) {
        let x2 = -arcsin(k2);
        let a2 = 180 + x2;
        let b2 = 360 - x2;
        return [a2, b2, void 0];
      }
    }
    if (func == "cos") {
      if (k2 > 1 || k2 < -1)
        return [void 0, void 0, void 0];
      if (k2 == 0)
        return [90, 270, void 0];
      if (k2 == 1)
        return [0, 360, void 0];
      if (k2 == -1)
        return [180, void 0, void 0];
      let a2 = arccos(k2);
      let b2 = 360 - a2;
      return [a2, b2, void 0];
    }
    if (func == "tan") {
      if (k2 == 0)
        return [0, 180, 360];
      if (k2 > 0) {
        let a2 = arctan(k2);
        let b2 = 180 + a2;
        return [a2, b2, void 0];
      }
      if (k2 < 0) {
        let x2 = -arctan(k2);
        let a2 = 180 - x2;
        let b2 = 360 - x2;
        return [a2, b2, void 0];
      }
    }
    return [void 0, void 0, void 0];
  }
  static TrigSolve(func, k2) {
    if (func == "sin") {
      if (k2 > 1 || k2 < -1)
        return [];
      if (k2 == 0)
        return [0, 180, 360];
      if (k2 == 1)
        return [90];
      if (k2 == -1)
        return [270];
      if (k2 > 0) {
        let a2 = arcsin(k2);
        let b2 = 180 - a2;
        return [a2, b2];
      }
      if (k2 < 0) {
        let x2 = -arcsin(k2);
        let a2 = 180 + x2;
        let b2 = 360 - x2;
        return [a2, b2];
      }
    }
    if (func == "cos") {
      if (k2 > 1 || k2 < -1)
        return [];
      if (k2 == 0)
        return [90, 270];
      if (k2 == 1)
        return [0, 360];
      if (k2 == -1)
        return [180];
      let a2 = arccos(k2);
      let b2 = 360 - a2;
      return [a2, b2];
    }
    if (func == "tan") {
      if (k2 == 0)
        return [0, 180, 360];
      if (k2 > 0) {
        let a2 = arctan(k2);
        let b2 = 180 + a2;
        return [a2, b2];
      }
      if (k2 < 0) {
        let x2 = -arctan(k2);
        let a2 = 180 - x2;
        let b2 = 360 - x2;
        return [a2, b2];
      }
    }
    return [];
  }
  static PolarReduce(q2) {
    q2 = q2 % 360;
    if (q2 < 0)
      q2 += 360;
    return q2;
  }
  static PolarDiff(angle1, angle2) {
    angle1 = PolarReduce(angle1);
    angle2 = PolarReduce(angle2);
    let d2 = Abs(angle1 - angle2);
    return Math.min(d2, 360 - d2);
  }
  static WholeBearing(polarAngle) {
    let q2 = polarAngle;
    q2 = PolarReduce(q2);
    q2 = cal.blur(q2);
    q2 = q2 <= 90 ? 90 - q2 : 450 - q2;
    q2 = cal.blur(q2);
    return q2.toString().padStart(3, "0") + "\xB0";
  }
  static CompassBearing(polarAngle) {
    let q2 = polarAngle;
    q2 = PolarReduce(q2);
    q2 = cal.blur(q2);
    if (q2 === 0)
      return "east";
    if (q2 === 270)
      return "south";
    if (q2 === 180)
      return "west";
    if (q2 === 90)
      return "north";
    if (0 < q2 && q2 < 90)
      return "N" + (90 - q2) + "\xB0E";
    if (90 < q2 && q2 < 180)
      return "N" + (q2 - 90) + "\xB0W";
    if (180 < q2 && q2 < 270)
      return "S" + (270 - q2) + "\xB0W";
    if (270 < q2 && q2 < 360)
      return "S" + (q2 - 270) + "\xB0E";
    throw "never";
  }
};
__decorateClass$6([
  checkIt(owl.or([owl.point2D, owl.num]))
], Host$6, "Quadrant", 1);
__decorateClass$6([
  checkIt(owl.polar)
], Host$6, "PolToRect", 1);
__decorateClass$6([
  checkIt(owl.point2D)
], Host$6, "RectToPol", 1);
__decorateClass$6([
  checkIt(owl.quadrant, owl.trig)
], Host$6, "ASTC", 1);
__decorateClass$6([
  checkIt(owl.trig, owl.num)
], Host$6, "TrigRoot", 1);
__decorateClass$6([
  checkIt(owl.trig, owl.num)
], Host$6, "TrigSolve", 1);
__decorateClass$6([
  checkIt(owl.num)
], Host$6, "PolarReduce", 1);
__decorateClass$6([
  checkIt(owl.num)
], Host$6, "PolarDiff", 1);
__decorateClass$6([
  checkIt(owl.int)
], Host$6, "WholeBearing", 1);
__decorateClass$6([
  checkIt(owl.int)
], Host$6, "CompassBearing", 1);
Host$6 = __decorateClass$6([
  exposeAll(),
  captureAll()
], Host$6);
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$5(target, key, result2);
  return result2;
};
let Host$5 = class {
  static Mid3D(...vectors) {
    const x2 = Sum(...vectors.map((p2) => p2[0])) / vectors.length;
    const y2 = Sum(...vectors.map((p2) => p2[1])) / vectors.length;
    const z2 = Sum(...vectors.map((p2) => p2[2])) / vectors.length;
    return [x2, y2, z2];
  }
  static Slide3D(A2, B2, ratio) {
    let r2 = ratio;
    let s2 = 1 - r2;
    return [
      A2[0] * s2 + B2[0] * r2,
      A2[1] * s2 + B2[1] * r2,
      A2[2] * s2 + B2[2] * r2
    ];
  }
  static PdFoot3D(point, base2) {
    if (base2.length === 3) {
      let [A2, B2, C2] = base2;
      return vec3D(A2, point).projectOnPlane(vec3D(A2, B2), vec3D(B2, C2)).add(A2).toArray();
    } else if (base2.length === 2) {
      let [A2, B2] = base2;
      return vec3D(A2, point).projectOn(vec3D(A2, B2)).add(A2).toArray();
    }
    Should(false, "base must have 2 or 3 points");
    throw "never";
  }
  static Embed(plane2D, origin, xVec, yVec) {
    return toShape2D(plane2D).erect(xVec, yVec).translate(origin).toArray();
  }
  static EmbedX(plane2D, x2 = 0) {
    return Embed(plane2D, [x2, 0, 0], [0, 1, 0], [0, 0, 1]);
  }
  static EmbedY(plane2D, y2 = 0) {
    return Embed(plane2D, [0, y2, 0], [1, 0, 0], [0, 0, 1]);
  }
  static EmbedZ(plane2D, z2 = 0) {
    return Embed(plane2D, [0, 0, z2], [1, 0, 0], [0, 1, 0]);
  }
  static FlatZ(points, z2 = 0) {
    return points.map(([x2, y2, _]) => [x2, y2, z2]);
  }
  static Extrude(lowerBase, upperBase, scale) {
    let max2 = Math.max(lowerBase.length, upperBase.length);
    let LB = toShape3D(lowerBase).padTail(max2);
    let UB = toShape3D(upperBase).padTail(max2);
    return LB.extrudeToShape(UB, scale).toArray();
  }
  static Projector(angle2 = 60, depth = 0.5) {
    return function(x2, y2, z2) {
      let x_new = x2 + depth * y2 * cos(angle2);
      let y_new = z2 + depth * y2 * sin(angle2);
      return [x_new, y_new];
    };
  }
  static Projector3D(angle2 = 60, depth = 0.5) {
    let projector = function(point3D2) {
      let [x2, y2, z2] = point3D2;
      let x_new = x2 + depth * y2 * cos(angle2);
      let y_new = z2 + depth * y2 * sin(angle2);
      return [x_new, y_new];
    };
    return contract(projector).sign([owl.point3D]);
  }
};
__decorateClass$5([
  checkIt(owl.vector3D)
], Host$5, "Mid3D", 1);
__decorateClass$5([
  checkIt(owl.point3D, owl.point3D, owl.num)
], Host$5, "Slide3D", 1);
__decorateClass$5([
  checkIt(owl.point3D, owl.point3Ds)
], Host$5, "PdFoot3D", 1);
__decorateClass$5([
  checkIt(owl.point2Ds, owl.point3D, owl.vector3D, owl.vector3D)
], Host$5, "Embed", 1);
__decorateClass$5([
  checkIt(owl.point2Ds, owl.num)
], Host$5, "EmbedX", 1);
__decorateClass$5([
  checkIt(owl.point2Ds, owl.num)
], Host$5, "EmbedY", 1);
__decorateClass$5([
  checkIt(owl.point2Ds, owl.num)
], Host$5, "EmbedZ", 1);
__decorateClass$5([
  checkIt(owl.point3Ds, owl.num)
], Host$5, "FlatZ", 1);
__decorateClass$5([
  checkIt(owl.point3Ds, owl.point3Ds, owl.num)
], Host$5, "Extrude", 1);
__decorateClass$5([
  checkIt(owl.num, owl.num)
], Host$5, "Projector3D", 1);
Host$5 = __decorateClass$5([
  exposeAll(),
  captureAll()
], Host$5);
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$4(target, key, result2);
  return result2;
};
let Host$4 = class {
  static Crammer(a2, b2, c2, p2, q2, r2) {
    const D2 = a2 * q2 - b2 * p2;
    const x2 = (c2 * q2 - b2 * r2) / D2;
    const y2 = (a2 * r2 - c2 * p2) / D2;
    return [x2, y2];
  }
  static xPolynomial(poly1, poly2) {
    const deg1 = poly1.length - 1;
    const deg2 = poly2.length - 1;
    const deg3 = deg1 + deg2;
    const result2 = Array(deg3 + 1).fill(0);
    for (let i2 = 0; i2 <= deg1; i2++) {
      for (let j2 = 0; j2 <= deg2; j2++) {
        result2[i2 + j2] += poly1[i2] * poly2[j2];
      }
    }
    return result2;
  }
};
__decorateClass$4([
  checkIt(owl.num),
  inspectIt(function has_unique_sol(a2, b2, c2, p2, q2, r2) {
    return a2 * q2 - b2 * p2 !== 0;
  })
], Host$4, "Crammer", 1);
__decorateClass$4([
  checkIt([owl.ntuple, function non_zero_leading_coeff(_) {
    return _[0] !== 0;
  }])
], Host$4, "xPolynomial", 1);
Host$4 = __decorateClass$4([
  exposeAll(),
  captureAll()
], Host$4);
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$3(target, key, result2);
  return result2;
};
let Host$3 = class {
  static CircleGeneral(centre, radius) {
    let [h2, k2] = centre;
    let r2 = radius;
    let D2 = -2 * h2;
    let E2 = -2 * k2;
    let F2 = h2 ** 2 + k2 ** 2 - r2 ** 2;
    return [D2, E2, F2];
  }
  static CircleFromGeneral(D2, E2, F2) {
    let [h2, k2] = [-D2 / 2, -E2 / 2];
    let R2 = (D2 / 2) ** 2 + (E2 / 2) ** 2 - F2;
    Should(R2 >= 0, "radius should be real");
    let r2 = R2 ** 0.5;
    return [[h2, k2], r2];
  }
  static CircleLinearIntersect(center, radius, linear2) {
    let [a2, b2, c2] = linear2;
    let [h2, k2] = center;
    let r2 = radius;
    if (b2 !== 0) {
      let m2 = -a2 / b2;
      let n2 = -c2 / b2 - k2;
      let A2 = 1 + m2 * m2;
      let B2 = -2 * h2 + 2 * m2 * n2;
      let C2 = h2 * h2 + n2 * n2 - r2 * r2;
      Should(Discriminant(A2, B2, C2) >= 0, "no intersection");
      let [x1, x2] = QuadraticRoot(A2, B2, C2);
      let y1 = (-a2 * x1 - c2) / b2;
      let y2 = (-a2 * x2 - c2) / b2;
      let P2 = [cal.blur(x1), cal.blur(y1)];
      let Q2 = [cal.blur(x2), cal.blur(y2)];
      return [P2, Q2];
    } else {
      let x2 = -c2 / a2;
      let D2 = r2 * r2 - (x2 - h2) ** 2;
      Should(D2 >= 0, "no intersection");
      let y1 = k2 - Math.sqrt(D2);
      let y2 = k2 + Math.sqrt(D2);
      let P2 = [cal.blur(x2), cal.blur(y1)];
      let Q2 = [cal.blur(x2), cal.blur(y2)];
      return [P2, Q2];
    }
  }
  static CircleLineIntersect(center, radius, [A2, B2]) {
    let lin2 = LinearFromTwoPoints(A2, B2);
    return CircleLinearIntersect(center, radius, lin2);
  }
};
__decorateClass$3([
  checkIt(owl.point2D, owl.positive)
], Host$3, "CircleGeneral", 1);
__decorateClass$3([
  checkIt(owl.num)
], Host$3, "CircleFromGeneral", 1);
__decorateClass$3([
  checkIt(owl.point2D, owl.positive, owl.triple)
], Host$3, "CircleLinearIntersect", 1);
__decorateClass$3([
  checkIt(owl.point2D, owl.positive, owl.point2Ds)
], Host$3, "CircleLineIntersect", 1);
Host$3 = __decorateClass$3([
  exposeAll(),
  captureAll()
], Host$3);
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$2(target, key, result2);
  return result2;
};
let Host$2 = class {
  static Discriminant(a2, b2, c2) {
    return b2 * b2 - 4 * a2 * c2;
  }
  static QuadraticRoot(a2, b2, c2) {
    const d2 = Discriminant(a2, b2, c2);
    const s2 = Math.sqrt(d2);
    const r1 = Divide(-b2 - s2, 2 * a2);
    const r2 = Divide(-b2 + s2, 2 * a2);
    return [Min(r1, r2), Max(r1, r2)];
  }
  static QuadraticVertex(a2, b2, c2) {
    const h2 = Divide(-b2, 2 * a2);
    const k2 = a2 * h2 * h2 + b2 * h2 + c2;
    return [h2, k2];
  }
  static QuadraticFromRoot(a2, p2, q2) {
    return [a2, -a2 * (p2 + q2), a2 * p2 * q2];
  }
  static QuadraticFromVertex(a2, h2, k2) {
    const b2 = -2 * a2 * h2;
    const c2 = k2 - a2 * h2 * h2 - b2 * h2;
    return [a2, b2, c2];
  }
};
__decorateClass$2([
  checkIt(owl.nonZero, owl.num, owl.num)
], Host$2, "Discriminant", 1);
__decorateClass$2([
  checkIt(owl.nonZero, owl.num, owl.num),
  inspectIt(function has_real_root(a2, b2, c2) {
    return b2 ** 2 - 4 * a2 * c2 >= 0;
  })
], Host$2, "QuadraticRoot", 1);
__decorateClass$2([
  checkIt(owl.nonZero, owl.num, owl.num)
], Host$2, "QuadraticVertex", 1);
__decorateClass$2([
  checkIt(owl.nonZero, owl.num, owl.num)
], Host$2, "QuadraticFromRoot", 1);
__decorateClass$2([
  checkIt(owl.nonZero, owl.num, owl.num)
], Host$2, "QuadraticFromVertex", 1);
Host$2 = __decorateClass$2([
  exposeAll(),
  captureAll()
], Host$2);
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp$1(target, key, result2);
  return result2;
};
let Host$1 = class {
  static LineFeat(a2, b2, c2) {
    let x2 = -c2 / a2;
    let y2 = -c2 / b2;
    let m2 = -a2 / b2;
    return [m2, y2, x2];
  }
  static LinearFromIntercepts(xInt, yInt) {
    return lin().byIntercepts(xInt, yInt).toLinear();
  }
  static LinearFromTwoPoints(point1, point2) {
    return lin().byTwoPoints(point1, point2).toLinear();
  }
  static LinearFromPointSlope(point, slope2) {
    return lin().byPointSlope(point, slope2).toLinear();
  }
  static LinearFromBisector(A2, B2) {
    return lin().byBisector(A2, B2).toLinear();
  }
  static LineFromIntercepts(xInt, yInt) {
    return lin().byIntercepts(xInt, yInt).toLine();
  }
  static LineFromTwoPoints(point1, point2) {
    return lin().byTwoPoints(point1, point2).toLine();
  }
  static LineFromPointSlope(point, slope2) {
    return lin().byPointSlope(point, slope2).toLine();
  }
  static LineFromBisector(A2, B2) {
    return lin().byBisector(A2, B2).toLine();
  }
};
__decorateClass$1([
  checkIt(owl.nonZero, owl.nonZero, owl.num)
], Host$1, "LineFeat", 1);
__decorateClass$1([
  checkIt(owl.nonZero, owl.nonZero)
], Host$1, "LinearFromIntercepts", 1);
__decorateClass$1([
  checkIt(owl.point2D, owl.point2D),
  inspectIt(function different_points(p1, p2) {
    return owl.distinct([p1, p2]);
  })
], Host$1, "LinearFromTwoPoints", 1);
__decorateClass$1([
  checkIt(owl.point2D, owl.num)
], Host$1, "LinearFromPointSlope", 1);
__decorateClass$1([
  checkIt(owl.point2D, owl.point2D),
  inspectIt(function different_points2(p1, p2) {
    return owl.distinct([p1, p2]);
  })
], Host$1, "LinearFromBisector", 1);
__decorateClass$1([
  checkIt(owl.nonZero, owl.nonZero)
], Host$1, "LineFromIntercepts", 1);
__decorateClass$1([
  checkIt(owl.point2D, owl.point2D),
  inspectIt(function different_points3(p1, p2) {
    return owl.distinct([p1, p2]);
  }),
  inspectIt(function non_vertical(p1, p2) {
    return p1[0] !== p2[0];
  })
], Host$1, "LineFromTwoPoints", 1);
__decorateClass$1([
  checkIt(owl.point2D, owl.num)
], Host$1, "LineFromPointSlope", 1);
__decorateClass$1([
  checkIt(owl.point2D, owl.point2D),
  inspectIt(function different_points4(p1, p2) {
    return owl.distinct([p1, p2]);
  }),
  inspectIt(function non_horizontal(p1, p2) {
    return p1[1] !== p2[1];
  })
], Host$1, "LineFromBisector", 1);
Host$1 = __decorateClass$1([
  exposeAll(),
  captureAll()
], Host$1);
class MonomialCls {
  constructor(coeff = 0, vars = []) {
    this.coeff = coeff;
    this.vars = vars;
  }
  clone() {
    let coeff = this.coeff;
    let vars = JSON.parse(JSON.stringify(this.vars));
    return new MonomialCls(coeff, vars);
  }
  random(degree, variables, maxCoeff) {
    let f2 = () => {
      let M2 = new MonomialCls();
      M2.coeff = RndZ(1, maxCoeff);
      for (let v2 of variables) {
        if (variables.length === 1) {
          M2.vars.push({ variable: v2, power: degree });
        } else {
          M2.vars.push({ variable: v2, power: RndN(0, degree) });
        }
      }
      return M2;
    };
    let mon = dice(f2).shield((M2) => M2.degree() === degree).roll();
    this.coeff = mon.coeff;
    this.vars = mon.vars;
  }
  degree() {
    return Sum(...this.vars.map((_) => _.power));
  }
  sortedVars() {
    return SortBy([...this.vars], (_) => _.variable.charCodeAt(0));
  }
  size() {
    let s2 = this.degree();
    let order = 1;
    for (let { variable, power } of this.sortedVars()) {
      order = order / 10;
      s2 += order * power;
    }
    return s2;
  }
  signature() {
    return JSON.stringify(this.sortedVars());
  }
  sort() {
    this.vars = this.sortedVars();
  }
  print() {
    let term = String(this.coeff);
    if (this.coeff === 0)
      return term;
    for (let v2 of this.vars) {
      let l2 = v2.variable;
      let p2 = v2.power;
      if (p2 === 0) {
        continue;
      } else if (p2 === 1) {
        term += l2;
      } else {
        term += l2 + "^{" + p2 + "}";
      }
    }
    return term;
  }
  func() {
    return (input) => {
      let x2 = this.coeff;
      for (let { variable, power } of this.vars) {
        x2 = x2 * input[variable] ** power;
      }
      return x2;
    };
  }
}
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2)
    __defProp(target, key, result2);
  return result2;
};
let Host = class {
  static Monomial(coeff, vars) {
    return new MonomialCls(coeff, vars);
  }
  static PolyClone(poly) {
    return poly.map((M2) => M2.clone());
  }
  static RndPolynomial(degree, vars = ["x"], terms = degree + 1, maxCoeff = 9) {
    let RndMono = () => {
      let M2 = new MonomialCls();
      M2.random(RndN(0, degree), vars, maxCoeff);
      return M2;
    };
    let f2 = () => dice(RndMono).unique((M2) => M2.size()).rolls(terms);
    return dice(f2).shield((P2) => Max(...P2.map((M2) => M2.degree())) === degree).roll();
  }
  static PolyPrint(poly) {
    return poly.map((M2) => M2.print()).filter((x2) => x2 !== "0").join("+");
  }
  static PolySort(poly, desc = true) {
    poly = PolyClone(poly);
    let arr = SortBy(poly, (M2) => desc ? -M2.size() : M2.size());
    return arr;
  }
  static PolyFunction(poly) {
    poly = PolyClone(poly);
    return (values) => {
      return Sum(...poly.map((M2) => M2.func()(values)));
    };
  }
  static PolyJoin(...polys) {
    polys = polys.map((p2) => PolyClone(p2));
    let arr = [];
    for (let p2 of polys)
      arr.push(...p2);
    return arr;
  }
  static PolySimplify(poly) {
    poly = PolyClone(poly);
    let arr = [];
    function findLikeTerm(M2) {
      return arr.find((m2) => m2.signature() === M2.signature());
    }
    for (let M2 of poly) {
      let like = findLikeTerm(M2);
      if (like) {
        like.coeff += M2.coeff;
      } else {
        arr.push(M2);
      }
    }
    return arr.filter((m2) => m2.coeff !== 0);
  }
  static PolyDegree(poly) {
    return Max(...poly.map((M2) => M2.degree()));
  }
};
__decorateClass([
  checkIt(owl.num, owl.array)
], Host, "Monomial", 1);
__decorateClass([
  checkIt(owl.polynomial)
], Host, "PolyClone", 1);
__decorateClass([
  checkIt(owl.positiveInt, owl.arrayWith(owl.str), owl.positiveInt, owl.num)
], Host, "RndPolynomial", 1);
__decorateClass([
  checkIt(owl.polynomial)
], Host, "PolyPrint", 1);
__decorateClass([
  checkIt(owl.polynomial, owl.bool)
], Host, "PolySort", 1);
__decorateClass([
  checkIt(owl.polynomial)
], Host, "PolyFunction", 1);
__decorateClass([
  checkIt(owl.polynomial)
], Host, "PolyJoin", 1);
__decorateClass([
  checkIt(owl.polynomial)
], Host, "PolySimplify", 1);
__decorateClass([
  checkIt(owl.polynomial)
], Host, "PolyDegree", 1);
Host = __decorateClass([
  exposeAll(),
  captureAll()
], Host);
class CustomErrorCls extends Error {
  constructor(name, message) {
    super(message);
    this.name = name;
  }
}
function CustomError$1(name, message) {
  return new CustomErrorCls(name, message);
}
globalThis.CustomError = CustomError$1;
function toError$1(e2) {
  if (e2 instanceof Error) {
    return e2;
  } else if (typeof e2 === "string") {
    return CustomError$1("UnknownError", e2);
  } else {
    return CustomError$1("UnknownError", JSON.stringify(e2));
  }
}
globalThis.toError = toError$1;
function MathError$1(message) {
  return new CustomErrorCls("MathError", message);
}
globalThis.MathError = MathError$1;
function Should$1(condition, msg = "Should condition failed!") {
  if (!condition) {
    let caller = new Error().stack.split("\n")[2].trim().split(" ")[1];
    caller = caller != null ? caller : "Anonymous ";
    throw MathError$1(caller + ": " + msg);
  }
}
globalThis.Should = Should$1;
function latexAligned(texts) {
  let T2 = "";
  T2 += "\\begin{aligned}";
  for (let t2 of texts)
    T2 += t2 + " \\\\ ";
  T2 += " \\end{aligned}";
  T2 = T2.replaceAll("=", "&=");
  T2 = T2.replaceAll("&&=", "&=");
  return T2;
}
function latexBraced(texts) {
  return "\\left\\{" + latexAligned(texts) + "\\right.";
}
class Equation {
  constructor(zeroFunc, latex, dep) {
    this.zeroFunc = zeroFunc;
    this.latex = latex;
    this.dep = dep;
  }
  print(showVars = []) {
    return this.dep.write(this.latex, showVars);
  }
}
const DEFAULT_UNIT = {
  "illuminance": "lx",
  "luminous flux": "lm",
  "overall thermal transfer value": "W m-2",
  "thermal conductivity": "W m-1  K-1",
  "thermal Transmittance": "W m-2 K-1",
  "cooling capacity": "W",
  "rate of conduction": "W",
  "effciency": "\\%",
  "angular speed": "rad s-1",
  "angular displacement": "rad",
  "time": "s",
  "distance": "m",
  "displacement": "m",
  "separation": "m",
  "speed": "m s-1",
  "velocity": "m s-1",
  "acceleration": "m s-2",
  "deceleration": "m s-2",
  "area": "m2",
  "volume": "m3",
  "height": "m",
  "radius": "m",
  "diameter": "m",
  "length": "m",
  "width": "m",
  "wavelength": "m",
  "capacitiy": "m3",
  "angle": "\xB0",
  "energy": "J",
  "molar mass": "kg mol-1",
  "mass": "kg",
  "electromotive force": "V",
  "specific heat capacity": "J kg-1 \xB0C-1",
  "heat capacity": "J \xB0C-1",
  "temperature": "\xB0C",
  "latent heat": "J kg-1",
  "pressure": "Pa",
  "number of molecule": "",
  "number of mole": "mol",
  "force": "N",
  "weight": "N",
  "tension": "N",
  "normal reaction": "N",
  "friction": "N",
  "moment": "N m",
  "power": "W",
  "gravitational field strength": "N kg-1",
  "angular position": "\xB0",
  "period": "s",
  "frequency": "Hz",
  "amplitude": "m",
  "charge": "C",
  "current": "A",
  "voltage": "V",
  "resistance": "\u03A9",
  "electric field strength": "N C-1",
  "potential difference": "V",
  "resistivity": "\u03A9 m",
  "emf": "V",
  "e.m.f.": "V",
  "magnetic field": "B",
  "magnetic flux": "Wb",
  "activity": "Bq",
  "half-life": "s",
  "decay constant": "s-1",
  "density": "kg m-3",
  "KE": "J",
  "PE": "J"
};
const BASE_UNITS = [
  "rad",
  "mol",
  "Wb",
  "Bq",
  "eV",
  "\xB0C",
  "Pa",
  "s",
  "m",
  "g",
  "A",
  "K",
  "J",
  "N",
  "W",
  "C",
  "V",
  "T",
  "u",
  "\u03A9"
];
const BASE_PREFIX = ["n", "u", "m", "c", "k", "M", "G", "T", ""];
const BASE_INDEX = ["-4", "-3", "-2", "-1", "1", "2", "3", "4"];
function findUnit(name) {
  for (let k2 in DEFAULT_UNIT) {
    if (name.includes(k2))
      return DEFAULT_UNIT[k2];
  }
  return void 0;
}
function parseUnit(raw) {
  let T2 = " " + raw + " ";
  for (let u2 of BASE_UNITS) {
    if (!T2.includes(u2))
      continue;
    for (let p2 of BASE_PREFIX) {
      T2 = T2.replaceAll(new RegExp("([^a-zA-z\xB0])" + p2 + u2 + "([^a-zA-z\xB0])", "g"), "$1~\\text{" + p2 + u2 + "}$2");
    }
  }
  for (let i2 of BASE_INDEX)
    T2 = T2.replaceAll(new RegExp("([^0123456789-])" + i2 + "([^0123456789-])", "g"), "$1^{" + i2 + "}$2");
  return T2;
}
function parseRange(rng) {
  if (Array.isArray(rng)) {
    return rng.length === 2 ? rng : [rng[0], rng[0]];
  } else {
    return rng > 0 ? [rng / 10, rng * 10] : [rng * 10, rng / 10];
  }
}
class Variable {
  constructor(sym, name, range2, unit, display) {
    this.sym = sym;
    this.name = name;
    this.val = NaN;
    this.subscript = "";
    unit != null ? unit : unit = findUnit(name);
    unit != null ? unit : unit = "";
    this.unit = parseUnit(unit);
    this.range = parseRange(range2);
    let [min2, max2] = this.range;
    if (min2 > max2)
      throw "[Variable] Range must have max > min";
    this.display = display != null ? display : this.sym;
  }
  set(val) {
    this.val = val;
  }
  round(sigfig2 = 2) {
    this.set(Round(this.val, sigfig2));
  }
  shake() {
    let ratio = RndT() ? 1.05 : 0.95;
    this.set(this.val * ratio);
  }
  clear() {
    this.set(NaN);
  }
  getVal() {
    return this.val;
  }
  widen(fraction2 = 0.1) {
    let [min2, max2] = this.range;
    this.range = [
      min2 - Math.abs(min2 * fraction2),
      max2 + Math.abs(max2 * fraction2)
    ];
  }
  label(subscript = "") {
    this.subscript = String(subscript);
  }
  symbol() {
    if (this.subscript.length > 0)
      return this.display + "_{" + this.subscript + "}";
    return this.display;
  }
  short() {
    let v2 = cal.blur(Round(this.val, 3));
    let abs2 = Math.abs(v2);
    return String(abs2 >= 1e4 || abs2 <= 0.01 ? Sci(v2) : v2);
  }
  long() {
    return this.short() + this.unit;
  }
  full() {
    return this.symbol() + " = " + this.long();
  }
  whole() {
    return "\\text{" + this.name + "} = " + this.long();
  }
  rich() {
    return "\\text{" + this.name + "}~" + this.symbol() + " = " + this.long();
  }
  writeSymbol(latex) {
    let T2 = latex;
    let sym = this.sym;
    let s2 = this.symbol();
    T2 = T2.replaceAll("*(" + sym + ")", s2);
    T2 = T2.replaceAll("*" + sym, s2);
    T2 = T2.replaceAll("$(" + sym + ")", s2);
    T2 = T2.replaceAll("$" + sym, s2);
    return T2;
  }
  writeValue(latex) {
    let T2 = latex;
    let sym = this.sym;
    let S2 = this.short();
    let L2 = this.long();
    T2 = T2.replaceAll("*(" + sym + ")", "(" + S2 + ")");
    T2 = T2.replaceAll("*" + sym, S2);
    T2 = T2.replaceAll("$(" + sym + ")", "(" + L2 + ")");
    T2 = T2.replaceAll("$" + sym, L2);
    return T2;
  }
}
class Variables extends Array {
  clear() {
    this.forEach(($) => $.clear());
  }
  widen() {
    this.forEach(($) => $.widen());
  }
  getVals() {
    return this.map(($) => $.getVal());
  }
  setVal(obj) {
    for (let k2 in obj) {
      let val = obj[k2];
      let variable = this.find(($) => $.sym === k2);
      variable.set(val);
    }
  }
  write(latex, showVars) {
    let T2 = latex;
    let shows = [...showVars];
    shows.sort((a2, b2) => b2.sym.length - a2.sym.length);
    for (let v2 of this) {
      T2 = showVars.includes(v2) ? v2.writeValue(T2) : v2.writeSymbol(T2);
    }
    return T2;
  }
  compareWith(oldVals) {
    this.forEach((v2, i2) => {
      let b2 = v2.getVal();
      let a2 = oldVals[i2];
      let mid2 = (Math.abs(a2) + Math.abs(b2)) / 2;
      let percent = (b2 - a2) / mid2;
      let THRESHOLD = 1e-7;
      let sign2 = 0;
      if (percent > THRESHOLD)
        sign2 = 1;
      if (percent < -THRESHOLD)
        sign2 = -1;
      v2.set(sign2);
    });
  }
  rangeObj() {
    let obj = {};
    for (let v2 of this) {
      obj[v2.sym] = v2.range;
    }
    return obj;
  }
  valObj() {
    let obj = {};
    for (let v2 of this) {
      obj[v2.sym] = v2.getVal();
    }
    return obj;
  }
}
function getVars(func) {
  const fnStr = func.toString();
  return fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).replaceAll(" ", "").split(",");
}
function getAllVars(fs) {
  const vars = fs.map(($) => getVars($)).flat();
  return [...new Set(vars)];
}
function permute(arr) {
  let result2 = [];
  if (arr.length === 0)
    return [];
  if (arr.length === 1)
    return [arr];
  for (let i2 = 0; i2 < arr.length; i2++) {
    const current = arr[i2];
    const remaining = [...arr.slice(0, i2), ...arr.slice(i2 + 1)];
    const remainingPermuted = permute(remaining);
    for (let permuted of remainingPermuted) {
      result2.push([current, ...permuted]);
    }
  }
  return result2;
}
function combinations(arr, k2) {
  if (k2 > arr.length || k2 <= 0)
    return [];
  if (k2 === arr.length)
    return [[...arr]];
  if (k2 === 1)
    return arr.map(($) => [$]);
  const combs = [];
  let tail_combs = [];
  for (let i2 = 0; i2 <= arr.length - k2 + 1; i2++) {
    let tail = arr.slice(i2 + 1);
    tail_combs = combinations(tail, k2 - 1);
    for (let j2 = 0; j2 < tail_combs.length; j2++) {
      combs.push([arr[i2], ...tail_combs[j2]]);
    }
  }
  return combs;
}
function randomUniform(range2) {
  const [min2, max2] = range2;
  return Math.random() * (max2 - min2) + min2;
}
function randomLog(range2) {
  const [min2, max2] = range2;
  const logmin = Math.log10(min2);
  const logmax = Math.log10(max2);
  const e2 = randomUniform([logmin, logmax]);
  return 10 ** e2;
}
function randomLogNeg(range2) {
  const [minNeg, maxNeg] = range2;
  const min2 = -maxNeg;
  const max2 = -minNeg;
  return -randomLog([min2, max2]);
}
function randomValue(range2) {
  let [min2, max2] = range2;
  if (min2 > 0 && max2 > 0)
    return randomLog(range2);
  if (min2 < 0 && max2 < 0)
    return randomLogNeg(range2);
  return randomUniform(range2);
}
function mid$3(a2, b2) {
  return a2.map(($, i2) => ($ + b2[i2]) / 2);
}
function equal(a2, b2) {
  return a2.every(($, i2) => $ === b2[i2]) && a2.length === b2.length;
}
class Bisection {
  constructor(equation, ranges) {
    this.equation = equation;
    this.ranges = ranges;
    this.a = [];
    this.b = [];
    this.precision = 10;
  }
  randomPoint() {
    return this.ranges.map(randomValue);
  }
  randomSignedPoint(sign2) {
    for (let i2 = 0; i2 < 100; i2++) {
      const point = this.randomPoint();
      const value = this.equation(...point);
      const sameSign = value * sign2 > 0;
      if (sameSign)
        return point;
    }
    console.error("[bisection] No signed point in ranges: " + JSON.stringify(this.ranges));
    throw "";
  }
  intialize() {
    this.a = this.randomSignedPoint(1);
    this.b = this.randomSignedPoint(-1);
  }
  iterate() {
    const m2 = mid$3(this.a, this.b);
    const M2 = this.equation(...m2);
    if (!Number.isFinite(M2)) {
      console.error("[bisection] The function value is not a finite number!");
      throw "";
    }
    if (M2 >= 0)
      this.a = m2;
    if (M2 <= 0)
      this.b = m2;
  }
  done() {
    const precision_a = this.a.map(($) => $.toPrecision(this.precision));
    const precision_b = this.b.map(($) => $.toPrecision(this.precision));
    return equal(precision_a, precision_b);
  }
  assertRange() {
    const pass2 = this.ranges.some(([min2, max2]) => max2 > min2);
    if (!pass2) {
      console.error("[bisection] all variables are locked already");
      throw "";
    }
  }
  run() {
    this.assertRange();
    this.intialize();
    for (let i2 = 0; i2 < 100; i2++) {
      this.iterate();
      if (this.done())
        return [...this.a];
    }
    console.error("[bisection] fail to find tolarable solution after 100 iteration");
    throw "";
  }
  exec() {
    try {
      return this.run();
    } catch {
      throw "[bisection] An error occur during bisection.";
    }
  }
}
function toObject(keys, vals) {
  const obj = {};
  for (let i2 = 0; i2 < keys.length; i2++) {
    obj[keys[i2]] = vals[i2];
  }
  return obj;
}
function narrowRange(ranges, preset) {
  const rngs = __spreadValues({}, ranges);
  for (let k2 in preset) {
    const val = preset[k2];
    if (k2 in rngs && Number.isFinite(val))
      rngs[k2] = [val, val];
  }
  return rngs;
}
function bisect(f2, ranges, preset) {
  const vars = getVars(f2);
  const narrowedRngs = narrowRange(ranges, preset);
  const bounds = vars.map(($) => narrowedRngs[$]);
  const bi = new Bisection(f2, bounds);
  const sol = bi.exec();
  return toObject(vars, sol);
}
class Searcher {
  constructor(fs, givens = []) {
    this.fs = fs;
    this.givens = givens;
    this.founds = new Set();
  }
  reset() {
    this.founds = new Set(this.givens);
  }
  isFull(f2) {
    return getVars(f2).every(($) => this.founds.has($));
  }
  fit(f2) {
    getVars(f2).forEach(($) => this.founds.add($));
  }
  isFittableOrder(fs) {
    this.reset();
    for (let f2 of fs) {
      if (this.isFull(f2))
        return false;
      this.fit(f2);
    }
    return true;
  }
  getFittableOrder() {
    for (let fs of permute(this.fs)) {
      if (this.isFittableOrder(fs))
        return fs;
    }
    return void 0;
  }
}
function getFittableOrder(fs, preset) {
  const givens = [];
  for (let k2 in preset) {
    let v2 = preset[k2];
    if (Number.isFinite(v2))
      givens.push(k2);
  }
  const sr = new Searcher(fs, givens);
  return sr.getFittableOrder();
}
class Fitter {
  constructor(fs, ranges, preset) {
    this.fs = fs;
    this.ranges = ranges;
    this.preset = preset;
    this.vals = {};
    this.allVariables = getAllVars(fs);
    this.reset();
  }
  reset() {
    this.vals = {};
    this.allVariables.forEach(($) => this.vals[$] = NaN);
    this.setVals(this.preset);
  }
  setVals(vals) {
    this.vals = __spreadValues(__spreadValues({}, this.vals), vals);
  }
  fitOne(f2) {
    const sol = bisect(f2, this.ranges, this.vals);
    this.setVals(sol);
  }
  fit() {
    const orderedFS = getFittableOrder(this.fs, this.preset);
    if (orderedFS === void 0)
      throw "There is no fittable order for this system.";
    for (let i2 = 0; i2 < 10; i2++) {
      try {
        this.reset();
        orderedFS.forEach(($) => this.fitOne($));
        return this.vals;
      } catch {
      }
    }
    throw "The system is not fittable in given range.";
  }
}
function fit(fs, ranges, preset) {
  let fitter = new Fitter(fs, ranges, preset);
  return fitter.fit();
}
class Vabe {
  constructor(symbol) {
    this.symbol = symbol;
    this.order = NaN;
  }
  reset() {
    this.order = NaN;
  }
  setZero() {
    this.order = 0;
  }
  solve(order) {
    this.order = order;
  }
  solved() {
    return Number.isFinite(this.order);
  }
}
class Eqube {
  constructor(vabes) {
    this.vabes = vabes;
  }
  unsolvedVabes() {
    return this.vabes.filter(($) => !$.solved());
  }
  solved() {
    return this.unsolvedVabes().length === 0;
  }
  solvable() {
    return this.unsolvedVabes().length === 1;
  }
  orders() {
    return this.vabes.map(($) => $.order);
  }
  realOrders() {
    return this.orders().filter(($) => Number.isFinite($));
  }
  maxOrder() {
    const orders = this.realOrders();
    if (orders.length === 0)
      return -1;
    return Math.max(...orders);
  }
  nextOrder() {
    return this.maxOrder() + 1;
  }
  forceSolve() {
    let nextOrder = this.nextOrder();
    for (let v2 of this.unsolvedVabes()) {
      v2.solve(nextOrder);
    }
  }
  trySolve() {
    if (this.solvable()) {
      this.forceSolve();
      return true;
    } else {
      return false;
    }
  }
}
class PresetAnalyzer {
  constructor(vabes, equbes, preset) {
    this.vabes = vabes;
    this.equbes = equbes;
    this.preset = preset;
  }
  reset() {
    for (let v2 of this.vabes) {
      const isPreset = this.preset.includes(v2);
      isPreset ? v2.setZero() : v2.reset();
    }
  }
  trySolveNext() {
    for (let eq2 of this.equbes) {
      const t2 = eq2.trySolve();
      if (t2 === true)
        return true;
    }
    return false;
  }
  exportOrder() {
    const orders = {};
    for (let v2 of this.vabes) {
      orders[v2.symbol] = v2.order;
    }
    return orders;
  }
  getTree() {
    this.reset();
    for (let i2 = 0; i2 <= this.equbes.length; i2++) {
      const t2 = this.trySolveNext();
      if (!t2)
        break;
    }
    return this.exportOrder();
  }
}
class Analyzer {
  constructor(vabes, equbes) {
    this.vabes = vabes;
    this.equbes = equbes;
  }
  allVabeCombinations() {
    const n2 = this.vabes.length - this.equbes.length;
    return combinations(this.vabes, n2);
  }
  getTrees() {
    const combs = this.allVabeCombinations();
    const ts = [];
    for (let c2 of combs) {
      const ana = new PresetAnalyzer(this.vabes, this.equbes, c2);
      ts.push(ana.getTree());
    }
    return ts;
  }
  isHealthy(tree) {
    const orders = Object.values(tree);
    return orders.every(($) => Number.isFinite($));
  }
  getHealthyTrees() {
    return this.getTrees().filter(($) => this.isHealthy($));
  }
}
function analyze(fs) {
  const symbols2 = getAllVars(fs);
  const vabes = symbols2.map(($) => new Vabe($));
  const equbes = [];
  for (let f2 of fs) {
    let syms = getVars(f2);
    const vs = syms.map(($) => vabes.find((_) => _.symbol === $));
    let eq2 = new Eqube(vs);
    equbes.push(eq2);
  }
  let analyzer = new Analyzer(vabes, equbes);
  return analyzer.getHealthyTrees();
}
class TreeReader {
  constructor(tree) {
    this.tree = tree;
    this.symbols = Object.keys(tree);
    this.orders = Object.values(this.tree);
    this.realOrders = this.orders.filter(($) => Number.isFinite($));
    this.maxOrder = Math.max(...this.realOrders);
  }
  symbolsWithOrder(order) {
    return this.symbols.filter(($) => this.tree[$] === order);
  }
  givenSymbols() {
    return this.symbolsWithOrder(0);
  }
  topSymbols() {
    return this.symbolsWithOrder(this.maxOrder);
  }
  stepSymbols() {
    const arr = [];
    for (let i2 = 1; i2 < this.maxOrder; i2++) {
      arr.push(...this.symbolsWithOrder(i2));
    }
    return arr;
  }
  solvedSymbols() {
    return [...this.stepSymbols(), ...this.topSymbols()];
  }
}
class EquationReader {
  constructor(f2, tree) {
    this.f = f2;
    this.tree = tree;
    this.myTree = {};
    this.symbols = getVars(f2);
    for (let k2 in tree) {
      if (this.symbols.includes(k2))
        this.myTree[k2] = tree[k2];
    }
    this.reader = new TreeReader(this.myTree);
  }
  isActiveSolve() {
    const m2 = this.maxOrder();
    return m2 !== 0 && this.symbolsWithOrder(m2).length === 1;
  }
  maxOrder() {
    return this.reader.maxOrder;
  }
  symbolsWithOrder(order) {
    return this.symbols.filter(($) => this.tree[$] === order);
  }
  solvingSymbol() {
    if (!this.isActiveSolve())
      return void 0;
    return this.reader.topSymbols()[0];
  }
  givenSymbols() {
    return this.reader.givenSymbols();
  }
  stepSymbols() {
    return this.reader.stepSymbols();
  }
}
class Tracer {
  constructor(tree, eqReaders) {
    this.tree = tree;
    this.eqReaders = eqReaders;
    this.symbols = Object.keys(this.tree);
  }
  revealer(symbol) {
    for (let eq2 of this.eqReaders) {
      if (eq2.solvingSymbol() === symbol)
        return eq2;
    }
    return void 0;
  }
  prerequisites(symbol) {
    var _a, _b;
    return (_b = (_a = this.revealer(symbol)) == null ? void 0 : _a.stepSymbols()) != null ? _b : [];
  }
  flowForOne(symbol) {
    const order = this.tree[symbol];
    if (order === 0)
      return [];
    if (order === 1)
      return [this.revealer(symbol)];
    let eqs = [];
    for (let s2 of this.prerequisites(symbol)) {
      eqs.push(...this.flowForOne(s2));
    }
    eqs.push(this.revealer(symbol));
    return [...new Set(eqs)];
  }
  flow(unknowns) {
    let eqs = [];
    for (let u2 of unknowns) {
      eqs.push(...this.flowForOne(u2));
    }
    return [...new Set(eqs)];
  }
}
function solutionFlow(fs, tree, unknownSymbols) {
  const eqReaders = fs.map(($) => new EquationReader($, tree));
  const tracer = new Tracer(tree, eqReaders);
  let flow = tracer.flow(unknownSymbols);
  return flow.map(($) => $.f);
}
function solvingSymbol(f2, tree) {
  const eqReader = new EquationReader(f2, tree);
  return eqReader.solvingSymbol();
}
function readTree(tree) {
  const reader = new TreeReader(tree);
  return {
    maxOrder: reader.maxOrder,
    givens: reader.givenSymbols(),
    tops: reader.topSymbols(),
    steps: reader.stepSymbols(),
    solved: reader.solvedSymbols()
  };
}
class EquSystem {
  constructor(variables, equations) {
    this.variables = variables;
    this.equations = equations;
    this.tree = {};
    this.fs = equations.map(($) => $.zeroFunc);
  }
  fit() {
    let vals = fit(this.fs, this.variables.rangeObj(), this.variables.valObj());
    this.variables.setVal(vals);
  }
  fitAgain(vars) {
    vars.forEach(($) => $.clear());
    vars.forEach(($) => $.widen());
    this.fit();
  }
  getVariables(symbols2) {
    const vars = symbols2.map(($) => this.variables.find((_) => _.sym === $));
    return new Variables(...vars);
  }
  getFullTree(avoids = []) {
    let trees = RndShuffle(...analyze(this.fs));
    for (let tree of trees) {
      let info = readTree(tree);
      for (let top of RndShuffle(...info.tops)) {
        let flow = solutionFlow(this.fs, tree, [top]);
        if (flow.length === this.fs.length && this.checkAvoids(info.givens, top, avoids))
          this.tree = tree;
        return {
          tree,
          top: this.getVariables([top])[0],
          info
        };
      }
    }
    throw "no sensible set of solvables found!";
  }
  checkAvoid(givens, unknown, avoid) {
    let allAreGivensOrUnknown = avoid.every(($) => givens.includes($) || unknown === $);
    let containUnknown = avoid.includes(unknown);
    let immediatelySolved = allAreGivensOrUnknown && containUnknown;
    return !immediatelySolved;
  }
  checkAvoids(givens, unknown, avoids) {
    return avoids.every(($) => this.checkAvoid(givens, unknown, $));
  }
  generateSolvables(avoids = []) {
    let { tree, top, info } = this.getFullTree(avoids);
    return [
      this.getVariables(info.givens),
      this.getVariables(info.solved),
      top
    ];
  }
  solInSteps(unknown) {
    let fs = solutionFlow(this.fs, this.tree, [unknown.sym]);
    let eqs = fs.map(($) => this.equations.find((_) => _.zeroFunc === $));
    let info = readTree(this.tree);
    let givens = info.givens.map(($) => this.variables.find((_) => _.sym === $));
    let T2 = "";
    for (let eq2 of eqs) {
      let solved = solvingSymbol(eq2.zeroFunc, this.tree);
      let solvedVar = this.variables.find(($) => $.sym === solved);
      T2 += latexAligned([eq2.print(), eq2.print(givens), solvedVar.full()]);
      T2 += " \\\\~\\\\ ";
      givens.push(solvedVar);
    }
    return T2;
  }
  generateTrend() {
    let { tree, top, info } = this.getFullTree();
    let [agent, ...constants] = RndShuffle(...this.getVariables(info.givens));
    let responses = [...this.getVariables(info.solved)];
    responses = RndShuffle(...responses);
    let target = top;
    this.variables.clear();
    this.fit();
    let oldVal = this.variables.getVals();
    agent.shake();
    this.fitAgain(responses);
    this.variables.compareWith(oldVal);
    return [constants, agent, responses, target];
  }
  print(givens = []) {
    let eqs = this.equations.map(($) => $.dep.write($.latex, givens));
    return eqs.length === 1 ? eqs[0] : latexBraced(eqs);
  }
}
function getSignature(func) {
  const fnStr = func.toString();
  return fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).replaceAll(" ", "").split(",");
}
function findVarBySym(sym, vars) {
  let v2 = vars.find((v22) => v22.sym === sym);
  if (v2 === void 0)
    throw "Fail to find variable: " + sym;
  return v2;
}
function getDeps(func, vars) {
  let dep = getSignature(func);
  let vs = dep.map(($) => findVarBySym($, vars));
  return new Variables(...vs);
}
function toVariable(variable) {
  let [sym, name, range2, unit, display] = variable;
  return new Variable(sym, name, range2, unit, display);
}
function toVariables(vars) {
  let vs = vars.map(($) => toVariable($));
  return new Variables(...vs);
}
function toEquation(eq2, vars) {
  let [func, latex] = eq2;
  return new Equation(func, latex, getDeps(func, vars));
}
function toEquations(eqs, vars) {
  return eqs.map(($) => toEquation($, vars));
}
function toEquSystem(variables, equations) {
  let vars = toVariables(variables);
  let eqs = toEquations(equations, vars);
  return new EquSystem(vars, eqs);
}
function BuildSolve(variables, equations, {
  listSym = false,
  avoids = [],
  sigfig: sigfig2 = {}
} = {}) {
  for (let i2 = 0; i2 <= 10; i2++) {
    try {
      return BuildSolveOnce$1(variables, equations, { listSym, avoids, sigfig: sigfig2 });
    } catch (e2) {
      if (i2 === 10) {
        throw e2;
      } else {
        continue;
      }
    }
  }
  throw "never";
}
function BuildSolveOnce$1(variables, equations, {
  listSym = false,
  avoids = [],
  sigfig: sigfig2 = {}
} = {}) {
  let system = toEquSystem(variables, equations);
  system.fit();
  let [givens, hiddens, unknown] = system.generateSolvables(avoids);
  givens.forEach(($) => $.round(sigfig2[$.sym]));
  system.fitAgain(hiddens);
  function sol() {
    if (equations.length === 1) {
      let eq2 = system.equations[0];
      return latexAligned([
        eq2.print(),
        eq2.print(givens),
        unknown.full()
      ]);
    } else {
      let T2 = "";
      T2 += system.print() + " \\\\~\\\\ ";
      T2 += system.print(givens) + " \\\\~\\\\ ";
      T2 += latexBraced(hiddens.map(($) => $.full()));
      return T2;
    }
  }
  return {
    list: givens.map(($) => listSym ? $.rich() : $.whole()).join("\\\\"),
    sol: sol(),
    vars: system.variables.map((v2) => givens.includes(v2) ? v2.long() : v2.symbol()),
    vals: system.variables.map(($) => $.getVal()),
    unknown: [
      unknown.symbol(),
      unknown.name,
      unknown.getVal(),
      unknown.unit
    ],
    ans: { val: unknown.getVal(), unit: unknown.unit }
  };
}
function BuildTrend(variables, equations, settings = {}) {
  let system = toEquSystem(variables, equations);
  let [constants, agent, responses, target] = system.generateTrend();
  function toWord(change) {
    var _a;
    let trendWords = (_a = settings.trends) != null ? _a : ["increases", "decreases", "is unchanged"];
    if (change > 0)
      return trendWords[0];
    if (change === 0)
      return trendWords[2];
    if (change < 0)
      return trendWords[1];
    return "[error]";
  }
  function toCode2(change) {
    if (change > 0)
      return 0;
    if (change === 0)
      return 2;
    if (change < 0)
      return 1;
    return 3;
  }
  return {
    consts: [
      constants.map((v2) => v2.symbol()),
      constants.map((v2) => v2.name)
    ],
    agent: [
      agent.symbol(),
      agent.name,
      toWord(agent.getVal()),
      toCode2(agent.getVal())
    ],
    responses: responses.map((v2) => [
      v2.symbol(),
      v2.name,
      toWord(v2.getVal()),
      toCode2(v2.getVal())
    ]),
    target: [
      target.symbol(),
      target.name,
      toWord(target.getVal()),
      toCode2(target.getVal())
    ],
    sol: system.print()
  };
}
function BuildRatio(variables, func, latex, {
  cases = ["Before", "After"],
  subscript = [1, 2],
  sigfig: sigfig2 = {}
} = {}) {
  let system = toEquSystem(variables, [[func, latex]]);
  let vars = system.variables;
  let [given, unknown, ...constants] = RndShuffle(...vars);
  let g2 = [];
  let u2 = [];
  system.fit();
  given.round(sigfig2[given.sym]);
  unknown.round(sigfig2[unknown.sym]);
  g2.push(given.getVal());
  u2.push(unknown.getVal());
  system.fitAgain(constants);
  for (let i2 = 0; i2 < 10; i2++) {
    system.fitAgain([given, unknown]);
    given.round(sigfig2[given.sym]);
    if (given.getVal() !== g2[0])
      break;
  }
  system.fitAgain([unknown]);
  g2.push(given.getVal());
  u2.push(unknown.getVal());
  function setSubscript(order) {
    if (order === 0) {
      given.label();
      unknown.label();
    }
    let subs = subscript;
    given.label(subs[order - 1]);
    unknown.label(subs[order - 1]);
  }
  function setVal(order) {
    if (order === 0)
      return;
    given.set(g2[order - 1]);
    unknown.set(u2[order - 1]);
  }
  function setCase(order) {
    setSubscript(order);
    setVal(order);
  }
  function printRatioFraction(case1Show = [], case2Show = []) {
    setCase(2);
    let [lhs2, rhs2] = system.print(case2Show).split("=");
    setCase(1);
    let [lhs1, rhs1] = system.print(case1Show).split("=");
    return `\\dfrac{${lhs1}}{${lhs2}}=\\dfrac{${rhs1}}{${rhs2}}`;
  }
  function printAns() {
    setCase(2);
    return unknown.full();
  }
  function sol() {
    return latexAligned([
      printRatioFraction(),
      printRatioFraction([given, unknown], [given]),
      printAns()
    ]);
  }
  function table() {
    setCase(1);
    let G1 = "$" + given.long();
    let U1 = "$" + unknown.long();
    setCase(2);
    let G2 = "$" + given.long();
    let U2 = "$" + unknown.symbol();
    let [case1, case2] = cases;
    setCase(0);
    return Table({
      content: [
        ["", "$" + given.symbol(), "$" + unknown.symbol()],
        [case1, G1, U1],
        [case2, G2, U2]
      ],
      columns: "c|c:c",
      rows: "r|r:r"
    });
  }
  function getUnknown() {
    setCase(2);
    return [unknown.symbol(), unknown.name, unknown.getVal(), unknown.unit];
  }
  function getAns() {
    setCase(2);
    return { val: unknown.getVal(), unit: unknown.unit };
  }
  return {
    table: table(),
    sol: sol(),
    consts: [
      constants.map((v2) => v2.symbol()),
      constants.map((v2) => v2.name)
    ],
    given: [
      given.symbol(),
      given.name
    ],
    unknown: getUnknown(),
    ans: getAns()
  };
}
function BuildSolve2(variables, equations, {
  listSym = false,
  avoids = [],
  sigfig: sigfig2 = {}
} = {}) {
  for (let i2 = 0; i2 <= 10; i2++) {
    try {
      return BuildSolveOnce(variables, equations, { listSym, avoids, sigfig: sigfig2 });
    } catch (e2) {
      if (i2 === 10) {
        throw e2;
      } else {
        continue;
      }
    }
  }
  throw "never";
}
function BuildSolveOnce(variables, equations, {
  listSym = false,
  avoids = [],
  sigfig: sigfig2 = {}
} = {}) {
  let system = toEquSystem(variables, equations);
  system.fit();
  let [givens, hiddens, unknown] = system.generateSolvables(avoids);
  givens.forEach(($) => $.round(sigfig2[$.sym]));
  system.fitAgain(hiddens);
  function sol() {
    if (equations.length === 1) {
      let eq2 = system.equations[0];
      return latexAligned([
        eq2.print(),
        eq2.print(givens),
        unknown.full()
      ]);
    } else {
      return system.solInSteps(unknown);
    }
  }
  return {
    list: givens.map(($) => listSym ? $.rich() : $.whole()).join("\\\\"),
    sol: sol(),
    vars: system.variables.map((v2) => givens.includes(v2) ? v2.long() : v2.symbol()),
    vals: system.variables.map(($) => $.getVal()),
    unknown: [
      unknown.symbol(),
      unknown.name,
      unknown.getVal(),
      unknown.unit
    ],
    ans: { val: unknown.getVal(), unit: unknown.unit }
  };
}
globalThis.BuildSolve = BuildSolve;
globalThis.BuildTrend = BuildTrend;
globalThis.BuildRatio = BuildRatio;
globalThis.BuildSolve2 = BuildSolve2;
function getAlpha(img, x2, y2) {
  let i2 = 0;
  i2 += y2 * img.width;
  i2 += x2;
  return img.data[4 * i2 + 3];
}
function isPainted(img, x2, y2) {
  return getAlpha(img, x2, y2) !== 0;
}
function rowBlank(img, y2) {
  for (let x2 = 0; x2 < img.width; x2++) {
    if (isPainted(img, x2, y2))
      return false;
  }
  return true;
}
function colBlank(img, x2) {
  for (let y2 = 0; y2 < img.height; y2++) {
    if (isPainted(img, x2, y2))
      return false;
  }
  return true;
}
function trimCanvasX(canvas) {
  let ctx = canvas.getContext("2d");
  let img = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let top = 0;
  let bottom = img.height - 1;
  while (top < bottom && rowBlank(img, top))
    top++;
  while (bottom > top && rowBlank(img, bottom))
    bottom--;
  let trimmed = ctx.getImageData(0, top, img.width, bottom - top + 1);
  canvas.width = trimmed.width;
  canvas.height = trimmed.height;
  ctx.putImageData(trimmed, 0, 0);
}
function trimCanvasY(canvas) {
  let ctx = canvas.getContext("2d");
  let img = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let left2 = 0;
  let right = img.width - 1;
  while (left2 < right && colBlank(img, left2))
    left2++;
  while (right > left2 && colBlank(img, right))
    right--;
  let trimmed = ctx.getImageData(left2, 0, right - left2 + 1, img.height);
  canvas.width = trimmed.width;
  canvas.height = trimmed.height;
  ctx.putImageData(trimmed, 0, 0);
}
function trimCanvas(canvas) {
  trimCanvasX(canvas);
  trimCanvasY(canvas);
}
const QUALITY = 3;
const INCH_SCALE = 10;
const REM_PIXEL$1 = parseFloat(getComputedStyle(document.documentElement).fontSize);
function inchToPx(inch) {
  return inch * INCH_SCALE * REM_PIXEL$1;
}
function pxToInch(px) {
  return px / INCH_SCALE / REM_PIXEL$1;
}
class Canvas00 {
  constructor() {
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.imgStore = null;
    this.backgroundURL = "";
  }
  reset() {
    this.ctx.scale(QUALITY, QUALITY);
    this.ctx.font = "normal 10px Times New Roman";
  }
  get width() {
    return this.canvas.width / QUALITY;
  }
  set width(value) {
    this.canvas.width = value * QUALITY;
    this.reset();
  }
  get height() {
    return this.canvas.height / QUALITY;
  }
  set height(value) {
    this.canvas.height = value * QUALITY;
    this.reset();
  }
  get widthInch() {
    return pxToInch(this.width);
  }
  set widthInch(value) {
    this.width = inchToPx(value);
  }
  get heightInch() {
    return pxToInch(this.height);
  }
  set heightInch(value) {
    this.height = inchToPx(value);
  }
  saveImg() {
    const w2 = this.canvas.width;
    const h2 = this.canvas.height;
    this.imgStore = this.ctx.getImageData(0, 0, w2, h2);
  }
  restoreImg() {
    if (this.imgStore !== null)
      this.ctx.putImageData(this.imgStore, 0, 0);
  }
  clearImg() {
    const w2 = this.canvas.width;
    const h2 = this.canvas.height;
    this.ctx.clearRect(0, 0, w2, h2);
  }
  export(html, placeholder, trim) {
    let cv = cloneCanvas(this.canvas);
    if (trim)
      trimCanvas(cv);
    const displayWidth = Math.floor(cv.width / QUALITY);
    const displayHeight = Math.floor(cv.height / QUALITY);
    const src = `src="${cv.toDataURL()}"`;
    const width = ` width="${displayWidth}"`;
    const height = ` height="${displayHeight}"`;
    const bg = this.backgroundURL.length === 0 ? "" : ` style="background-image:url('${this.backgroundURL}');background-size:100% 100%;" `;
    return html.replace('src="' + placeholder + '"', src + width + height + bg);
  }
}
function cloneCanvas(canvas) {
  let oldCanvas = canvas;
  let newCanvas = document.createElement("canvas");
  let context2 = newCanvas.getContext("2d");
  newCanvas.width = oldCanvas.width;
  newCanvas.height = oldCanvas.height;
  context2.drawImage(oldCanvas, 0, 0);
  return newCanvas;
}
function toPixelX(xmin, xmax, width, xCoord) {
  return (xCoord - xmin) / (xmax - xmin) * width;
}
function toPixelY(ymin, ymax, height, yCoord) {
  return height - (yCoord - ymin) / (ymax - ymin) * height;
}
class Canvas01 extends Canvas00 {
  constructor() {
    super(...arguments);
    this.xmin = 0;
    this.xmax = 0;
    this.ymin = 0;
    this.ymax = 0;
  }
  dx() {
    return this.xmax - this.xmin;
  }
  dy() {
    return this.ymax - this.ymin;
  }
  yxRatio() {
    return this.dy() / this.dx();
  }
  center() {
    let x2 = (this.xmin + this.xmax) / 2;
    let y2 = (this.ymin + this.ymax) / 2;
    return [x2, y2];
  }
  edgeTop(x2 = 0) {
    return [x2, this.ymax];
  }
  edgeBottom(x2 = 0) {
    return [x2, this.ymin];
  }
  edgeLeft(y2 = 0) {
    return [this.xmin, y2];
  }
  edgeRight(y2 = 0) {
    return [this.xmax, y2];
  }
  capturePoints2D(pts) {
    if (pts.length === 0)
      return;
    let [first, ...rest] = pts;
    let xmin = first[0];
    let xmax = first[0];
    let ymin = first[1];
    let ymax = first[1];
    for (let [x2, y2] of rest) {
      if (x2 < xmin)
        xmin = x2;
      if (x2 > xmax)
        xmax = x2;
      if (y2 < ymin)
        ymin = y2;
      if (y2 > ymax)
        ymax = y2;
    }
    this.xmin = xmin;
    this.xmax = xmax;
    this.ymin = ymin;
    this.ymax = ymax;
  }
  fixCollapsedRange() {
    let { xmin, xmax, ymin, ymax } = this;
    let xSize = xmax - xmin;
    let ySize = ymax - ymin;
    if (xSize === 0 && ySize === 0) {
      xmax++;
      xmin--;
      ymax++;
      ymin--;
    }
    if (xSize === 0 && ySize !== 0) {
      xmax += ySize / 2;
      xmin -= ySize / 2;
    }
    if (xSize !== 0 && ySize === 0) {
      ymax += xSize / 2;
      ymin -= xSize / 2;
    }
    this.xmin = xmin;
    this.xmax = xmax;
    this.ymin = ymin;
    this.ymax = ymax;
  }
  addBorder(borderInch) {
    let borderXUnit = this.dx() / this.widthInch * borderInch;
    let borderYUnit = this.dy() / this.heightInch * borderInch;
    this.xmin -= borderXUnit;
    this.xmax += borderXUnit;
    this.ymin -= borderYUnit;
    this.ymax += borderYUnit;
    this.widthInch += 2 * borderInch;
    this.heightInch += 2 * borderInch;
  }
  point2DtoPx(point) {
    let [xCoord, yCoord] = point;
    let x2 = toPixelX(this.xmin, this.xmax, this.width, xCoord);
    let y2 = toPixelY(this.ymin, this.ymax, this.height, yCoord);
    return [x2, y2];
  }
}
function getCircleCorners(center, radius) {
  let [h2, k2] = center;
  let r2 = radius;
  return [
    [h2 + r2, k2 + r2],
    [h2 + r2, k2 - r2],
    [h2 - r2, k2 + r2],
    [h2 - r2, k2 - r2]
  ];
}
function getSphereCorners(center, radius) {
  let [a2, b2, c2] = center;
  let r2 = radius;
  return [
    [a2 + r2, b2 + r2, c2 + r2],
    [a2 + r2, b2 + r2, c2 - r2],
    [a2 + r2, b2 - r2, c2 + r2],
    [a2 + r2, b2 - r2, c2 - r2],
    [a2 - r2, b2 + r2, c2 + r2],
    [a2 - r2, b2 + r2, c2 - r2],
    [a2 - r2, b2 - r2, c2 + r2],
    [a2 - r2, b2 - r2, c2 - r2]
  ];
}
function isPoint2D(thing) {
  return Array.isArray(thing) && thing.length === 2 && typeof thing[0] === "number" && typeof thing[1] === "number";
}
function isPoint3D(thing) {
  return Array.isArray(thing) && thing.length === 3 && typeof thing[0] === "number" && typeof thing[1] === "number" && typeof thing[2] === "number";
}
function isCircle(thing) {
  return thing.length === 2 && isPoint2D(thing[0]) && typeof thing[1] === "number";
}
function isSphere(thing) {
  return thing.length === 2 && isPoint3D(thing[0]) && typeof thing[1] === "number";
}
function thingsToPoints(things) {
  let pts = [];
  for (let th of things) {
    if (isPoint2D(th)) {
      pts.push(th);
      continue;
    }
    if (isPoint3D(th)) {
      pts.push(th);
      continue;
    }
    if (isCircle(th)) {
      pts.push(...getCircleCorners(...th));
      continue;
    }
    if (isSphere(th)) {
      pts.push(...getSphereCorners(...th));
      continue;
    }
  }
  return pts;
}
function proj(point3D2, angle2, depth) {
  let a2 = angle2 * Math.PI / 180;
  let s2 = Math.sin(a2);
  let c2 = Math.cos(a2);
  let [x2, y2, z2] = point3D2;
  let x_new = x2 + depth * y2 * c2;
  let y_new = z2 + depth * y2 * s2;
  return [x_new, y_new];
}
function forceProj(point, angle2, depth) {
  return point.length === 3 ? proj(point, angle2, depth) : point;
}
class Canvas02 extends Canvas01 {
  constructor() {
    super(...arguments);
    this.Proj_3D_Angle = 60;
    this.Proj_3D_Depth = 0.5;
  }
  pj(point) {
    return forceProj(point, this.Proj_3D_Angle, this.Proj_3D_Depth);
  }
  pjs(points) {
    return points.map(($) => this.pj($));
  }
  toPx(point) {
    let pt = this.pj(point);
    return this.point2DtoPx(pt);
  }
  capture(things) {
    let pts = thingsToPoints(things);
    let pt2Ds = this.pjs(pts);
    this.capturePoints2D(pt2Ds);
  }
}
function segmentArray(seg) {
  if (Array.isArray(seg))
    return seg;
  if (typeof seg === "number")
    return [seg, seg];
  if (typeof seg === "boolean")
    return seg ? [5, 5] : [];
  return [];
}
const REM_PIXEL = parseFloat(getComputedStyle(document.documentElement).fontSize);
class Canvas03 extends Canvas02 {
  constructor() {
    super(...arguments);
    this.AUTO_BORDER = false;
    this.RANGE_DONE = false;
    this.SIZE_DONE = false;
    this.$TEXT_DIR = 0;
    this.$TEXT_LATEX = false;
    this.$ANGLE_MODE = "normal";
    this.$LENGTH_UNIT = "";
    this.$BORDER = 0.2;
    this.$LINE_LABEL = "auto";
    this._$LABEL_CENTER = this.center();
    this.states = [];
  }
  get $WEIGHT() {
    return this.ctx.lineWidth;
  }
  set $WEIGHT(value) {
    this.ctx.lineWidth = value;
  }
  get $COLOR() {
    let c2 = this.ctx.fillStyle;
    return typeof c2 === "string" ? c2 : "";
  }
  set $COLOR(value) {
    this.ctx.strokeStyle = value;
    this.ctx.fillStyle = value;
  }
  get $ALPHA() {
    return this.ctx.globalAlpha;
  }
  set $ALPHA(value) {
    this.ctx.globalAlpha = value;
  }
  get $DASH() {
    return this.ctx.getLineDash();
  }
  set $DASH(value) {
    let seg = segmentArray(value);
    this.ctx.setLineDash(seg);
  }
  get $TEXT_ALIGN() {
    return this.ctx.textAlign;
  }
  set $TEXT_ALIGN(value) {
    this.ctx.textAlign = value;
  }
  get $TEXT_BASELINE() {
    return this.ctx.textBaseline;
  }
  set $TEXT_BASELINE(value) {
    this.ctx.textBaseline = value;
  }
  get $TEXT_PIXEL() {
    let match2 = this.ctx.font.match(/(\d+)px/);
    if (match2 === null)
      return NaN;
    return Number.parseInt(match2[1]);
  }
  set $TEXT_PIXEL(value) {
    value = Math.round(value);
    this.ctx.font = this.ctx.font.replace(/\d+px/g, value + "px");
  }
  get $TEXT_SIZE() {
    return this.$TEXT_PIXEL / REM_PIXEL;
  }
  set $TEXT_SIZE(value) {
    this.$TEXT_PIXEL = value * REM_PIXEL;
  }
  get $TEXT_ITALIC() {
    return this.ctx.font.includes("italic");
  }
  set $TEXT_ITALIC(value) {
    this.ctx.font = this.ctx.font.replace("italic ", "");
    if (value)
      this.ctx.font = "italic " + this.ctx.font;
  }
  get $3D_ANGLE() {
    return this.Proj_3D_Angle;
  }
  set $3D_ANGLE(value) {
    this.Proj_3D_Angle = value;
  }
  get $3D_DEPTH() {
    return this.Proj_3D_Depth;
  }
  set $3D_DEPTH(value) {
    this.Proj_3D_Depth = value;
  }
  set $LABEL_CENTER(centers) {
    let empty = centers.length === 0;
    this._$LABEL_CENTER = empty ? this.center() : mid$2(this.pjs(centers));
  }
  get $LABEL_CENTER() {
    return [this._$LABEL_CENTER];
  }
  save() {
    this.ctx.save();
    this.states.push({
      $3D_ANGLE: this.$3D_ANGLE,
      $3D_DEPTH: this.$3D_DEPTH,
      $TEXT_DIR: this.$TEXT_DIR,
      $TEXT_LATEX: this.$TEXT_LATEX,
      $LABEL_CENTER: this.$LABEL_CENTER,
      $ANGLE_MODE: this.$ANGLE_MODE,
      $LENGTH_UNIT: this.$LENGTH_UNIT,
      $BORDER: this.$BORDER,
      $LINE_LABEL: this.$LINE_LABEL
    });
  }
  restore() {
    this.ctx.restore();
    let state = this.states.pop();
    if (state === void 0)
      return;
    this.$3D_ANGLE = state.$3D_ANGLE;
    this.$3D_DEPTH = state.$3D_DEPTH;
    this.$TEXT_DIR = state.$TEXT_DIR;
    this.$TEXT_LATEX = state.$TEXT_LATEX;
    this.$LABEL_CENTER = state.$LABEL_CENTER;
    this.$ANGLE_MODE = state.$ANGLE_MODE;
    this.$LENGTH_UNIT = state.$LENGTH_UNIT;
    this.$BORDER = state.$BORDER;
    this.$LINE_LABEL = state.$LINE_LABEL;
  }
}
function mid$2(Points) {
  if (Points.length === 0)
    return [0, 0];
  let X2 = 0;
  let Y2 = 0;
  for (let p2 of Points) {
    X2 += p2[0];
    Y2 += p2[1];
  }
  let n2 = Points.length;
  return [X2 / n2, Y2 / n2];
}
function rad(degree) {
  return degree * Math.PI / 180;
}
function deg$2(radian) {
  return radian / Math.PI * 180;
}
function dotVec$1([x1, y1], [x2, y2]) {
  return [x2 - x1, y2 - y1];
}
function dir$1(A2, B2) {
  let [dx, dy] = dotVec$1(A2, B2);
  let rad2 = -Math.atan2(dy, dx);
  return deg$2(rad2);
}
function scaleDot([x2, y2], ratio) {
  return [x2 * ratio, y2 * ratio];
}
function dist(A2, B2) {
  let [dx, dy] = dotVec$1(A2, B2);
  return (dx * dx + dy * dy) ** 0.5;
}
function addDot([x1, y1], [x2, y2]) {
  return [x1 + x2, y1 + y2];
}
function scaleDotTo(A2, length) {
  let oldLength = dist([0, 0], A2);
  let ratio = length / oldLength;
  return scaleDot(A2, ratio);
}
function moveDot(A2, B2, dist2) {
  let AB = dotVec$1(A2, B2);
  let d2 = scaleDotTo(AB, dist2);
  return addDot(A2, d2);
}
class Canvas04 extends Canvas03 {
  translateTo(pt) {
    let [x2, y2] = this.toPx(pt);
    this.ctx.translate(x2, y2);
  }
  rotate(degreePolar) {
    this.ctx.rotate(-rad(degreePolar));
  }
  rotateTo(start, end) {
    let [x1, y1] = this.toPx(start);
    let [x2, y2] = this.toPx(end);
    let dx = x2 - x1;
    let dy = y2 - y1;
    let q2 = Math.atan2(dy, dx);
    this.ctx.rotate(q2);
  }
  alignTo(start, end) {
    this.translateTo(end);
    this.rotateTo(start, end);
  }
  moveToPx([x2, y2]) {
    this.ctx.moveTo(x2, y2);
  }
  lineToPx([x2, y2]) {
    this.ctx.lineTo(x2, y2);
  }
  createPathPx(dots) {
    this.ctx.beginPath();
    if (dots.length === 0)
      return;
    let [first, ...rest] = dots;
    this.moveToPx(first);
    for (let d2 of rest) {
      this.lineToPx(d2);
    }
  }
  createShapePx(dots) {
    this.createPathPx(dots);
    this.ctx.closePath();
  }
  moveTo(pt) {
    let [x2, y2] = this.toPx(pt);
    this.ctx.moveTo(x2, y2);
  }
  lineTo(pt) {
    let [x2, y2] = this.toPx(pt);
    this.ctx.lineTo(x2, y2);
  }
  createPath(pts) {
    this.ctx.beginPath();
    if (pts.length === 0)
      return;
    let [first, ...rest] = pts;
    this.moveTo(first);
    for (let p2 of rest) {
      this.lineTo(p2);
    }
  }
  createShape(pts) {
    this.createPath(pts);
    this.ctx.closePath();
  }
  createArc(center, radius, angle2) {
    let [x2, y2] = this.toPx(center);
    let [q1, q2] = angle2;
    q1 = -rad(q1);
    q2 = -rad(q2);
    this.ctx.beginPath();
    this.ctx.arc(x2, y2, radius, q1, q2, true);
  }
  createArcByPoints(P2, O2, Q2, radius) {
    let p2 = this.toPx(P2);
    let o2 = this.toPx(O2);
    let q2 = this.toPx(Q2);
    let q1 = dir$1(o2, p2);
    let q22 = dir$1(o2, q2);
    this.createArc(O2, radius, [q1, q22]);
  }
  createRightAnglePath(P2, O2, Q2, size) {
    let p2 = this.toPx(P2);
    let o2 = this.toPx(O2);
    let q2 = this.toPx(Q2);
    let a2 = moveDot(o2, p2, size);
    let b2 = moveDot(o2, q2, size);
    let c2 = addDot(b2, dotVec$1(o2, a2));
    this.createPathPx([a2, c2, b2]);
  }
  doStroke() {
    this.ctx.stroke();
  }
  doSolid() {
    let dash = this.$DASH;
    this.$DASH = false;
    this.ctx.stroke();
    this.$DASH = dash;
  }
  doDash() {
    let dash = this.$DASH;
    this.$DASH = true;
    this.ctx.stroke();
    this.$DASH = dash;
  }
  doFill() {
    this.ctx.fill();
  }
  doShade() {
    const DEFAULT_SHADE_ALPHA2 = 0.1;
    let alpha = this.$ALPHA;
    this.$ALPHA = DEFAULT_SHADE_ALPHA2;
    this.ctx.fill();
    this.$ALPHA = alpha;
  }
}
function sin$1(degree) {
  return Math.sin(degree / 180 * Math.PI);
}
function cos$1(degree) {
  return Math.cos(degree / 180 * Math.PI);
}
function LatexWidget(text2, color, size) {
  text2 = `\\color{${color}} ` + text2;
  const widget = new CanvasLatex.default(text2, {
    displayMode: true,
    debugBounds: false,
    baseSize: size
  });
  return widget;
}
function latexTuneX(x2, width, textAlign) {
  if (textAlign === "left")
    return -x2;
  if (textAlign === "right")
    return -x2 - width;
  if (textAlign === "center")
    return -x2 - width / 2;
  return -x2 - width / 2;
}
function latexTuneY(y2, height, textBaseline) {
  if (textBaseline === "top")
    return -y2;
  if (textBaseline === "bottom")
    return -y2 - height;
  if (textBaseline === "middle")
    return -y2 - height / 2;
  return -y2 / 2;
}
function isAlphabet(_) {
  return _.length === 1 && _.toLowerCase() !== _.toUpperCase();
}
class Canvas05 extends Canvas04 {
  plainPx(text2, dot) {
    text2 = String(text2);
    if (text2 === "")
      return;
    this.save();
    this.ctx.translate(...dot);
    this.rotate(this.$TEXT_DIR);
    this.ctx.fillText(text2, 0, 0);
    this.restore();
  }
  latexPx(text2, dot) {
    text2 = String(text2);
    if (text2 === "")
      return;
    const widget = LatexWidget(text2, this.$COLOR, this.$TEXT_PIXEL);
    const bounds = widget.getBounds();
    if (bounds === null) {
      console.error("[CanvasLatex] bounds === null! This is an unexpected error.");
      return;
    }
    this.save();
    this.ctx.translate(...dot);
    this.rotate(this.$TEXT_DIR);
    let xTune = latexTuneX(bounds.x, bounds.width, this.ctx.textAlign);
    let yTune = latexTuneY(bounds.y, bounds.height, this.ctx.textBaseline);
    this.ctx.translate(xTune, yTune);
    widget.draw(this.ctx);
    this.restore();
  }
  textPx(text2, dot) {
    if (this.$TEXT_LATEX) {
      this.latexPx(text2, dot);
    } else {
      this.plainPx(text2, dot);
    }
  }
  text(text2, point, offset) {
    let [x2, y2] = this.toPx(point);
    x2 += offset[0];
    y2 -= offset[1];
    this.textPx(text2, [x2, y2]);
  }
  write(text2, point) {
    this.text(text2, point, [0, 0]);
  }
  labelOffset(text2, radius, dir2) {
    let textWidth = this.textSemi(text2);
    let x2 = (radius + textWidth - 5) * cos$1(dir2);
    let y2 = radius * sin$1(dir2);
    return [x2, y2];
  }
  label(text2, point, radius, dir2) {
    let italic = this.$TEXT_ITALIC;
    if (isAlphabet(text2))
      this.$TEXT_ITALIC = true;
    let offset = this.labelOffset(text2, radius, dir2);
    this.text(text2, point, offset);
    this.$TEXT_ITALIC = italic;
  }
  plainSemi(text2) {
    return this.ctx.measureText(text2).width / 2;
  }
  latexSemi(text2) {
    const widget = LatexWidget(text2, this.$COLOR, this.$TEXT_PIXEL);
    const bounds = widget.getBounds();
    return bounds === null ? 0 : bounds.width / 2;
  }
  textSemi(text2) {
    return this.$TEXT_LATEX ? this.latexSemi(text2) : this.plainSemi(text2);
  }
}
function deg$1(radian) {
  return radian / Math.PI * 180;
}
function dotVec([x1, y1], [x2, y2]) {
  return [x2 - x1, y2 - y1];
}
function dir(A2, B2) {
  let [dx, dy] = dotVec(A2, B2);
  let rad2 = -Math.atan2(dy, dx);
  return deg$1(rad2);
}
function vec$1(p1, p2) {
  let [x1, y1] = p1;
  let [x2, y2] = p2;
  return [x2 - x1, y2 - y1];
}
function cross2D(vec1, vec2) {
  let [x1, y1] = vec1;
  let [x2, y2] = vec2;
  return x1 * y2 - y1 * x2;
}
function IsReflex$1(A2, O2, B2) {
  let OA = vec$1(O2, A2);
  let OB = vec$1(O2, B2);
  return cross2D(OA, OB) < 0;
}
function polarFlip(A2, O2, B2, mode) {
  let isReflex = IsReflex$1(A2, O2, B2);
  if (mode === "normal" && isReflex)
    return true;
  if (mode === "reflex" && !isReflex)
    return true;
  return false;
}
class Canvas06 extends Canvas05 {
  getDir(start, end) {
    let A2 = this.toPx(start);
    let B2 = this.toPx(end);
    return dir(A2, B2);
  }
  getCenterDir(point) {
    let C2 = this.$LABEL_CENTER[0];
    return this.getDir(C2, point);
  }
  getDirAngle(A2, O2, B2) {
    let flip = this.polarFlip(A2, O2, B2);
    let [P2, Q2] = flip ? [B2, A2] : [A2, B2];
    let a2 = this.getDir(O2, P2);
    let b2 = this.getDir(O2, Q2);
    return a2 <= b2 ? b2 - a2 : 360 + b2 - a2;
  }
  getMidDir(A2, O2, B2) {
    let flip = this.polarFlip(A2, O2, B2);
    let [P2, Q2] = flip ? [B2, A2] : [A2, B2];
    let a1 = this.getDir(O2, P2);
    let a2 = this.getDir(O2, Q2);
    if (a2 < a1)
      a2 += 360;
    return (a1 + a2) / 2;
  }
  getLineDir(A2, B2) {
    let q2 = this.getDir(A2, B2);
    let mode = this.$LINE_LABEL;
    if (mode === "left")
      return q2 + 90;
    if (mode === "right")
      return q2 - 90;
    let [a2, b2, c2] = this.pjs([A2, B2, this.$LABEL_CENTER[0]]);
    let right = IsReflex$1(a2, b2, c2);
    return right ? q2 - 90 : q2 + 90;
  }
  polarFlip(A2, O2, B2) {
    let [a2, o2, b2] = this.pjs([A2, O2, B2]);
    return polarFlip(a2, o2, b2, this.$ANGLE_MODE);
  }
  unitize(text2) {
    if (typeof text2 === "number") {
      text2 = String(text2);
      let unit = this.$LENGTH_UNIT;
      if (unit === "")
        return text2;
      return this.$TEXT_LATEX ? text2 + `~\\text{${unit}}` : text2 + " " + unit;
    } else {
      return text2;
    }
  }
  getAngleAllowance(A2, O2, B2, threshold, pixelPerDeg) {
    let angle2 = this.getDirAngle(A2, O2, B2);
    let angleUnderThreshold = Math.max(threshold - angle2, 0);
    return angleUnderThreshold * pixelPerDeg;
  }
}
function isOdd(n2) {
  return n2 % 2 !== 0;
}
function floorHalf(n2) {
  if (isOdd(n2))
    n2 = n2 - 1;
  return n2 / 2;
}
function steps(n2) {
  let N2 = floorHalf(n2);
  let arr = [];
  if (isOdd(n2)) {
    arr.push(0);
    for (let i2 = 1; i2 <= N2; i2++) {
      arr.push(i2);
      arr.push(-i2);
    }
  } else {
    for (let i2 = 1; i2 <= N2; i2++) {
      let s2 = i2 - 0.5;
      arr.push(s2);
      arr.push(-s2);
    }
  }
  return arr;
}
function mid$1(A2, B2) {
  if (A2.length === 3 && B2.length === 3) {
    let [x2, y2, z2] = A2;
    let [X2, Y2, Z2] = B2;
    return [(x2 + X2) / 2, (y2 + Y2) / 2, (z2 + Z2) / 2];
  } else {
    let [x2, y2] = A2;
    let [X2, Y2] = B2;
    return [(x2 + X2) / 2, (y2 + Y2) / 2];
  }
}
class Canvas07 extends Canvas06 {
  linePx(dots) {
    this.createPathPx(dots);
    this.doStroke();
  }
  solidPx(dots) {
    this.createPathPx(dots);
    this.doSolid();
  }
  line(pts) {
    this.createPath(pts);
    this.doStroke();
  }
  lineVert(x2) {
    let A2 = this.edgeBottom(x2);
    let B2 = this.edgeTop(x2);
    this.line([A2, B2]);
  }
  lineHori(y2) {
    let A2 = this.edgeLeft(y2);
    let B2 = this.edgeRight(y2);
    this.line([A2, B2]);
  }
  solid(pts) {
    this.createPath(pts);
    this.doSolid();
  }
  dash(pts) {
    this.createPath(pts);
    this.doDash();
  }
  shape(pts) {
    this.createShape(pts);
    this.doStroke();
  }
  fill(pts) {
    this.createShape(pts);
    this.doFill();
  }
  shade(pts) {
    this.createShape(pts);
    this.doShade();
  }
  arc(P2, O2, Q2, radius) {
    this.createArcByPoints(P2, O2, Q2, radius);
    this.doStroke();
  }
  solidArc(P2, O2, Q2, radius) {
    this.createArcByPoints(P2, O2, Q2, radius);
    this.doSolid();
  }
  circle(center, radius) {
    this.createArc(center, radius, [0, 360]);
    this.doStroke();
  }
  disc(center, radius) {
    this.createArc(center, radius, [0, 360]);
    this.doFill();
  }
  halo(center, radius) {
    this.createArc(center, radius, [0, 360]);
    this.doShade();
  }
  arrowHead(start, end, size, offset) {
    this.save();
    this.translateTo(end);
    this.rotateTo(start, end);
    let A2 = [offset - 2 * size, -size];
    let O2 = [offset, 0];
    let B2 = [offset - 2 * size, +size];
    this.solidPx([A2, O2, B2]);
    this.restore();
  }
  arrow(start, end, size) {
    this.line([start, end]);
    this.arrowHead(start, end, size, 0);
  }
  anglePolar(A2, O2, B2, radius, count, space) {
    for (let s2 of steps(count)) {
      let r2 = radius + s2 * space;
      this.solidArc(A2, O2, B2, r2);
    }
  }
  angle(A2, O2, B2, radius, count, space) {
    let flip = this.polarFlip(A2, O2, B2);
    let [P2, Q2] = flip ? [B2, A2] : [A2, B2];
    this.anglePolar(P2, O2, Q2, radius, count, space);
  }
  rightAngle(A2, O2, B2, size) {
    this.createRightAnglePath(A2, O2, B2, size);
    this.doSolid();
  }
  parallel(start, end, size, count, space) {
    let M2 = mid$1(start, end);
    for (let i2 = 0; i2 < count; i2++) {
      this.arrowHead(start, M2, size, i2 * space);
    }
  }
  tick(start, end, length, offset) {
    this.save();
    this.translateTo(end);
    this.rotateTo(start, end);
    let A2 = [offset, -length];
    let B2 = [offset, +length];
    this.solidPx([A2, B2]);
    this.restore();
  }
  tickVert(pt, length) {
    let [x2, y2] = pt;
    this.tick([x2 - 1, y2], pt, length, 0);
  }
  tickHori(pt, length) {
    let [x2, y2] = pt;
    this.tick([x2, y2 - 1], pt, length, 0);
  }
  equalSide(start, end, length, count, space) {
    let M2 = mid$1(start, end);
    for (let s2 of steps(count)) {
      this.tick(start, M2, length, s2 * space);
    }
  }
  compass(center, xSize, ySize, arrowSize) {
    this.save();
    this.translateTo(center);
    let E2 = [xSize, 0];
    let W2 = [-xSize, 0];
    let S2 = [0, ySize];
    let N2 = [0, -ySize];
    let A2 = [-arrowSize, -ySize + arrowSize * 2];
    let B2 = [+arrowSize, -ySize + arrowSize * 2];
    this.solidPx([E2, W2]);
    this.solidPx([N2, S2]);
    this.solidPx([A2, N2, B2]);
    this.restore();
  }
}
const LABEL_OFFSET_PX = 15;
const X_MARK_OFFSET_PX = 15;
const Y_MARK_OFFSET_PX = 10;
const TICK_LENGTH_PX = 5;
function getTicks(min2, max2, interval2) {
  const start = Math.floor(min2 / interval2) * interval2;
  const arr = [];
  for (let i2 = start; i2 <= max2; i2 += interval2) {
    i2 = parseFloat(i2.toPrecision(3));
    if (i2 === min2 || i2 === max2)
      continue;
    if (i2 === 0)
      continue;
    arr.push(i2);
  }
  return arr;
}
class Canvas08 extends Canvas07 {
  xAxis() {
    let A2 = this.edgeLeft(0);
    let B2 = this.edgeRight(0);
    this.arrow(A2, B2, 5);
  }
  yAxis() {
    let A2 = this.edgeBottom(0);
    let B2 = this.edgeTop(0);
    this.arrow(A2, B2, 5);
  }
  xAxisLabel(text2) {
    this.save();
    this.$TEXT_ALIGN = "right";
    this.$TEXT_BASELINE = "middle";
    this.label(text2, this.edgeRight(0), LABEL_OFFSET_PX, 90);
    this.restore();
  }
  yAxisLabel(text2) {
    this.save();
    this.$TEXT_ALIGN = "left";
    this.$TEXT_BASELINE = "top";
    this.label(text2, this.edgeTop(0), LABEL_OFFSET_PX, 0);
    this.restore();
  }
  xTicks(interval2) {
    return getTicks(this.xmin, this.xmax, interval2);
  }
  yTicks(interval2) {
    return getTicks(this.ymin, this.ymax, interval2);
  }
  xAxisTick(interval2) {
    for (let x2 of this.xTicks(interval2)) {
      this.tickVert([x2, 0], TICK_LENGTH_PX);
    }
  }
  yAxisTick(interval2) {
    for (let y2 of this.yTicks(interval2)) {
      this.tickHori([0, y2], TICK_LENGTH_PX);
    }
  }
  xAxisTickMark(interval2) {
    this.save();
    this.$TEXT_ITALIC = false;
    this.$TEXT_ALIGN = "center";
    this.$TEXT_BASELINE = "middle";
    for (let x2 of this.xTicks(interval2)) {
      this.label(String(x2), [x2, 0], X_MARK_OFFSET_PX, 270);
    }
    this.restore();
  }
  yAxisTickMark(interval2) {
    this.save();
    this.$TEXT_ITALIC = false;
    this.$TEXT_ALIGN = "right";
    this.$TEXT_BASELINE = "middle";
    for (let y2 of this.yTicks(interval2)) {
      this.label(String(y2), [0, y2], Y_MARK_OFFSET_PX, 180);
    }
    this.restore();
  }
  xAxisGrid(interval2) {
    this.save();
    this.$COLOR = "#d3d5db";
    this.lineVert(0);
    for (let x2 of this.xTicks(interval2)) {
      this.lineVert(x2);
    }
    this.restore();
  }
  yAxisGrid(interval2) {
    this.save();
    this.$COLOR = "#d3d5db";
    this.lineHori(0);
    for (let y2 of this.yTicks(interval2)) {
      this.lineHori(y2);
    }
    this.restore();
  }
}
function trace(func, range2, dots = 1e3) {
  function tracer(t3) {
    let result2;
    try {
      result2 = func(t3);
    } catch {
      return [NaN, NaN];
    }
    if (!Array.isArray(result2))
      result2 = [t3, result2];
    return result2;
  }
  let [t1, t2] = range2;
  const step = (t2 - t1) / (dots - 1);
  let points = [];
  for (let t3 = t1; t3 <= t2; t3 += step) {
    points.push(tracer(t3));
  }
  return points;
}
function traceCircle(center, radius, angleRange, dots = 100) {
  const [h2, k2] = center;
  function sin2(degree) {
    return Math.sin(degree / 180 * Math.PI);
  }
  function cos2(degree) {
    return Math.cos(degree / 180 * Math.PI);
  }
  return trace((t2) => [h2 + radius * cos2(t2), k2 + radius * sin2(t2)], angleRange, dots);
}
function splitNull(arr) {
  let ls = [];
  let clone2 = [...arr];
  while (true) {
    let index = clone2.findIndex(($) => $ === null);
    if (index === -1) {
      let head = clone2.splice(0);
      ls.push(head);
      break;
    } else {
      let head = clone2.splice(0, index);
      ls.push(head);
      clone2.shift();
      if (clone2.length === 0)
        break;
    }
  }
  ls = ls.filter(($) => $.length > 0);
  return ls;
}
function vec(p1, p2) {
  let [x1, y1] = p1;
  let [x2, y2] = p2;
  return [x2 - x1, y2 - y1];
}
function deg(radian) {
  return radian / Math.PI * 180;
}
function magnitude([x2, y2]) {
  return (x2 * x2 + y2 * y2) ** 0.5;
}
function argument([x2, y2]) {
  let rad2 = Math.atan2(y2, x2);
  let angle2 = deg(rad2);
  if (angle2 < 0)
    angle2 += 360;
  return angle2;
}
function sectoroid(O2, A2, B2, vertices) {
  let v1 = vec(O2, A2);
  let v2 = vec(O2, B2);
  let r2 = magnitude(v1);
  let q1 = argument(v1);
  let q2 = argument(v2);
  if (q2 < q1)
    q2 += 360;
  let points = traceCircle(O2, r2, [q1, q2]);
  return [A2, ...points, B2, ...vertices];
}
class Canvas09 extends Canvas08 {
  plot(func, tStart = this.xmin, tEnd = this.xmax, dots = 1e3) {
    let points = trace(func, [tStart, tEnd], dots);
    let { xmin, xmax, ymin, ymax } = this;
    let X2 = xmax - xmin;
    let Y2 = ymax - ymin;
    function outOfRange([x2, y2]) {
      return x2 > xmax + X2 || x2 < xmin - X2 || y2 > ymax + Y2 || y2 < ymin - Y2;
    }
    function isIll(p2) {
      let [x2, y2] = p2;
      return !Number.isFinite(x2) || !Number.isFinite(y2) || outOfRange(p2);
    }
    let filteredPoints = points.map((p2) => isIll(p2) ? null : p2);
    let segments = splitNull(filteredPoints);
    for (let seg of segments)
      this.line(seg);
  }
  sectoroidLine(O2, A2, B2, vertices) {
    let pts = sectoroid(O2, A2, B2, vertices);
    this.line(pts);
  }
  sectoroidFill(O2, A2, B2, vertices) {
    let pts = sectoroid(O2, A2, B2, vertices);
    this.fill(pts);
  }
  sectoroidShade(O2, A2, B2, vertices) {
    let pts = sectoroid(O2, A2, B2, vertices);
    this.shade(pts);
  }
}
function degrize(text2) {
  return typeof text2 === "number" ? text2 + "\xB0" : text2;
}
function mid(A2, B2) {
  if (A2.length === 3 && B2.length === 3) {
    let [x2, y2, z2] = A2;
    let [X2, Y2, Z2] = B2;
    return [(x2 + X2) / 2, (y2 + Y2) / 2, (z2 + Z2) / 2];
  } else {
    let [x2, y2] = A2;
    let [X2, Y2] = B2;
    return [(x2 + X2) / 2, (y2 + Y2) / 2];
  }
}
class Canvas10 extends Canvas09 {
  labelPoint(text2, point, dir2, radius) {
    this.label(text2, point, radius, dir2);
  }
  labelPointAuto(text2, point, radius) {
    let dir2 = this.getCenterDir(point);
    this.label(text2, point, radius, dir2);
  }
  labelAngle(text2, [A2, O2, B2], dir2, radius) {
    let T2 = degrize(text2);
    let mid2 = this.getMidDir(A2, O2, B2);
    this.label(T2, O2, radius, mid2 + dir2);
  }
  labelLine(text2, [A2, B2], dir2, radius) {
    text2 = this.unitize(text2);
    let M2 = mid(A2, B2);
    let normal = this.getLineDir(A2, B2);
    this.label(text2, M2, radius, normal + dir2);
  }
}
class PenRange {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  set([xmin, xmax], [ymin, ymax] = [xmin, xmax]) {
    this.cv.xmin = xmin;
    this.cv.xmax = xmax;
    this.cv.ymin = ymin;
    this.cv.ymax = ymax;
    this.cv.RANGE_DONE = true;
  }
  square(size, [x2, y2] = [0, 0]) {
    this.set([x2 - size, x2 + size], [y2 - size, y2 + size]);
  }
  capture(...things) {
    this.cv.capture(things);
    this.cv.AUTO_BORDER = true;
  }
  extend(...things) {
    this.capture([0, 0], ...things);
  }
}
class PenSize {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  initSize(widthInch, heightInch) {
    if (!this.cv.RANGE_DONE)
      throw "[Pencil] Range must be set before Size";
    this.cv.widthInch = widthInch;
    this.cv.heightInch = heightInch;
    this.cv.SIZE_DONE = true;
  }
  initOuterBorder() {
    if (!this.cv.RANGE_DONE)
      throw "[Pencil] Range must be set before setting border";
    if (!this.cv.SIZE_DONE)
      throw "[Pencil] Size must be set before setting border";
    this.cv.addBorder(this.cv.$BORDER);
  }
  set(widthInch = 1, heightInch = widthInch) {
    this.initSize(widthInch, heightInch);
    if (this.cv.AUTO_BORDER)
      this.initOuterBorder();
    this.pen.set.reset();
  }
  resolution(xIPU = 0.1, yIPU = xIPU) {
    let xScale = this.cv.dx() * xIPU;
    let yScale = this.cv.dy() * yIPU;
    this.set(xScale, yScale);
  }
  lock(maxWidthInch = 1, maxHeightInch = maxWidthInch) {
    let ratio = this.cv.yxRatio();
    if (maxWidthInch * ratio < maxHeightInch) {
      this.set(maxWidthInch, maxWidthInch * ratio);
    } else {
      this.set(maxHeightInch / ratio, maxHeightInch);
    }
  }
}
class PenSettings {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  weight(weight = 1) {
    this.cv.$WEIGHT = weight;
  }
  color(color = "black") {
    this.cv.$COLOR = color;
  }
  alpha(value = 1) {
    this.cv.$ALPHA = value;
  }
  dash(segments = []) {
    this.cv.$DASH = segments;
  }
  textAlign(align = "center") {
    this.cv.$TEXT_ALIGN = align;
  }
  textBaseline(baseline = "middle") {
    this.cv.$TEXT_BASELINE = baseline;
  }
  textSize(size = 1) {
    this.cv.$TEXT_SIZE = size;
  }
  textItalic(italic = false) {
    this.cv.$TEXT_ITALIC = italic;
  }
  textDir(angle2 = 0) {
    this.cv.$TEXT_DIR = angle2;
  }
  textLatex(on = false) {
    this.cv.$TEXT_LATEX = on;
  }
  labelCenter(...centers) {
    this.cv.$LABEL_CENTER = centers;
  }
  lengthUnit(text2 = "") {
    this.cv.$LENGTH_UNIT = text2;
  }
  angle(mode = "normal") {
    this.cv.$ANGLE_MODE = mode;
  }
  projector3D(angle2 = 60, depth = 0.5) {
    this.cv.$3D_ANGLE = angle2;
    this.cv.$3D_DEPTH = depth;
  }
  border(border = 0.2) {
    this.cv.$BORDER = border;
  }
  lineLabel(setting = "auto") {
    this.cv.$LINE_LABEL = setting;
  }
  reset() {
    this.weight();
    this.color();
    this.alpha();
    this.dash();
    this.textAlign();
    this.textBaseline();
    this.textSize();
    this.textItalic();
    this.textDir();
    this.textLatex();
    this.labelCenter();
    this.lengthUnit();
    this.angle();
    this.lineLabel();
  }
  resetAll() {
    this.reset();
    this.border();
    this.projector3D();
  }
}
class PenD3 {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  axis3D(length = 999) {
    this.pen.line([-length, 0, 0], [length, 0, 0]);
    this.pen.line([0, -length, 0], [0, length, 0]);
    this.pen.dash([0, 0, -length], [0, 0, length]);
  }
  circle(center, radius, xVec, yVec, {
    line = true,
    dash = false,
    shade = false,
    fill = false,
    arc = [0, 360]
  } = {}) {
    let ps = cal.traceCircle([0, 0], radius, arc);
    let ps3D = Embed(ps, center, xVec, yVec);
    if (line) {
      this.cv.save();
      if (dash)
        this.pen.set.dash(true);
      if (arc[1] - arc[0] >= 360) {
        this.pen.polygon(...ps3D);
      } else {
        this.pen.polyline(...ps3D);
      }
      this.cv.restore();
    }
    if (shade)
      this.pen.polyshade(...ps3D);
    if (fill)
      this.pen.polyfill(...ps3D);
  }
  circleXZ(center, radius, {
    line = true,
    dash = false,
    shade = false,
    fill = false,
    arc = [0, 360]
  } = {}) {
    this.circle(center, radius, [1, 0, 0], [0, 0, 1], {
      line,
      dash,
      shade,
      fill,
      arc
    });
  }
  circleYZ(center, radius, {
    line = true,
    dash = false,
    shade = false,
    fill = false,
    arc = [0, 360]
  } = {}) {
    this.circle(center, radius, [0, 1, 0], [0, 0, 1], {
      line,
      dash,
      shade,
      fill,
      arc
    });
  }
  circleXY(center, radius, {
    line = true,
    dash = false,
    shade = false,
    fill = false,
    arc = [0, 360]
  } = {}) {
    this.circle(center, radius, [1, 0, 0], [0, 1, 0], {
      line,
      dash,
      shade,
      fill,
      arc
    });
  }
  sphere(center, radius, {
    baseDash = false,
    baseShade = false,
    radiusLine = false,
    radiusDash = false,
    radiusLabel = "",
    lowerOnly = false,
    upperOnly = false
  } = {}) {
    if (upperOnly)
      this.circleXZ(center, radius, { arc: [0, 180] });
    if (lowerOnly)
      this.circleXZ(center, radius, { arc: [180, 360] });
    if (!upperOnly && !lowerOnly)
      this.circleXZ(center, radius, { arc: [0, 360] });
    this.circleXY(center, radius, { line: true, dash: baseDash, shade: baseShade });
    let leftEnd = vec3D(center).add([radius, 0, 0]).toArray();
    if (radiusLine)
      this.pen.line(center, leftEnd);
    if (radiusDash)
      this.pen.dash(center, leftEnd);
    if (radiusLabel.length > 0)
      this.pen.label.line([leftEnd, center], radiusLabel);
  }
  envelope(lowerBase, upperBase) {
    const LB = toList(lowerBase);
    const UB = toList(upperBase);
    let isPolar = (A2, O2, B2) => AnglePolar(this.cv.pj(A2), this.cv.pj(O2), this.cv.pj(B2)) < 180 ? 1 : -1;
    let lastPolarwise = isPolar(LB.cyclicAt(-1), UB.cyclicAt(-1), LB.cyclicAt(0));
    let arr = [];
    for (let i2 = 0; i2 < LB.length; i2++) {
      let polarwise = isPolar(LB.cyclicAt(i2), UB.cyclicAt(i2), LB.cyclicAt(i2 + 1));
      if (lastPolarwise * polarwise === -1)
        arr.push([LB.cyclicAt(i2), UB.cyclicAt(i2)]);
      lastPolarwise = polarwise;
    }
    return arr;
  }
  frustum(lowerBase, upperBase, {
    base: base2 = true,
    height = false,
    shadeLower = false,
    shadeUpper = false,
    envelope = false
  } = {}) {
    if (owl.point3D(upperBase)) {
      upperBase = Array(lowerBase.length).fill(upperBase);
    }
    if (base2) {
      this.pen.polygon(...lowerBase);
      this.pen.polygon(...upperBase);
    }
    if (envelope) {
      let env = this.envelope(lowerBase, upperBase);
      for (let e2 of env) {
        this.pen.line(e2[0], e2[1]);
      }
    } else {
      for (let i2 = 0; i2 < lowerBase.length; i2++) {
        this.pen.line(lowerBase[i2], upperBase[i2]);
      }
    }
    if (height) {
      let V2 = toShape3D(upperBase).mean().toArray();
      let [A2, B2, C2] = lowerBase;
      let O2 = PdFoot3D(V2, [A2, B2, C2]);
      this.pen.dash(O2, V2);
    }
    if (shadeLower)
      this.pen.polyshade(...lowerBase);
    if (shadeUpper)
      this.pen.polyshade(...upperBase);
  }
  prismZ(lowerBase, lowerZ, upperZ, {
    base: base2 = true,
    height = false,
    shadeLower = false,
    shadeUpper = false,
    envelope = false
  } = {}) {
    let lower = EmbedZ(lowerBase, lowerZ);
    let upper = EmbedZ(lowerBase, upperZ);
    this.frustum(lower, upper, {
      base: base2,
      height,
      shadeLower,
      shadeUpper,
      envelope
    });
  }
  cylinderZ(center, radius, lowerZ, upperZ, {
    base: base2 = true,
    height = false,
    shadeLower = false,
    shadeUpper = false,
    envelope = true
  } = {}) {
    let ps = cal.traceCircle(center, radius, [0, 360]);
    this.prismZ(ps, lowerZ, upperZ, {
      base: base2,
      height,
      shadeLower,
      shadeUpper,
      envelope
    });
  }
  pyramidZ(lowerBase, lowerZ, vertex, {
    base: base2 = true,
    height = false,
    shadeLower = false,
    envelope = false
  } = {}) {
    let lower = EmbedZ(lowerBase, lowerZ);
    this.frustum(lower, vertex, {
      base: base2,
      height,
      shadeLower,
      envelope
    });
  }
  coneZ(center, radius, lowerZ, vertex, {
    base: base2 = true,
    height = false,
    shadeLower = false,
    envelope = true
  } = {}) {
    let ps = cal.traceCircle(center, radius, [0, 360]);
    this.pyramidZ(ps, lowerZ, vertex, {
      base: base2,
      height,
      shadeLower,
      envelope
    });
  }
  frustumZ(lowerBase, lowerZ, vertex, scale, {
    base: base2 = true,
    height = false,
    shadeLower = false,
    shadeUpper = false,
    envelope = false
  } = {}) {
    let lower = EmbedZ(lowerBase, lowerZ);
    let upper = Extrude(lower, [vertex], scale);
    this.frustum(lower, upper, {
      base: base2,
      height,
      shadeLower,
      shadeUpper,
      envelope
    });
  }
  conicalFrustumZ(center, radius, lowerZ, vertex, scale, {
    base: base2 = true,
    height = false,
    shadeLower = false,
    shadeUpper = false,
    envelope = true
  } = {}) {
    let ps = cal.traceCircle(center, radius, [0, 360]);
    this.frustumZ(ps, lowerZ, vertex, scale, {
      base: base2,
      height,
      shadeLower,
      shadeUpper,
      envelope
    });
  }
  angleBet(angle2, line, label) {
    let [P2, O2, Q2] = angle2;
    let [A2, B2] = line;
    this.pen.line(P2, O2);
    this.pen.line(Q2, O2);
    this.pen.angle(P2, O2, Q2);
    if (label !== void 0)
      this.pen.label.angle([P2, O2, Q2], label);
    if (A2 !== void 0)
      this.pen.rightAngle(P2, O2, A2);
    if (B2 !== void 0)
      this.pen.rightAngle(Q2, O2, B2);
  }
  height(vertex, foot, leg, label) {
    this.pen.dash(vertex, foot);
    this.pen.rightAngle(vertex, foot, leg);
    this.pen.line(foot, leg);
    if (label !== void 0)
      this.pen.label.line([vertex, foot], label);
  }
  altitude(vertex, foot, leg, label) {
    this.pen.line(vertex, foot);
    this.pen.rightAngle(vertex, foot, leg);
    this.pen.line(foot, leg);
    if (label !== void 0)
      this.pen.label.line([vertex, foot], label);
  }
}
class PenGraph {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  circle(center, radius) {
    const [h2, k2] = center;
    this.pen.plot((t2) => [h2 + radius * cos(t2), k2 + radius * sin(t2)], 0, 365);
  }
  arc(O2, A2, B2) {
    this.cv.sectoroidLine(O2, A2, B2, []);
  }
  sector(O2, A2, B2) {
    this.cv.sectoroidLine(O2, A2, B2, [O2, A2]);
  }
  segment(O2, A2, B2) {
    this.cv.sectoroidLine(O2, A2, B2, [A2]);
  }
  quadratic(a2, b2, c2) {
    this.pen.plot((x2) => a2 * x2 * x2 + b2 * x2 + c2);
  }
  line(m2, c2) {
    const { xmin, xmax } = this.cv;
    const y2 = (x2) => m2 * x2 + c2;
    this.pen.line([xmin, y2(xmin)], [xmax, y2(xmax)]);
  }
  horizontal(y2) {
    this.cv.lineHori(y2);
  }
  vertical(x2) {
    this.cv.lineVert(x2);
  }
  linear(a2, b2, c2) {
    if (a2 === 0 && b2 !== 0)
      this.horizontal(-c2 / b2);
    if (b2 == 0 && a2 !== 0)
      this.vertical(-c2 / a2);
    if (a2 !== 0 && b2 !== 0)
      this.line(-a2 / b2, -c2 / b2);
  }
  through(A2, B2) {
    let ptA = this.cv.pj(A2);
    let ptB = this.cv.pj(B2);
    let [a2, b2, c2] = lin().byTwoPoints(ptA, ptB).toLinear();
    this.linear(a2, b2, c2);
  }
  perpBisector(A2, B2) {
    let [a2, b2, c2] = lin().byBisector(A2, B2).toLinear();
    this.linear(a2, b2, c2);
  }
}
class PenFill {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  circle(center, radius) {
    let points = cal.traceCircle(center, radius, [0, 360]);
    this.pen.polyfill(...points);
  }
  sector(O2, A2, B2) {
    this.cv.sectoroidFill(O2, A2, B2, [O2]);
  }
  segment(O2, A2, B2) {
    this.cv.sectoroidFill(O2, A2, B2, []);
  }
  sectoroid(O2, A2, B2, vertices) {
    this.cv.sectoroidFill(O2, A2, B2, vertices);
  }
  rect(A2, C2) {
    let [a2, b2] = A2;
    let [c2, d2] = C2;
    this.pen.polyfill([a2, b2], [c2, b2], [c2, d2], [a2, d2]);
  }
}
class PenShade {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  circle(center, radius) {
    let points = cal.traceCircle(center, radius, [0, 360]);
    this.pen.polyshade(...points);
  }
  sector(O2, A2, B2) {
    this.cv.sectoroidShade(O2, A2, B2, [O2]);
  }
  segment(O2, A2, B2) {
    this.cv.sectoroidShade(O2, A2, B2, []);
  }
  sectoroid(O2, A2, B2, vertices) {
    this.cv.sectoroidShade(O2, A2, B2, vertices);
  }
  rect(A2, C2) {
    let [a2, b2] = A2;
    let [c2, d2] = C2;
    this.pen.polyshade([a2, b2], [c2, b2], [c2, d2], [a2, d2]);
  }
}
class PenLabel {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  point(point, text2 = "", dir2, radius = 15) {
    if (dir2 !== void 0) {
      this.cv.labelPoint(text2, point, dir2, radius);
    } else {
      this.cv.labelPointAuto(text2, point, radius);
    }
  }
  points(points) {
    for (let k2 in points) {
      this.point(points[k2], k2);
    }
  }
  vertices(points) {
    this.cv.save();
    this.pen.set.labelCenter(...Object.values(points));
    this.points(points);
    this.cv.restore();
  }
  angle([A2, O2, B2], text2, dir2 = 0, radius = -1) {
    if (radius < 0) {
      radius = 28 + this.cv.getAngleAllowance(A2, O2, B2, 40, 1.5);
    }
    this.cv.labelAngle(text2, [A2, O2, B2], dir2, radius);
  }
  line([A2, B2], text2, dir2 = 0, radius = 15) {
    this.cv.labelLine(text2, [A2, B2], dir2, radius);
  }
  polygon(points, text2) {
    let pts = this.cv.pjs(points);
    this.cv.labelPoint(String(text2), Mid(...pts), 0, 0);
  }
  coordinates(point, dir2, radius = 15) {
    let [x2, y2] = point;
    x2 = Fix(x2, 1);
    y2 = Fix(y2, 1);
    let text2 = `(${x2}, ${y2})`;
    this.point(point, text2, dir2, radius);
  }
}
class PenAxis {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  x(label = "x") {
    this.cv.xAxis();
    this.cv.xAxisLabel(label);
  }
  y(label = "y") {
    this.cv.yAxis();
    this.cv.yAxisLabel(label);
  }
  xy(xlabel = "x", ylabel = "y") {
    this.x(xlabel);
    this.y(ylabel);
  }
}
class PenTick {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  x(interval2 = 1, mark = true) {
    this.cv.xAxisTick(interval2);
    if (mark)
      this.cv.xAxisTickMark(interval2);
  }
  y(interval2 = 1, mark = true) {
    this.cv.yAxisTick(interval2);
    if (mark)
      this.cv.yAxisTickMark(interval2);
  }
  xy(interval2 = 1, mark = true) {
    this.x(interval2, mark);
    this.y(interval2, mark);
  }
}
class PenGrid {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  x(interval2 = 1) {
    this.cv.xAxisGrid(interval2);
  }
  y(interval2 = 1) {
    this.cv.yAxisGrid(interval2);
  }
  xy(interval2 = 1) {
    this.x(interval2);
    this.y(interval2);
  }
}
class PenLinProg {
  constructor(pen, cv) {
    this.pen = pen;
    this.cv = cv;
  }
  drawConstraints(...constraints2) {
    for (let c2 of toReins(constraints2)) {
      if (c2.canEqual()) {
        this.pen.graph.linear(...c2.toLinear());
      } else {
        this.pen.set.dash(true);
        this.pen.graph.linear(...c2.toLinear());
        this.pen.set.dash();
      }
    }
  }
  shadeConstraints(constraints2) {
    let poly = toReins(constraints2).polygon();
    this.pen.polyshade(...poly);
  }
  verticesCoord(constraints2) {
    let vs = toReins(constraints2).vertices();
    for (let v2 of vs) {
      this.pen.label.coordinates(v2);
    }
  }
}
const DEFAULT_POINT_RADIUS_PIXEL = 2;
const DEFAULT_CUTTER_LENGTH_PIXEL = 5;
class PenCls {
  constructor() {
    this.cv = new Canvas10();
    this.range = new PenRange(this, this.cv);
    this.size = new PenSize(this, this.cv);
    this.set = new PenSettings(this, this.cv);
    this.graph = new PenGraph(this, this.cv);
    this.fill = new PenFill(this, this.cv);
    this.shade = new PenShade(this, this.cv);
    this.linProg = new PenLinProg(this, this.cv);
    this.label = new PenLabel(this, this.cv);
    this.axis = new PenAxis(this, this.cv);
    this.tick = new PenTick(this, this.cv);
    this.grid = new PenGrid(this, this.cv);
    this.d3 = new PenD3(this, this.cv);
    this.range.set([-5, 5], [-5, 5]);
    this.size.set(1);
    this.set.reset();
  }
  plot(func, tStart, tEnd) {
    this.cv.plot(func, tStart, tEnd, 1e3);
  }
  plotDash(func, tStart, tEnd) {
    this.cv.save();
    this.set.dash(true);
    this.cv.plot(func, tStart, tEnd, 1e3);
    this.cv.restore();
  }
  point(position, label) {
    this.cv.disc(position, DEFAULT_POINT_RADIUS_PIXEL);
    if (label !== void 0)
      this.label.point(position, label);
  }
  points(positions) {
    for (let k2 in positions) {
      this.point(positions[k2], k2);
    }
  }
  cutX(position, label) {
    if (typeof position === "number")
      position = [position, 0];
    this.cv.tickVert(position, DEFAULT_CUTTER_LENGTH_PIXEL);
    if (label !== void 0)
      this.label.point(position, label, 270);
  }
  cutY(position, label) {
    if (typeof position === "number")
      position = [0, position];
    this.cv.tickHori(position, DEFAULT_CUTTER_LENGTH_PIXEL);
    if (label !== void 0)
      this.label.point(position, label, 180);
  }
  guideX(point, label) {
    let [x2, y2] = point;
    this.dash([x2, 0], point);
    if (label !== void 0) {
      this.cutX(x2);
      this.label.point([x2, 0], label, y2 >= 0 ? 270 : 90);
    }
  }
  guideY(point, label) {
    let [x2, y2] = point;
    this.dash([0, y2], point);
    if (label !== void 0) {
      this.cutY(y2);
      this.label.point([0, y2], label, x2 >= 0 ? 180 : 0);
    }
  }
  circle(center, radius) {
    this.cv.circle(center, radius);
  }
  disc(center, radius) {
    this.cv.disc(center, radius);
  }
  halo(center, radius) {
    this.cv.halo(center, radius);
  }
  dot(point) {
    this.disc(point, 4);
  }
  hole(point) {
    this.cv.save();
    this.set.color("white");
    this.disc(point, 4);
    this.cv.restore();
    this.circle(point, 4);
  }
  line(A2, B2, label) {
    this.cv.line([A2, B2]);
    if (label !== void 0)
      this.label.line([A2, B2], label);
  }
  dash(A2, B2, label) {
    this.cv.dash([A2, B2]);
    if (label !== void 0)
      this.label.line([A2, B2], label);
  }
  arrow(A2, B2, label) {
    this.cv.arrow(A2, B2, 5);
    if (label !== void 0)
      this.label.line([A2, B2], label);
  }
  arrowCompo(O2, P2, dir2, angleLabel) {
    let X2 = Move(O2, dir2, 1);
    let Q2 = PdFoot(O2, X2, P2);
    this.arrow(O2, Q2);
    if (angleLabel !== void 0)
      this.angle(Q2, O2, P2, angleLabel);
  }
  arrowResolve(O2, P2, dir2, angleLabel) {
    this.arrowCompo(O2, P2, dir2, angleLabel);
    this.arrowCompo(O2, P2, dir2 + 90);
  }
  length(A2, B2, label) {
    this.cv.line([A2, B2]);
    this.cv.tick(A2, B2, 5, 0);
    this.cv.tick(B2, A2, 5, 0);
    if (label !== void 0)
      this.label.line([A2, B2], label);
  }
  height(V2, [A2, B2], label) {
    let F2 = PdFoot(A2, B2, V2);
    this.dash(V2, F2);
    this.rightAngle(A2, F2, V2);
    if (label !== void 0) {
      const c2 = vec2D(V2, A2).cross2D(vec2D(V2, B2));
      if (c2 > 0) {
        this.label.line([V2, F2], label);
      } else {
        this.label.line([F2, V2], label);
      }
    }
  }
  polyline(...points) {
    this.cv.line(points);
  }
  polygon(...points) {
    this.cv.shape(points);
  }
  polyfill(...points) {
    this.cv.fill(points);
  }
  polyshade(...points) {
    this.cv.shade(points);
  }
  polyshape(...points) {
    this.polygon(...points);
    this.polyshade(...points);
  }
  angle(A2, O2, B2, label, arc = 1, radius = -1) {
    if (radius < 0)
      radius = 15 + this.cv.getAngleAllowance(A2, O2, B2, 40, 1.5);
    let space = 3;
    this.cv.angle(A2, O2, B2, radius, arc, space);
    if (label !== void 0 && label !== "")
      this.label.angle([A2, O2, B2], label, void 0, radius < 0 ? radius : radius + 13);
  }
  equalSide(A2, B2, tick = 1) {
    this.cv.equalSide(A2, B2, 5, tick, 3);
  }
  bisectSide(A2, B2, tick = 1) {
    [A2, B2] = this.cv.pjs([A2, B2]);
    let M2 = Mid(A2, B2);
    this.equalSide(A2, M2, tick);
    this.equalSide(B2, M2, tick);
  }
  parallel(A2, B2, tick = 1) {
    this.cv.parallel(A2, B2, 4, tick, 6);
  }
  rightAngle(A2, O2, B2, size = 12) {
    A2 = this.cv.pj(A2);
    O2 = this.cv.pj(O2);
    B2 != null ? B2 : B2 = Rotate(A2, 90, O2);
    B2 = this.cv.pj(B2);
    this.cv.rightAngle(A2, O2, B2, size);
  }
  compass(point) {
    this.cv.compass(point, 17, 20, 3.5);
  }
  write(point, text2) {
    this.cv.write(text2, point);
  }
  background(url) {
    this.cv.backgroundURL = url;
  }
  export(html, placeholder) {
    return this.cv.export(html, placeholder, false);
  }
  exportTrim(html, placeholder) {
    return this.cv.export(html, placeholder, true);
  }
  clear() {
    this.cv.clearImg();
  }
  saveImg() {
    this.cv.saveImg();
  }
  restoreImg() {
    this.cv.restoreImg();
  }
}
class AutoPenCls {
  constructor() {
    this.pen = new Pen();
  }
  export(html, placeholder) {
    return this.pen.exportTrim(html, placeholder);
  }
  PrimeFactorization({ numbers: numbers2 }) {
    function lowestFactor(arr) {
      const primes2 = [2, 3, 5, 7, 11, 13, 17, 19];
      for (let p2 of primes2) {
        if (HCF(...arr) % p2 === 0)
          return p2;
      }
      return 1;
    }
    const pen = new Pen();
    pen.range.set([-10, 10], [-15, 5]);
    pen.size.set(4);
    const w2 = 1;
    const h2 = 1;
    function drawRow(arr, pivot2) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        pen.write([pivot2[0] + i2 * w2, pivot2[1]], arr[i2].toString());
      }
    }
    function drawVert(pivot2) {
      pen.line([pivot2[0] - 0.5 * w2, pivot2[1] - h2 / 2], [pivot2[0] - 0.5 * w2, pivot2[1] + h2 / 2]);
    }
    function drawUnderline(arr, pivot2) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        pen.line([pivot2[0] + i2 * w2 - 0.5 * w2, pivot2[1] - h2 / 2], [pivot2[0] + i2 * w2 + 0.5 * w2, pivot2[1] - h2 / 2]);
      }
    }
    function drawDivisor(pivot2, divisor) {
      pen.write([pivot2[0] - w2, pivot2[1]], divisor.toString());
    }
    function drawDiv(arr, pivot2) {
      const d2 = lowestFactor(arr);
      drawVert(pivot2);
      drawUnderline(arr, pivot2);
      drawDivisor(pivot2, d2);
      arr = arr.map((x2) => x2 / d2);
      pivot2 = [pivot2[0], pivot2[1] - h2];
      drawRow(arr, pivot2);
      return [arr, pivot2];
    }
    let pivot = [1, 0];
    drawRow(numbers2, pivot);
    while (HCF(...numbers2) > 1) {
      [numbers2, pivot] = drawDiv(numbers2, pivot);
    }
    this.pen = pen;
  }
  Inequalities({
    items = [],
    ticks = [],
    scale = 1.6,
    ratio = 0.5
  }) {
    const width = 5;
    const height = 2;
    let ineqs = items.map((x2, i2) => __spreadValues({ base: -i2 * (height + 2) }, x2));
    const pen = new Pen();
    pen.range.set([-width - 2, width + 2], [-ineqs.length * (height + 2) + 2, height + 1]);
    pen.size.set(scale, scale * ratio);
    pen.set.textLatex(true);
    function inequality({ position, sign: sign2, num: num2, base: base2, vertical }) {
      let greater = sign2.includes(">") || sign2.includes("g");
      let solid = sign2.includes("=") || sign2.includes("e");
      let align = -width + 2 * width * position;
      let B2 = [align, base2];
      let T2 = [align, base2 + height];
      let E2 = [greater ? align + 0.4 * width : align - 0.4 * width, base2 + height];
      let E1 = [greater ? width : -width, base2 + height];
      let E22 = [greater ? width : -width, base2];
      if (vertical) {
        pen.set.color("grey");
        pen.set.dash(10);
        pen.graph.vertical(align);
        pen.set.color();
        pen.set.dash();
      }
      pen.polyshade(B2, T2, E1, E22);
      pen.arrow([-width, base2], [width, base2]);
      pen.line(B2, T2);
      pen.arrow(T2, E2);
      solid ? pen.dot(T2) : pen.hole(T2);
      pen.label.point(B2, num2.toString(), 270);
    }
    function tick(position, correct2) {
      let align = -width + 2 * width * position;
      let y2 = -(ineqs.length - 1) * (height + 2) - height / 2;
      pen.write([align, y2], correct2 ? "\u2714" : "\u2718");
    }
    ineqs.forEach((x2) => inequality(x2));
    let cutting = ineqs.map((x2) => x2.position);
    cutting = [0, ...cutting, 1];
    for (let i2 = 0; i2 < ticks.length; i2++) {
      let p2 = (cutting[i2] + cutting[i2 + 1]) / 2;
      tick(p2, ticks[i2]);
    }
    this.pen = pen;
  }
  TrigSolution({
    trig: trig2 = "sin",
    k: k2 = 0,
    scale = 1.4,
    ratio = 0.7
  }) {
    if (trig2 === "sin" || trig2 === "cos") {
      if (k2 > 2)
        k2 = 2;
      if (0.9 < k2 && k2 < 1)
        k2 = 0.9;
      if (0 < k2 && k2 < 0.3)
        k2 = 0.3;
      if (-1 < k2 && k2 < -0.9)
        k2 = -0.9;
      if (-0.3 < k2 && k2 < 0)
        k2 = -0.3;
      if (k2 < -2)
        k2 = -2;
    }
    if (trig2 === "tan") {
      if (k2 > 4)
        k2 = 4;
      if (k2 < -4)
        k2 = -4;
      if (0 < k2 && k2 < 0.9)
        k2 = 0.9;
      if (0 > k2 && k2 > -0.9)
        k2 = -0.9;
    }
    let [a2, b2, c2] = TrigRoot(trig2, k2);
    const pen = new Pen();
    let limit = Max(1, Abs(k2)) + 0.2;
    if (trig2 === "sin")
      pen.range.set([-40, 390], [-limit, limit]);
    if (trig2 === "cos")
      pen.range.set([-40, 390], [-limit, limit]);
    if (trig2 === "tan")
      pen.range.set([-40, 390], [-5, 5]);
    pen.size.set(scale, scale * ratio);
    pen.axis.x();
    pen.axis.y();
    if (trig2 === "sin" || trig2 === "cos") {
      pen.tick.x(360);
    }
    if (trig2 === "tan") {
      pen.tick.x(180);
    }
    if (trig2 === "sin" || trig2 === "cos") {
      pen.cutY([0, 1]);
      pen.cutY([0, -1]);
      pen.label.point([0, 1], "1", 180);
      pen.label.point([0, -1], "-1", 180);
    }
    pen.set.weight(1.5);
    if (trig2 === "sin")
      pen.plot((x2) => sin(x2), 0, 360);
    if (trig2 === "cos")
      pen.plot((x2) => cos(x2), 0, 360);
    if (trig2 === "tan") {
      pen.plot((x2) => tan(x2), 0, 360);
      pen.set.color("grey");
      pen.set.dash([5, 10]);
      pen.set.weight(0.7);
      pen.graph.vertical(90);
      pen.graph.vertical(270);
      pen.set.color();
      pen.set.dash();
      pen.set.weight(1);
    }
    pen.set.weight(1);
    function arrow(x2, y2, func, label = "") {
      if (x2 === void 0)
        return;
      let anchor = 0;
      let skipAnchor = false;
      if (func === "sin") {
        if ([0, 90, 180, 270, 360].includes(x2))
          skipAnchor = true;
        if (x2 > 0 && x2 < 90)
          anchor = 0;
        if (x2 > 90 && x2 < 270)
          anchor = 180;
        if (x2 > 270 && x2 < 360)
          anchor = 360;
      }
      if (func === "cos") {
        if ([0, 90, 180, 270, 360].includes(x2))
          skipAnchor = true;
        if (x2 > 0 && x2 < 180 && x2 !== 90)
          anchor = 0;
        if (x2 > 180 && x2 < 360 && x2 !== 270)
          anchor = 360;
      }
      if (func === "tan") {
        if ([0, 90, 180, 270, 360].includes(x2))
          skipAnchor = true;
        if (x2 > 0 && x2 < 180)
          anchor = 0;
        if (x2 > 180 && x2 < 360)
          anchor = 180;
      }
      let P2 = [x2, y2];
      let Q2 = [x2, 0];
      let R2 = [anchor, 0];
      pen.set.color();
      pen.point(P2);
      pen.set.color("red");
      if (y2 !== 0) {
        pen.arrow(P2, Q2);
      }
      if (y2 >= 0) {
        pen.label.point(Q2, label, 270);
      }
      if (y2 < 0) {
        pen.label.point(Q2, label, 90);
      }
      if (skipAnchor)
        return;
      pen.set.weight(3);
      pen.set.color("blue");
      pen.line(R2, Q2);
      pen.set.weight(1);
      pen.set.color("red");
    }
    pen.set.color("red");
    pen.set.dash([5, 5]);
    pen.graph.horizontal(k2);
    pen.set.dash();
    if (trig2 === "sin") {
      if (k2 === 0) {
        arrow(a2, k2, "sin", "0");
        arrow(b2, k2, "sin", "180");
        arrow(c2, k2, "sin", "360");
      }
      if (k2 === 1) {
        arrow(a2, k2, "sin", "90");
      }
      if (k2 === -1) {
        arrow(a2, k2, "sin", "270");
      }
      if (k2 > -1 && k2 < 1 && k2 !== 0) {
        arrow(a2, k2, "sin", "\u03B1");
        arrow(b2, k2, "sin", "\u03B2");
      }
    }
    if (trig2 === "cos") {
      if (k2 === 0) {
        arrow(a2, k2, "cos", "90");
        arrow(b2, k2, "cos", "270");
      }
      if (k2 === 1) {
        arrow(a2, k2, "cos", "0");
        arrow(b2, k2, "cos", "360");
      }
      if (k2 === -1) {
        arrow(a2, k2, "cos", "180");
      }
      if (k2 > -1 && k2 < 1 && k2 !== 0) {
        arrow(a2, k2, "cos", "\u03B1");
        arrow(b2, k2, "cos", "\u03B2");
      }
    }
    if (trig2 === "tan") {
      if (k2 === 0) {
        arrow(a2, k2, "tan", "0");
        arrow(b2, k2, "tan", "180");
        arrow(c2, k2, "tan", "360");
      }
      if (k2 !== 0) {
        arrow(a2, k2, "tan", "\u03B1");
        arrow(b2, k2, "tan", "\u03B2");
      }
    }
    this.pen = pen;
  }
  QuadraticInequality({
    quadratic,
    sign: sign2,
    scale = 1,
    ratio = 0.8
  }) {
    let a2 = quadratic[0];
    let b2 = quadratic[1];
    let c2 = quadratic[2];
    let greater = sign2.includes(">") || sign2.includes("g");
    let equal2 = sign2.includes("=") || sign2.includes("e");
    let p2;
    let q2;
    try {
      [p2, q2] = QuadraticRoot(a2, b2, c2);
    } catch {
      [p2, q2] = [void 0, void 0];
    }
    if (p2 !== void 0 && q2 !== void 0) {
      [p2, q2] = [Max(p2, q2), Min(p2, q2)];
      p2 = Fix(p2, 2);
      q2 = Fix(q2, 2);
    }
    const pen = new Pen();
    pen.range.set([-5, 5], [-5, 5]);
    pen.size.set(scale, scale * ratio);
    pen.set.textLatex(true);
    pen.axis.x("");
    if (p2 !== void 0 && q2 !== void 0 && p2 !== q2) {
      pen.plot((x2) => Sign(a2) * (x2 ** 2 - 4));
      let P2 = [2, 0];
      let Q2 = [-2, 0];
      pen.cutX(P2);
      pen.cutX(Q2);
      pen.set.weight(3);
      pen.set.color("red");
      if (a2 > 0) {
        if (greater) {
          pen.plot((x2) => Sign(a2) * (x2 ** 2 - 4), -5, -2);
          pen.plot((x2) => Sign(a2) * (x2 ** 2 - 4), 2, 5);
        } else {
          pen.plot((x2) => Sign(a2) * (x2 ** 2 - 4), -2, 2);
        }
      }
      if (a2 < 0) {
        if (greater) {
          pen.plot((x2) => Sign(a2) * (x2 ** 2 - 4), -2, 2);
        } else {
          pen.plot((x2) => Sign(a2) * (x2 ** 2 - 4), -5, -2);
          pen.plot((x2) => Sign(a2) * (x2 ** 2 - 4), 2, 5);
        }
      }
      pen.set.weight();
      pen.set.color();
      pen.label.point(P2, p2.toString(), a2 > 0 ? 315 : 45);
      pen.label.point(Q2, q2.toString(), a2 > 0 ? 225 : 135);
    }
    if (p2 === void 0 && q2 === void 0) {
      if (a2 > 0 && greater || a2 < 0 && !greater) {
        pen.set.weight(3);
        pen.set.color("red");
      }
      if (a2 > 0)
        pen.plot((x2) => x2 ** 2 + 2);
      if (a2 < 0)
        pen.plot((x2) => -(x2 ** 2) - 2);
    }
    if (p2 !== void 0 && q2 !== void 0 && p2 === q2) {
      let func = a2 > 0 ? (x2) => x2 ** 2 : (x2) => -(x2 ** 2);
      pen.plot(func);
      pen.label.point([0, 0], p2.toString(), a2 > 0 ? 270 : 90);
      if (a2 > 0) {
        pen.set.weight(3);
        pen.set.color("red");
        if (greater && equal2)
          pen.plot(func);
        if (greater && !equal2) {
          pen.plot(func);
          pen.set.color();
          pen.hole([0, 0]);
        }
        if (!greater && equal2) {
          pen.set.color("red");
          pen.dot([0, 0]);
        }
      }
      if (a2 < 0) {
        pen.set.weight(3);
        pen.set.color("red");
        if (!greater && equal2)
          pen.plot(func);
        if (!greater && !equal2) {
          pen.plot(func);
          pen.set.color();
          pen.hole([0, 0]);
        }
        if (greater && equal2) {
          pen.set.color("red");
          pen.dot([0, 0]);
        }
      }
    }
    this.pen = pen;
  }
  Triangle({
    vertices,
    triangle = {},
    labels = ["", "", ""],
    heights = [false, false, false],
    scale = 1.6
  }) {
    let A2 = vertices[0];
    let B2 = vertices[1];
    let C2 = vertices[2];
    let xmax = Math.max(A2[0], B2[0], C2[0]);
    let xmin = Math.min(A2[0], B2[0], C2[0]);
    let xmid = (xmax + xmin) / 2;
    let ymax = Math.max(A2[1], B2[1], C2[1]);
    let ymin = Math.min(A2[1], B2[1], C2[1]);
    let ymid = (ymax + ymin) / 2;
    let dx = xmax - xmin;
    let dy = ymax - ymin;
    let dmax = Math.max(dx, dy) * 0.8;
    let G2 = Mid(A2, B2, C2);
    let T2 = triangle;
    let sideA = T2.sideA;
    let sideB = T2.sideB;
    let sideC = T2.sideC;
    let angleA = T2.angleA;
    let angleB = T2.angleB;
    let angleC = T2.angleC;
    let labelA = labels[0];
    let labelB = labels[1];
    let labelC = labels[2];
    const pen = new Pen();
    pen.range.set([xmid - dmax, xmid + dmax], [ymid - dmax, ymid + dmax]);
    pen.size.set(scale);
    function drawHeight(vertex, base2) {
      let F2 = PdFoot(base2[0], base2[1], vertex);
      pen.set.dash([5, 5]);
      pen.set.color("grey");
      pen.line(vertex, F2);
      if (F2[0] === base2[0][0] && F2[1] === base2[0][1]) {
        pen.line(F2, base2[1]);
      } else {
        pen.line(F2, base2[0]);
      }
      pen.set.dash();
      if (F2[0] === base2[0][0] && F2[1] === base2[0][1]) {
        pen.rightAngle(vertex, F2, base2[1]);
      } else {
        pen.rightAngle(vertex, F2, base2[0]);
      }
      pen.set.color();
    }
    if (heights[0])
      drawHeight(A2, [B2, C2]);
    if (heights[1])
      drawHeight(B2, [C2, A2]);
    if (heights[2])
      drawHeight(C2, [A2, B2]);
    pen.polygon(A2, B2, C2);
    pen.set.textItalic(true);
    if (labelA)
      pen.label.point(A2, labelA.toString(), Dir(G2, A2));
    if (labelB)
      pen.label.point(B2, labelB.toString(), Dir(G2, B2));
    if (labelC)
      pen.label.point(C2, labelC.toString(), Dir(G2, C2));
    pen.set.textItalic();
    let AB = [B2[0] - A2[0], B2[1] - A2[1]];
    let BC = [C2[0] - B2[0], C2[1] - B2[1]];
    let anticlockwise = AB[0] * BC[1] - AB[1] * BC[0] > 0;
    function writeSide(side2, start, end) {
      if (side2) {
        if (typeof side2 === "string" && !/\d/.test(side2))
          pen.set.textItalic(true);
        if (anticlockwise) {
          pen.label.line([start, end], side2.toString());
        } else {
          pen.label.line([end, start], side2.toString());
        }
        pen.set.textItalic();
      }
    }
    writeSide(sideC, A2, B2);
    writeSide(sideA, B2, C2);
    writeSide(sideB, C2, A2);
    function writeAngle(angle2, P2, O2, Q2) {
      if (angle2) {
        if (typeof angle2 === "string")
          pen.set.textItalic(true);
        if (typeof angle2 === "number")
          angle2 = angle2 + "\xB0";
        pen.angle(P2, O2, Q2, angle2);
        pen.set.textItalic();
      }
    }
    writeAngle(angleA, B2, A2, C2);
    writeAngle(angleB, C2, B2, A2);
    writeAngle(angleC, A2, C2, B2);
    this.pen = pen;
  }
  LinearProgram({
    constraints: constraints2 = [],
    field: field2 = [0, 0, 0],
    contours = [],
    labelConstraints = [],
    highlights = [],
    ranges = [[-10, 10], [-10, 10]],
    resolution = 0.2,
    grid = 0,
    subGrid = 0,
    tick = 0,
    showLine = true,
    showShade = true,
    showVertex = false,
    showVertexCoordinates = false,
    showVertexLabel = false,
    showVertexMax = false,
    showVertexMin = false,
    showIntegral = false,
    showIntegralLabel = false,
    showIntegralMax = false,
    showIntegralMin = false,
    contourColor = "grey",
    constraintColors = []
  }) {
    function fieldAt(p2) {
      const [a2, b2, c2] = field2;
      const [x2, y2] = p2;
      return Fix(a2 * x2 + b2 * y2 + c2, 1);
    }
    let vertices = FeasiblePolygon(...constraints2);
    let integrals = [];
    if (showIntegral || showIntegralMax || showIntegralMin) {
      integrals = FeasibleIntegral(...constraints2);
    }
    const pen = new Pen();
    let [[xmin, xmax], [ymin, ymax]] = ranges;
    let bound = 0.7;
    xmin -= bound;
    xmax += bound;
    ymin -= bound;
    ymax += bound;
    pen.range.set([xmin, xmax], [ymin, ymax]);
    pen.size.resolution(resolution);
    pen.axis.x("");
    pen.axis.y("");
    if (grid > 0) {
      pen.set.alpha(0.6);
      pen.grid.x(grid);
      pen.grid.y(grid);
      pen.set.alpha();
    }
    if (subGrid > 0) {
      pen.set.alpha(0.4);
      pen.grid.x(grid);
      pen.grid.y(grid);
      pen.set.alpha();
    }
    if (tick > 0) {
      pen.set.color("grey");
      pen.set.textSize(0.8);
      pen.tick.x(tick);
      pen.tick.y(tick);
      pen.set.color();
      pen.set.textSize();
    }
    function drawLines() {
      var _a;
      for (let i2 = 0; i2 < constraints2.length; i2++) {
        let [a2, b2, s2, c2] = constraints2[i2];
        if (!ineq(s2).canEqual())
          pen.set.dash([5, 5]);
        pen.set.color((_a = constraintColors[i2]) != null ? _a : "black");
        pen.graph.linear(a2, b2, -c2);
        pen.set.color();
        pen.set.dash();
      }
    }
    labelConstraints.push((x2, y2) => x2 > xmin);
    labelConstraints.push((x2, y2) => x2 < xmax);
    labelConstraints.push((x2, y2) => y2 > ymin);
    labelConstraints.push((x2, y2) => y2 < ymax);
    function labelField(p2) {
      pen.set.textAlign("left");
      pen.label.point(p2, fieldAt(p2).toString(), 60, 10);
      pen.set.textAlign();
    }
    function drawIntegral(label = false) {
      integrals.forEach((p2) => {
        pen.point(p2);
        if (label && labelConstraints.every((f2) => f2(...p2)))
          labelField(p2);
      });
    }
    function drawVertex(coordinates = false, label = false) {
      vertices.forEach((p2) => {
        pen.point(p2);
        if (coordinates)
          pen.label.coordinates(p2, 270);
        if (label && labelConstraints.every((f2) => f2(...p2)))
          labelField(p2);
      });
    }
    function drawShade() {
      pen.polyshade(...vertices);
    }
    function drawContour(value) {
      pen.graph.linear(field2[0], field2[1], field2[2] - value);
    }
    function drawContours(color = contourColor) {
      pen.set.color(color);
      contours.forEach(drawContour);
      pen.set.color();
    }
    function drawHighlight({
      point = [0, 0],
      color = "red",
      circle = true,
      contour = true,
      coordinates = true,
      label = true
    }) {
      pen.set.color(color);
      pen.point(point);
      if (circle)
        pen.circle(point, 5);
      if (contour)
        drawContour(fieldAt(point));
      if (coordinates)
        pen.label.coordinates(point, 270);
      if (label)
        labelField(point);
      pen.set.color();
    }
    function drawHighlights() {
      highlights.forEach((h2) => drawHighlight(h2));
    }
    if (showLine)
      drawLines();
    if (showIntegral)
      drawIntegral(showIntegralLabel);
    if (showShade)
      drawShade();
    if (showVertex)
      drawVertex(showVertexCoordinates, showVertexLabel);
    drawHighlights();
    drawContours();
    if (showVertexMax)
      drawHighlight({
        point: MaximizePoint(vertices, field2),
        color: "red"
      });
    if (showVertexMin)
      drawHighlight({
        point: MinimizePoint(vertices, field2),
        color: "blue"
      });
    if (showIntegralMax)
      drawHighlight({
        point: MaximizePoint(integrals, field2),
        color: "red"
      });
    if (showIntegralMin)
      drawHighlight({
        point: MinimizePoint(integrals, field2),
        color: "blue"
      });
    this.pen = pen;
  }
  DotPattern({ a: a2, p: p2, q: q2, n: n2, offset }) {
    const pen = new Pen();
    pen.range.set([-2, 30], [-4, 10]);
    pen.size.resolution(0.08);
    function drawRow(n22, j2, offset2 = 0) {
      for (let i2 = 1 + offset2; i2 <= n22 + offset2; i2++) {
        pen.point([i2, j2]);
      }
    }
    drawRow(a2 + (n2 - 1) * p2, 1);
    for (let j2 = 2; j2 <= n2; j2++) {
      drawRow(q2 + (n2 - j2) * p2, j2, (j2 - 1) * offset);
    }
    let m2 = "";
    if (n2 === 1)
      m2 = "1st";
    if (n2 === 2)
      m2 = "2nd";
    if (n2 === 3)
      m2 = "3rd";
    if (n2 >= 3)
      m2 = n2 + "th";
    pen.write([(1 + a2 + (n2 - 1) * p2) / 2, -1], m2 + " pattern");
    this.pen = pen;
  }
  PieChart({ categories, labels, angles, angleLabels, size = 2 }) {
    var _a;
    const pen = new Pen();
    pen.range.set([-1.2, 1.2], [-1.2, 1.2]);
    pen.size.set(size);
    pen.graph.circle([0, 0], 1);
    pen.set.angle("polar");
    let O2 = [0, 0];
    pen.line(O2, [1, 0]);
    let current = 0;
    for (let i2 = 0; i2 < angles.length; i2++) {
      let a2 = angles[i2];
      let next = current + a2;
      let mid2 = current + a2 / 2;
      pen.line(O2, PolToRect([1, next]));
      if (categories[i2] === "") {
        pen.write(PolToRect([0.7, mid2]), labels[i2]);
      } else if (labels[i2] === "") {
        pen.write(PolToRect([0.7, mid2]), categories[i2]);
      } else {
        pen.label.point(PolToRect([0.7, mid2]), categories[i2], 90, 10);
        pen.label.point(PolToRect([0.7, mid2]), labels[i2], 270, 10);
      }
      if (angleLabels[i2] !== void 0) {
        pen.angle(PolToRect([1, current]), O2, PolToRect([1, next]), (_a = angleLabels[i2]) != null ? _a : angles[i2] + "\xB0");
      }
      current += a2;
    }
    this.pen = pen;
  }
  HeightChart({
    categories,
    data: data2,
    xLabel = "",
    yLabel = "",
    interval: interval2 = 5,
    subInterval = 1,
    barWidth = 1,
    barGap = 1,
    showBar = false,
    showLine = false
  }) {
    const pen = new Pen();
    let endGap = barWidth + barGap / 2;
    let width = endGap + categories.length * (barWidth + barGap) + endGap;
    let max2 = Max(...data2);
    let maxUnit = Ceil(max2 / interval2);
    let maxSubUnit = maxUnit * (interval2 / subInterval);
    let height = maxUnit * interval2 * 1.1;
    pen.range.set([-width * 0.5, width], [-height, height]);
    pen.size.resolution(0.2, 1.4 / height);
    pen.line([0, 0], [width, 0]);
    pen.arrow([0, 0], [0, height]);
    pen.set.textDir(90);
    pen.write([-1.5, height / 2], yLabel);
    pen.set.textDir();
    pen.label.point([width / 2, 0], xLabel, 270, 40);
    function grid(y2) {
      pen.line([0, y2], [width, y2]);
    }
    for (let y2 = 1; y2 <= maxUnit; y2++) {
      let h2 = y2 * interval2;
      pen.set.alpha(0.2);
      grid(h2);
      pen.cutY([0, h2]);
      pen.set.alpha();
      pen.label.point([0, h2], h2.toString(), 180);
    }
    for (let y2 = 1; y2 <= maxSubUnit; y2++) {
      pen.set.alpha(0.1);
      grid(y2 * subInterval);
      pen.set.alpha();
    }
    function bar(x2, w2, h2) {
      pen.set.color("grey");
      pen.polyfill([x2, 0], [x2, h2], [x2 + w2, h2], [x2 + w2, 0]);
      pen.set.color();
      pen.polygon([x2, 0], [x2, h2], [x2 + w2, h2], [x2 + w2, 0]);
    }
    function writeCat(x2, w2, text2) {
      pen.label.point([x2 + w2 / 2, 0], text2, 270, 15);
    }
    if (showBar) {
      for (let i2 = 0; i2 < categories.length; i2++) {
        let x2 = endGap + i2 * (barWidth + barGap) + barGap / 2;
        bar(x2, barWidth, data2[i2]);
        writeCat(x2, barWidth, categories[i2]);
      }
    }
    if (showLine) {
      let points = [];
      for (let i2 = 0; i2 < categories.length; i2++) {
        let x2 = endGap + i2 * (barWidth + barGap) + barGap / 2;
        let p2 = [x2 + barWidth / 2, data2[i2]];
        pen.point(p2);
        points.push(p2);
        writeCat(x2, barWidth, categories[i2]);
      }
      pen.set.weight(2);
      pen.polyline(...points);
      pen.set.weight();
    }
    this.pen = pen;
  }
  Boxplot({
    summary = [0, 0, 0, 0, 0],
    labels = [null, null, null, null, null],
    size = 2,
    tick = 1,
    start,
    end,
    showDash = false,
    showValue = false,
    showTick = false
  }) {
    var _a, _b, _c, _d, _e;
    const pen = new Pen();
    let [Q0, Q1, Q2, Q3, Q4] = summary;
    let height = showDash ? 1 : 0.5;
    let thickness = 1;
    let b2 = height;
    let t2 = b2 + thickness;
    let m2 = (b2 + t2) / 2;
    let L2 = [Q0, m2];
    let R2 = [Q4, m2];
    let A1 = [Q1, t2];
    let A2 = [Q1, b2];
    let Am = [Q1, m2];
    let B1 = [Q2, t2];
    let B2 = [Q2, b2];
    let C1 = [Q3, t2];
    let C2 = [Q3, b2];
    let Cm = [Q3, m2];
    let L_ = [Q0, 0];
    let R_ = [Q4, 0];
    let A_ = [Q1, 0];
    let B_ = [Q2, 0];
    let C_ = [Q3, 0];
    start != null ? start : start = Q0 - (Q4 - Q0) * 0.2;
    end != null ? end : end = Q4 + (Q4 - Q0) * 0.2;
    pen.range.set([start, end], [-(t2 + 1), t2 + 1]);
    pen.size.set(size, 1);
    if (showTick) {
      pen.tick.x(tick);
    }
    pen.axis.x("");
    pen.polygon(A1, A2, C2, C1);
    pen.line(B1, B2);
    pen.line(L2, Am);
    pen.line(R2, Cm);
    if (showDash) {
      pen.dash(L2, L_);
      pen.dash(A2, A_);
      pen.dash(B2, B_);
      pen.dash(C2, C_);
      pen.dash(R2, R_);
    }
    if (showValue) {
      pen.cutX(L_);
      pen.label.point(L_, (_a = labels[0]) != null ? _a : String(Q0), 270);
      pen.cutX(A_);
      pen.label.point(A_, (_b = labels[1]) != null ? _b : String(Q1), 270);
      pen.cutX(B_);
      pen.label.point(B_, (_c = labels[2]) != null ? _c : String(Q2), 270);
      pen.cutX(C_);
      pen.label.point(C_, (_d = labels[3]) != null ? _d : String(Q3), 270);
      pen.cutX(R_);
      pen.label.point(R_, (_e = labels[4]) != null ? _e : String(Q4), 270);
    }
    this.pen = pen;
  }
  RegularPolygon({
    side: side2,
    diagonal = false,
    reflectional = false,
    rotational = false
  }) {
    const pen = new Pen();
    pen.range.square(1.3);
    pen.size.set(1.5);
    let gon = RegularPolygon(side2, [0, 0], 1, 0);
    pen.polygon(...gon);
    if (diagonal) {
      pen.set.alpha(0.3);
      for (let i2 = 0; i2 < side2; i2++) {
        for (let j2 = i2 + 1; j2 < side2; j2++) {
          pen.line(gon[i2], gon[j2]);
        }
      }
      pen.set.alpha();
    }
    if (reflectional) {
      pen.set.alpha(0.5);
      pen.set.dash(true);
      if (side2 % 2 === 0) {
        pen.set.color("red");
        for (let n2 = 0; n2 < side2; n2 += 2) {
          pen.graph.through([0, 0], PolToRect([1, n2 * 180 / side2]));
        }
        pen.set.color("blue");
        for (let n2 = 1; n2 < side2; n2 += 2) {
          pen.graph.through([0, 0], PolToRect([1, n2 * 180 / side2]));
        }
      } else {
        for (let n2 = 0; n2 < side2; n2++) {
          pen.graph.through([0, 0], PolToRect([1, n2 * 180 / side2]));
        }
      }
      pen.set.alpha();
      pen.set.dash();
    }
    if (rotational) {
      for (let i2 = 0; i2 < side2; i2++) {
        pen.line(gon[i2], [0, 0]);
      }
    }
    this.pen = pen;
  }
  TreeDiagram({
    titles,
    probabilities,
    events,
    select,
    circleSize
  }) {
    const pen = new Pen();
    pen.range.set([-5, 15], [-12, 12]);
    pen.size.resolution(0.12);
    function path2(P2, Q2, prob2, event, selected, circle) {
      let T2 = MoveX(Q2, 2);
      pen.write(T2, event);
      pen.line(P2, Q2, prob2);
      if (selected) {
        pen.set.weight(3);
        pen.line(P2, Q2, prob2);
        if (circle)
          pen.halo(T2, circleSize != null ? circleSize : 30);
        pen.set.weight();
      }
    }
    function branch(C2, w2, h1, h2, prob2, [eventA, eventB], [selectedA, selectedB], circle, [title, titleHeight] = ["", 0]) {
      let D2 = MoveX(C2, w2);
      let probA;
      let probB;
      if (typeof prob2 === "number") {
        probA = String(Round(prob2, 5));
        probB = String(Round(1 - prob2, 5));
      } else {
        probA = prob2[0];
        probB = prob2[1];
      }
      let A1 = MoveY(C2, h1);
      let A2 = MoveY(D2, h2);
      path2(A1, A2, probA, eventA, selectedA, circle);
      let B1 = MoveY(C2, -h1);
      let B2 = MoveY(D2, -h2);
      path2(B1, B2, probB, eventB, selectedB, circle);
      if (title && titleHeight) {
        let M2 = Mid(C2, D2);
        let T2 = MoveY(M2, titleHeight);
        pen.write(T2, title);
      }
    }
    let s1 = select.includes(1);
    let s2 = select.includes(2);
    let s3 = select.includes(3);
    let s4 = select.includes(4);
    let [t1, t2] = titles;
    let [[p00], [p10, p11]] = probabilities;
    let [[e00], [e10, e11]] = events;
    branch([0, 0], 2, 2, 4, p00, e00, [s1 || s2, s3 || s4], false, [t1, 8]);
    branch([6, 4], 3, 1, 2, p10, e10, [s1, s2], true, [t2, 5]);
    branch([6, -4], 3, 1, 2, p11, e11, [s3, s4], true);
    this.pen = pen;
  }
}
class PhyPenCls {
  constructor() {
    this.pen = new Pen();
  }
  export(html, placeholder) {
    return this.pen.exportTrim(html, placeholder);
  }
  Projectile({
    speed,
    angle: angle2 = 0,
    time,
    arrowScale = 0.5,
    ground = false
  }) {
    let pen = new Pen();
    let ux = speed * cos(angle2);
    let uy = speed * sin(angle2);
    time != null ? time : time = 2 * uy / 9.81;
    let x2 = (t2) => ux * t2;
    let y2 = (t2) => uy * t2 - 0.5 * 9.81 * t2 * t2;
    let O2 = [0, 0];
    let U2 = [ux * arrowScale, uy * arrowScale];
    let P2 = [x2(time), y2(time)];
    pen.range.capture(O2, U2, P2);
    pen.size.lock(1.5);
    pen.disc(O2, 5);
    pen.arrow(O2, U2);
    pen.set.color("grey");
    pen.plotDash((t2) => [x2(t2), y2(t2)], 0, time);
    pen.circle(P2, 5);
    if (ground) {
      pen.graph.horizontal(0);
    }
    this.pen = pen;
  }
  CarOnBankedRoad({
    carMid = 10,
    carWidth = 3,
    wheelHeight = 1,
    carHeight = 2,
    angle: angle2 = 25,
    angleLabel = "\u03B8",
    weight = 4,
    weightLabel = "mg",
    normal = 5,
    normalLabel = "R",
    friction = 0,
    frictionLabel = "f",
    showAllForces = false
  }) {
    let O2 = [0, 0];
    let l2 = carMid - carWidth / 2;
    let r2 = carMid + carWidth / 2;
    let A2 = [l2, 0];
    let B2 = [r2, 0];
    let P2 = MoveY(A2, wheelHeight);
    let Q2 = MoveY(P2, carHeight);
    let R2 = MoveY(B2, wheelHeight);
    let S2 = MoveY(R2, carHeight);
    [A2, B2, P2, Q2, R2, S2] = [A2, B2, P2, Q2, R2, S2].map(($) => Rotate($, angle2, O2));
    let Z2 = [2 * r2, 0];
    let Y2 = Rotate(Z2, angle2, O2);
    let G2 = Mid(P2, Q2, R2, S2);
    let W2 = MoveY(G2, -weight);
    let N2 = Move(G2, 90 + angle2, normal);
    let g2 = friction > 0 ? A2 : B2;
    let f2 = Move(g2, friction > 0 ? 180 + angle2 : angle2, Math.abs(friction));
    let pen = new Pen();
    pen.range.capture(O2, A2, B2, P2, Q2, R2, S2, N2, f2);
    pen.size.lock(1.3);
    pen.set.labelCenter(G2);
    pen.set.textLatex(true);
    pen.polygon(P2, Q2, S2, R2);
    pen.line(O2, Z2);
    pen.line(O2, Y2);
    pen.angle(Y2, O2, Z2, angleLabel);
    pen.set.weight(4);
    pen.line(A2, P2);
    pen.line(B2, R2);
    if (showAllForces) {
      pen.set.weight(3);
      pen.set.color("red");
      pen.set.lineLabel("left");
      pen.arrow(G2, W2, weightLabel);
      pen.set.lineLabel();
      pen.set.weight(3);
      pen.set.color("purple");
      pen.arrow(G2, N2);
      pen.label.point(N2, normalLabel);
      pen.set.weight(2);
      pen.arrowResolve(G2, N2, 90, angleLabel);
      if (friction !== 0) {
        pen.set.weight(3);
        pen.set.color("blue");
        pen.arrow(g2, f2);
        pen.label.point(f2, frictionLabel);
        pen.set.weight(2);
        pen.arrowResolve(g2, f2, 0, angleLabel);
      }
    }
    this.pen = pen;
  }
  AirplaneTurning({
    wingWidth = 7,
    planeRadius = 1,
    angle: angle2 = 35,
    angleLabel = "\u03B8",
    weight = 4,
    weightLabel = "mg",
    lift = 5,
    liftLabel = "L",
    showAllForces = false
  }) {
    let O2 = [0, 0];
    let P2 = [-wingWidth, 0];
    let Q2 = [+wingWidth, 0];
    [P2, Q2] = [P2, Q2].map(($) => Rotate($, angle2, O2));
    let W2 = MoveY(O2, -weight);
    let N2 = Move(O2, 90 + angle2, lift);
    let pen = new Pen();
    pen.range.capture(P2, Q2, W2, N2);
    pen.size.lock(1.3);
    pen.set.labelCenter(O2);
    pen.set.textLatex(true);
    pen.graph.circle(O2, planeRadius);
    pen.shade.circle(O2, planeRadius);
    pen.set.weight(3);
    pen.line(P2, Q2);
    pen.set.weight();
    pen.set.dash(true);
    pen.graph.horizontal(0);
    pen.set.dash();
    pen.angle(Q2, O2, [1, 0], angleLabel);
    if (showAllForces) {
      pen.set.weight(3);
      pen.set.color("red");
      pen.set.lineLabel("left");
      pen.arrow(O2, W2, weightLabel);
      pen.set.lineLabel();
      pen.set.weight(3);
      pen.set.color("purple");
      pen.arrow(O2, N2);
      pen.label.point(N2, liftLabel);
      pen.set.weight(2);
      pen.arrowResolve(O2, N2, 90, angleLabel);
    }
    this.pen = pen;
  }
  ConicalPendulum({
    bobRadius = 1,
    length = 15,
    angle: angle2 = 50,
    angleLabel = "\u03B8",
    weight = 7,
    weightLabel = "mg",
    tension = 10,
    tensionLabel = "T",
    showAllForces = false
  }) {
    let O2 = [0, 0];
    let P2 = Rotate([0, -length], angle2, O2);
    let V2 = [0, P2[1]];
    let W2 = MoveY(P2, -weight);
    let T2 = Move(P2, 90 + angle2, tension);
    let pen = new Pen();
    pen.set.border(0.3);
    pen.range.capture(O2, P2, V2, ReflectY(P2), W2);
    pen.size.lock(1.3);
    pen.set.textLatex(true);
    pen.set.color("grey");
    pen.plotDash((t2) => [P2[0] * cos(t2) + V2[0], 1 * sin(t2) + V2[1]], 0, 360);
    pen.set.color();
    pen.dash(O2, V2);
    pen.line(O2, P2);
    pen.fill.circle(P2, bobRadius);
    pen.angle(P2, O2, V2, angleLabel);
    if (showAllForces) {
      pen.set.color("red");
      pen.set.weight(3);
      pen.arrow(P2, W2, weightLabel);
      pen.set.color("blue");
      pen.arrow(P2, T2);
      pen.set.weight(2);
      pen.arrowResolve(P2, T2, 90, angleLabel);
      pen.set.weight();
      pen.label.point(T2, tensionLabel);
    }
    this.pen = pen;
  }
  SatelliteOrbit({
    planetRadius = 1.3,
    orbitRadius = 2,
    angle: angle2 = 30,
    showHeight = false
  }) {
    let pen = new Pen();
    let O2 = [0, 0];
    let P2 = PolToRect([orbitRadius, angle2]);
    let Q2 = PolToRect([orbitRadius, -angle2]);
    let A2 = [-planetRadius, 0];
    let B2 = PolToRect([planetRadius, angle2]);
    let C2 = [0, -planetRadius];
    pen.range.capture([O2, orbitRadius]);
    pen.size.set(1.2);
    pen.shade.circle(O2, planetRadius);
    pen.graph.circle(O2, planetRadius);
    pen.label.point(C2, "M", 270);
    pen.point(P2, "m");
    pen.point(O2);
    if (showHeight) {
      pen.set.color("red");
      pen.line(B2, P2, "h");
    }
    pen.set.color("blue");
    pen.line(O2, Q2, "r");
    pen.set.color("grey");
    pen.line(O2, A2, "R");
    pen.set.color();
    pen.set.dash(true);
    pen.graph.circle(O2, orbitRadius);
    this.pen = pen;
  }
}
globalThis.Pen = PenCls;
globalThis.AutoPen = AutoPenCls;
globalThis.PhyPen = PhyPenCls;
class QuestionHTML {
  constructor(html = "") {
    this.body = new DOMParser().parseFromString(html, "text/html").getElementsByTagName("body")[0];
  }
  export() {
    return this.body.innerHTML;
  }
  get li() {
    return [...this.body.getElementsByTagName("li")];
  }
  get ul() {
    return this.body.getElementsByTagName("ul")[0];
  }
  cloneLi(sourceIndex, repeat = 1) {
    for (let i2 = 1; i2 <= repeat; i2++) {
      this.ul.appendChild(this.li[sourceIndex].cloneNode(true));
    }
  }
  printInWhole(symbol, value) {
    this.body.innerHTML = PrintVariable(this.body.innerHTML, symbol, value);
  }
  printInLi(index, symbol, value) {
    let li = this.li[index];
    li.innerHTML = PrintVariable(li.innerHTML, symbol, value);
  }
  isLiDuplicated() {
    let htmls = this.li.map((x2) => x2.innerHTML.replace(/\s+/g, ""));
    return new Set(htmls).size !== htmls.length;
  }
  shuffleLi(shuffle2 = true) {
    let oldHTMLs = this.li.map((x2) => x2.innerHTML);
    let newHTMLs;
    if (shuffle2) {
      newHTMLs = RndShuffle(...oldHTMLs);
    } else {
      newHTMLs = [...oldHTMLs];
    }
    for (let i2 = 0; i2 < newHTMLs.length; i2++) {
      this.li[i2].innerHTML = newHTMLs[i2];
    }
    return oldHTMLs.map((x2) => newHTMLs.indexOf(x2));
  }
}
function PrintVariable(html, symbol, value) {
  let print = (signal, prefix, suffix = "") => {
    html = html.replace(new RegExp(prefix + symbol + suffix, "g"), () => ParseForPrint(value, signal));
  };
  print("*", "\\*\\*");
  print("/", "\\*\\/");
  print("//", "\\*\\/\\/");
  print("/()", "\\*\\/\\(", "\\)");
  print("()", "\\*\\(", "\\)");
  print("!", "\\*\\!");
  print("||", "\\*\\|", "\\|");
  print("+", "\\*\\^\\+\\_");
  print("-", "\\*\\^\\-\\_");
  print(">", "\\*\\^\\\\gt\\_");
  print("<", "\\*\\^\\\\lt\\_");
  print(">=", "\\*\\^\\\\ge\\_");
  print("<=", "\\*\\^\\\\le\\_");
  print("%", "\\*\\%");
  print("\\%", "\\*\\\\\\%");
  print(":", "\\*\\:");
  print("", "\\*");
  print("|.", "\\*\\|\\.");
  print(".", "\\*\\.");
  print("=", "\\*\\=");
  print("==", "\\*\\=\\=");
  print("=.", "\\*\\=\\.");
  print("==.", "\\*\\=\\=\\.");
  return html;
}
function numberDefault(num2) {
  let v2 = num2;
  if (owl.zero(v2))
    return 0;
  if (IsInteger(v2)) {
    v2 = Fix(v2, 0);
  } else {
    v2 = Math.abs(v2) > 100 ? Fix(v2, 2) : Round(v2, 5);
  }
  return v2;
}
function ParseForPrint(value, signal = "") {
  let T2 = typeof value;
  if (signal === "") {
    if (T2 === "number") {
      return String(numberDefault(value));
    }
    if (T2 === "boolean") {
      return value ? "\u2714" : "\u2718";
    }
    if (owl.quantity(value)) {
      let { val, unit } = value;
      return String(numberDefault(val)) + unit;
    }
    if (owl.point2D(value)) {
      return Coord(value);
    }
    if (owl.combo(value)) {
      return ink.printCombo(value);
    }
    if (owl.polynomial(value)) {
      return PolyPrint(value);
    }
    if (owl.trigValue(value)) {
      return ink.printTrigValue(value);
    }
    if (owl.trigExp(value)) {
      return ink.printTrigExp(value);
    }
    if (owl.constraint(value)) {
      return ink.printConstraint(value);
    }
    if (owl.constraints(value)) {
      return ink.printConstraints(value);
    }
  }
  if (signal === "*") {
    if (T2 === "number") {
      let v2 = cal.blur(Round(value, 3));
      let abs2 = Math.abs(v2);
      return String(abs2 >= 1e4 || abs2 <= 0.01 ? Sci(v2) : v2);
    }
    if (owl.quantity(value)) {
      let { val, unit } = value;
      let v2 = cal.blur(Round(val, 3));
      let abs2 = Math.abs(v2);
      return String(abs2 >= 1e4 || abs2 <= 0.01 ? Sci(v2) : v2) + unit;
    }
  }
  if (signal === "/") {
    if (T2 === "number") {
      let [p2, q2] = ToFrac(value);
      return Dfrac(p2, q2);
    }
  }
  if (signal === "/()") {
    if (T2 === "number") {
      let [p2, q2] = ToFrac(value);
      if (q2 === 1 && p2 >= 0)
        return Dfrac(p2, q2);
      if (q2 === 1 && p2 < 0)
        return "(" + Dfrac(p2, q2) + ")";
      return "\\left ( " + Dfrac(p2, q2) + " \\right )";
    }
  }
  if (signal === "//") {
    if (T2 === "number") {
      let [p2, q2] = ToFrac(value);
      return Dfrac(p2, q2).replace(/dfrac/g, "frac");
    }
  }
  if (signal === "()") {
    if (T2 === "number") {
      let v2 = numberDefault(value);
      return String(v2 >= 0 ? v2 : "(" + v2 + ")");
    }
  }
  if (signal === "!") {
    if (T2 === "number") {
      return ink.printSurd(value);
    }
    if (owl.point2D(value)) {
      let [a2, b2] = value;
      return "(" + ink.printSurd(a2) + "," + ink.printSurd(b2) + ")";
    }
  }
  if (signal === "+") {
    if (T2 === "number")
      return value >= 0 ? "+" : "-";
  }
  if (signal === "-") {
    if (T2 === "number")
      return value >= 0 ? "-" : "+";
  }
  if (signal === "||") {
    if (T2 === "number") {
      return String(numberDefault(Math.abs(value)));
    }
  }
  if (signal === ">") {
    if (T2 === "boolean")
      return value ? "\\gt" : "\\lt";
    if (T2 === "number")
      return value > 0 ? "\\gt" : value < 0 ? "\\lt" : "=";
  }
  if (signal === "<") {
    if (T2 === "boolean")
      return value ? "\\lt" : "\\gt";
    if (T2 === "number")
      return value > 0 ? "\\lt" : value < 0 ? "\\gt" : "=";
  }
  if (signal === ">=") {
    if (T2 === "boolean")
      return value ? "\\ge" : "\\le";
    if (T2 === "number")
      return value > 0 ? "\\ge" : value < 0 ? "\\le" : "=";
  }
  if (signal === "<=") {
    if (T2 === "boolean")
      return value ? "\\le" : "\\ge";
    if (T2 === "number")
      return value > 0 ? "\\le" : value < 0 ? "\\ge" : "=";
  }
  if (signal === "%") {
    if (T2 === "number") {
      return numberDefault(value * 100) + "%";
    }
  }
  if (signal === "\\%") {
    if (T2 === "number") {
      return numberDefault(value * 100) + "\\%";
    }
  }
  if (signal === ":") {
    if (owl.ntuple(value)) {
      return toNumbers(value).ratio().join(":");
    }
    if (T2 === "number") {
      let [p2, q2] = cal.toFraction(value);
      return p2 + ":" + q2;
    }
  }
  if (signal === "|.") {
    if (owl.array(value)) {
      return ink.printOrTrigRoots(value);
    }
  }
  if (signal === ".") {
    if (owl.point2D(value)) {
      return ink.printPointPolar(value);
    }
  }
  if (signal === "=") {
    if (owl.labeledValue(value)) {
      let v2 = [...value];
      v2[0] = numberDefault(v2[0]);
      return ink.printLabeledValue(v2, 1, false);
    }
  }
  if (signal === "==") {
    if (owl.labeledValue2(value)) {
      let v2 = [...value];
      v2[0] = numberDefault(v2[0]);
      return ink.printLabeledValue(v2, 2, false);
    }
  }
  if (signal === "=.") {
    if (owl.labeledValue(value)) {
      let v2 = [...value];
      v2[0] = numberDefault(v2[0]);
      return ink.printLabeledValue(v2, 1, true);
    }
  }
  if (signal === "==.") {
    if (owl.labeledValue2(value)) {
      let v2 = [...value];
      v2[0] = numberDefault(v2[0]);
      return ink.printLabeledValue(v2, 2, true);
    }
  }
  return String(value);
}
function detectVarErr(e2) {
  if (e2 instanceof Error) {
    let isVarErr = e2.message === "Cannot convert a Symbol value to a number";
    if (isVarErr) {
      return CustomError("VariableError", "A variable is used before a value is defined.");
    } else {
      return e2;
    }
  }
  return e2;
}
function evaluate(code, context) {
  let {
    a,
    b,
    c,
    d,
    e,
    f,
    g,
    h,
    i,
    j,
    k,
    l,
    m,
    n,
    o,
    p,
    q,
    r,
    s,
    t,
    u,
    v,
    w,
    x,
    y,
    z,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z
  } = context.dict;
  let sections = context.sections;
  let answer = context.answer;
  let options = context.options;
  let shuffle = context.shuffle;
  let question = context.qn;
  let solution = context.sol;
  let result;
  try {
    result = eval(code);
  } catch (e2) {
    throw detectVarErr(e2);
  }
  if (typeof answer === "number")
    answer = ["A", "B", "C", "D"][answer];
  context.dict.update({
    a,
    b,
    c,
    d,
    e,
    f,
    g,
    h,
    i,
    j,
    k,
    l,
    m,
    n,
    o,
    p,
    q,
    r,
    s,
    t,
    u,
    v,
    w,
    x,
    y,
    z,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z
  });
  let newContext = {
    dict: context.dict,
    sections,
    answer,
    options,
    shuffle,
    qn: question,
    sol: solution
  };
  return { result, context: newContext };
}
function htmlDecode(str2) {
  return str2.replace(/&amp;|&lt;|&gt;|&#39;|&quot;/g, (tag2) => ({
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&#39;": "'",
    "&quot;": '"'
  })[tag2] || tag2);
}
function evalInline(code, dict) {
  code = htmlDecode(code);
  try {
    return eval(code);
  } catch (e2) {
    throw detectVarErr(e2);
  }
}
function intrapolate(html, dict2) {
  function intra(signal, prefix) {
    html = html.replace(new RegExp(String.raw`\*${prefix}\\\{([^\{\}]*)\\\}`, "g"), (match2, code2) => {
      let result2 = evalInline(code2);
      return ParseForPrint(result2, signal);
    });
    html = html.replace(new RegExp(String.raw`\*${prefix}\{([^\{\}]*)\}`, "g"), (match2, code2) => {
      let result2 = evalInline(code2);
      return ParseForPrint(result2, signal);
    });
  }
  intra("", "");
  intra("/", "\\/");
  intra("*", "\\*");
  return html;
}
function DropVersion(html, section, version) {
  let id = section + "." + version;
  return html.replace(new RegExp("<p>##" + id + "<\\/p>((\\s|\\S)(?!##))*<p>##<\\/p>", "g"), "");
}
function DropTags(html) {
  html = html.replace(new RegExp("<[^#<]*##[^#>]*>", "g"), "");
  return html;
}
function KeepVersion(html, section, version) {
  for (let i2 = 0; i2 < 10; i2++) {
    if (i2 === version)
      continue;
    html = DropVersion(html, section, i2);
  }
  return html;
}
function ExecSection(html, sections2, dict2) {
  for (let i2 = 0; i2 < sections2.length; i2++) {
    let [section, version] = sections2[i2];
    html = KeepVersion(html, section.toString(), version);
  }
  html = DropCondition(html);
  html = DropTags(html);
  return html;
}
function DropCondition(html, dict2) {
  return html.replace(new RegExp("<p>##{([^{}]*)}<\\/p>((\\s|\\S)(?!##))*<p>##<\\/p>", "g"), (match2, p1) => evalInline(p1) ? match2 : "");
}
function or(...reg) {
  return "(" + reg.join("|") + ")";
}
const s = String.raw`(?:\s|&nbsp;)*`;
const p = String.raw`\+`;
const m = String.raw`\-`;
const e = String.raw`(?:\=|\>|\<|&lt;|&gt;|\\ge|\\le|\\gt|\\lt)`;
const l = String.raw`[\(\[\{]`;
const r = String.raw`[\)\]\}]`;
const pl = String.raw`[\(\[]`;
const c = String.raw`\,`;
const v = String.raw`(?:[A-Za-z]|\\alpha|\\beta|\\theta|\\phi|\\pi|\\sigma|\\mu|||||||)`;
const f = String.raw`(?:\\sin|\\cos|\\tan|\\log|\\ln)`;
const sl = String.raw`\\`;
const left = String.raw`\\left`;
const sq = String.raw`\\sqrt`;
const endtag = String.raw`(?=[^<>]*</span>)`;
function regReplace(input, reg, replace) {
  return input.replace(new RegExp(reg, "g"), replace);
}
function handleSigns(input) {
  input = regReplace(input, p + s + m, "-");
  input = regReplace(input, m + s + p, "-");
  input = regReplace(input, or(l, e, c) + s + m + s + m, "$1");
  input = regReplace(input, "(,)" + s + m + s + m, "$1");
  input = regReplace(input, m + s + m, "+");
  input = regReplace(input, m + s + m, "+");
  return input;
}
function handlePower(input) {
  input = regReplace(input, String.raw`\^\{1\}`, "");
  return input;
}
function handleSqrt(input) {
  input = regReplace(input, String.raw`\\sqrt\[2\]`, "\\sqrt");
  return input;
}
function handleCoeff(input) {
  input = regReplace(input, or(p, m, e, l, sl, r, c) + s + 1 + s + or(v, f, pl, left, sq) + endtag, "$1 $2");
  return input;
}
function handlePrime(input) {
  input = regReplace(input, "(" + v + ")'" + endtag, "$1 \\prime ");
  return input;
}
function dress(html) {
  html = handleSigns(html);
  html = handlePower(html);
  html = handleSqrt(html);
  html = handleCoeff(html);
  html = handlePrime(html);
  return html;
}
class OptionShuffler {
  constructor(qn, sol, ans, shuffle2) {
    this.qn = qn;
    this.sol = sol;
    this.ans = ans;
    this.shuffle = shuffle2;
    this.perm = [];
    this.valid = false;
    this.Qn = new QuestionHTML(qn);
    if (!this.Qn.ul)
      return;
    if (this.Qn.li.length === 0)
      return;
    this.valid = true;
  }
  AreOptionsDuplicated() {
    return this.Qn.isLiDuplicated();
  }
  genQn() {
    if (!this.valid)
      return this.qn;
    this.perm = this.Qn.shuffleLi(this.shuffle);
    return this.Qn.export();
  }
  mapLetter(oldLetter) {
    let oldIndex = ["A", "B", "C", "D", "E", "F"].indexOf(oldLetter);
    let newIndex = this.perm[oldIndex];
    return ["A", "B", "C", "D", "E", "F"][newIndex];
  }
  genAns() {
    if (!this.valid)
      return "X";
    return this.mapLetter(this.ans);
  }
  genSol() {
    if (!this.valid)
      return this.sol;
    let newSol = "<p>Answer: " + this.genAns() + "</p><p><b>Solution:</b></p>" + this.sol;
    let ansList = ["A", "B", "C", "D", "E", "F"];
    ansList.length = this.perm.length;
    for (let x2 of ansList) {
      newSol = newSol.replace(new RegExp("{#" + x2 + "}", "g"), this.mapLetter(x2));
    }
    return newSol;
  }
}
function Produce(source, assigned) {
  return Array.isArray(assigned) && assigned !== source ? RndShuffle(...assigned) : RndShake(source);
}
function ExecInstructions(instructions, source) {
  let products = {};
  let k2;
  for (k2 in instructions) {
    products[k2] = Produce(source[k2], instructions[k2]);
  }
  return products;
}
function AutoOptions(instructions, question2, source) {
  if (owl.emptyObject(instructions))
    return question2;
  let Qn = new QuestionHTML(question2);
  let products = ExecInstructions(instructions, source);
  if (Qn.li.length === 1) {
    Qn.cloneLi(0, 3);
    for (let k2 in products) {
      Qn.printInLi(1, k2, products[k2][0]);
      Qn.printInLi(2, k2, products[k2][1]);
      Qn.printInLi(3, k2, products[k2][2]);
    }
    return Qn.export();
  }
  if (Qn.li.length === 2) {
    Qn.cloneLi(0);
    Qn.cloneLi(1);
    for (let k2 in products) {
      Qn.printInLi(2, k2, products[k2][0]);
      Qn.printInLi(3, k2, products[k2][0]);
    }
    return Qn.export();
  }
  return question2;
}
class Config {
  constructor(sections2 = [], answer2 = "A", options2 = {}, shuffle2 = true) {
    this.sections = sections2;
    this.answer = answer2;
    this.options = options2;
    this.shuffle = shuffle2;
  }
}
class Dict {
  constructor(a2 = Symbol(), b2 = Symbol(), c2 = Symbol(), d2 = Symbol(), e2 = Symbol(), f2 = Symbol(), g2 = Symbol(), h2 = Symbol(), i2 = Symbol(), j2 = Symbol(), k2 = Symbol(), l2 = Symbol(), m2 = Symbol(), n2 = Symbol(), o2 = Symbol(), p2 = Symbol(), q2 = Symbol(), r2 = Symbol(), s2 = Symbol(), t2 = Symbol(), u2 = Symbol(), v2 = Symbol(), w2 = Symbol(), x2 = Symbol(), y2 = Symbol(), z2 = Symbol(), A2 = Symbol(), B2 = Symbol(), C2 = Symbol(), D2 = Symbol(), E2 = Symbol(), F2 = Symbol(), G2 = Symbol(), H2 = Symbol(), I2 = Symbol(), J2 = Symbol(), K2 = Symbol(), L2 = Symbol(), M2 = Symbol(), N2 = Symbol(), O2 = Symbol(), P2 = Symbol(), Q2 = Symbol(), R2 = Symbol(), S2 = Symbol(), T2 = Symbol(), U2 = Symbol(), V2 = Symbol(), W2 = Symbol(), X2 = Symbol(), Y2 = Symbol(), Z2 = Symbol()) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
    this.d = d2;
    this.e = e2;
    this.f = f2;
    this.g = g2;
    this.h = h2;
    this.i = i2;
    this.j = j2;
    this.k = k2;
    this.l = l2;
    this.m = m2;
    this.n = n2;
    this.o = o2;
    this.p = p2;
    this.q = q2;
    this.r = r2;
    this.s = s2;
    this.t = t2;
    this.u = u2;
    this.v = v2;
    this.w = w2;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.A = A2;
    this.B = B2;
    this.C = C2;
    this.D = D2;
    this.E = E2;
    this.F = F2;
    this.G = G2;
    this.H = H2;
    this.I = I2;
    this.J = J2;
    this.K = K2;
    this.L = L2;
    this.M = M2;
    this.N = N2;
    this.O = O2;
    this.P = P2;
    this.Q = Q2;
    this.R = R2;
    this.S = S2;
    this.T = T2;
    this.U = U2;
    this.V = V2;
    this.W = W2;
    this.X = X2;
    this.Y = Y2;
    this.Z = Z2;
    this.variables = [
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
  }
  update(other) {
    for (let key of this.variables) {
      if (key in other)
        this[key] = other[key];
    }
  }
  checked() {
    for (let key of this.variables) {
      let v2 = this[key];
      if (v2 === void 0 || typeof v2 === "number" && !Number.isFinite(v2))
        return false;
    }
    return true;
  }
  substitute(text2) {
    for (let key of this.variables) {
      let num2 = this[key];
      if (typeof num2 === "symbol")
        continue;
      text2 = PrintVariable(text2, key, num2);
    }
    return text2;
  }
}
class SourceLocation {
  constructor(lexer, start, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start;
    this.end = end;
  }
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
}
class Token {
  constructor(text2, loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text2;
    this.loc = loc;
  }
  range(endToken, text2) {
    return new Token(text2, SourceLocation.range(this, endToken));
  }
}
class ParseError {
  constructor(message, token) {
    this.position = void 0;
    var error2 = "KaTeX parse error: " + message;
    var start;
    var loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      var input = loc.lexer.input;
      start = loc.start;
      var end = loc.end;
      if (start === input.length) {
        error2 += " at end of input: ";
      } else {
        error2 += " at position " + (start + 1) + ": ";
      }
      var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
      var left2;
      if (start > 15) {
        left2 = "\u2026" + input.slice(start - 15, start);
      } else {
        left2 = input.slice(0, start);
      }
      var right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "\u2026";
      } else {
        right = input.slice(end);
      }
      error2 += left2 + underlined + right;
    }
    var self2 = new Error(error2);
    self2.name = "ParseError";
    self2.__proto__ = ParseError.prototype;
    self2.position = start;
    return self2;
  }
}
ParseError.prototype.__proto__ = Error.prototype;
var contains = function contains2(list2, elem) {
  return list2.indexOf(elem) !== -1;
};
var deflt = function deflt2(setting, defaultIfUndefined) {
  return setting === void 0 ? defaultIfUndefined : setting;
};
var uppercase = /([A-Z])/g;
var hyphenate = function hyphenate2(str2) {
  return str2.replace(uppercase, "-$1").toLowerCase();
};
var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
function escape(text2) {
  return String(text2).replace(ESCAPE_REGEX, (match2) => ESCAPE_LOOKUP[match2]);
}
var getBaseElem = function getBaseElem2(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem2(group.body);
  } else {
    return group;
  }
};
var isCharacterBox = function isCharacterBox2(group) {
  var baseElem = getBaseElem(group);
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};
var assert = function assert2(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};
var protocolFromUrl = function protocolFromUrl2(url) {
  var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
  return protocol != null ? protocol[1] : "_relative";
};
var utils = {
  contains,
  deflt,
  escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};
class Settings {
  constructor(options2) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    options2 = options2 || {};
    this.displayMode = utils.deflt(options2.displayMode, false);
    this.output = utils.deflt(options2.output, "htmlAndMathml");
    this.leqno = utils.deflt(options2.leqno, false);
    this.fleqn = utils.deflt(options2.fleqn, false);
    this.throwOnError = utils.deflt(options2.throwOnError, true);
    this.errorColor = utils.deflt(options2.errorColor, "#cc0000");
    this.macros = options2.macros || {};
    this.minRuleThickness = Math.max(0, utils.deflt(options2.minRuleThickness, 0));
    this.colorIsTextColor = utils.deflt(options2.colorIsTextColor, false);
    this.strict = utils.deflt(options2.strict, "warn");
    this.trust = utils.deflt(options2.trust, false);
    this.maxSize = Math.max(0, utils.deflt(options2.maxSize, Infinity));
    this.maxExpand = Math.max(0, utils.deflt(options2.maxExpand, 1e3));
    this.globalGroup = utils.deflt(options2.globalGroup, false);
  }
  reportNonstrict(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      strict = strict(errorCode, errorMsg, token);
    }
    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  useStrictBehavior(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error2) {
        strict = "error";
      }
    }
    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  isTrusted(context2) {
    if (context2.url && !context2.protocol) {
      context2.protocol = utils.protocolFromUrl(context2.url);
    }
    var trust = typeof this.trust === "function" ? this.trust(context2) : this.trust;
    return Boolean(trust);
  }
}
class Style {
  constructor(id, size, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size;
    this.cramped = cramped;
  }
  sup() {
    return styles[sup[this.id]];
  }
  sub() {
    return styles[sub[this.id]];
  }
  fracNum() {
    return styles[fracNum[this.id]];
  }
  fracDen() {
    return styles[fracDen[this.id]];
  }
  cramp() {
    return styles[cramp[this.id]];
  }
  text() {
    return styles[text$1[this.id]];
  }
  isTight() {
    return this.size >= 2;
  }
}
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;
var styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var text$1 = [D, Dc, T, Tc, T, Tc, T, Tc];
var Style$1 = {
  DISPLAY: styles[D],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
};
var scriptData = [{
  name: "latin",
  blocks: [
    [256, 591],
    [768, 879]
  ]
}, {
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  name: "cjk",
  blocks: [
    [12288, 12543],
    [19968, 40879],
    [65280, 65376]
  ]
}, {
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(codepoint) {
  for (var i2 = 0; i2 < scriptData.length; i2++) {
    var script = scriptData[i2];
    for (var _i6 = 0; _i6 < script.blocks.length; _i6++) {
      var block = script.blocks[_i6];
      if (codepoint >= block[0] && codepoint <= block[1]) {
        return script.name;
      }
    }
  }
  return null;
}
var allBlocks = [];
scriptData.forEach((s2) => s2.blocks.forEach((b2) => allBlocks.push(...b2)));
function supportedCodepoint(codepoint) {
  for (var i2 = 0; i2 < allBlocks.length; i2 += 2) {
    if (codepoint >= allBlocks[i2] && codepoint <= allBlocks[i2 + 1]) {
      return true;
    }
  }
  return false;
}
var hLinePad = 80;
var sqrtMain = function sqrtMain2(extraViniculum, hLinePad2) {
  return "M95," + (622 + extraViniculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
};
var sqrtSize1 = function sqrtSize12(extraViniculum, hLinePad2) {
  return "M263," + (601 + extraViniculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
};
var sqrtSize2 = function sqrtSize22(extraViniculum, hLinePad2) {
  return "M983 " + (10 + extraViniculum + hLinePad2) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
};
var sqrtSize3 = function sqrtSize32(extraViniculum, hLinePad2) {
  return "M424," + (2398 + extraViniculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
};
var sqrtSize4 = function sqrtSize42(extraViniculum, hLinePad2) {
  return "M473," + (2713 + extraViniculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "H1017.7z";
};
var phasePath = function phasePath2(y2) {
  var x2 = y2 / 2;
  return "M400000 " + y2 + " H0 L" + x2 + " 0 l65 45 L145 " + (y2 - 80) + " H400000z";
};
var sqrtTall = function sqrtTall2(extraViniculum, hLinePad2, viewBoxHeight) {
  var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraViniculum;
  return "M702 " + (extraViniculum + hLinePad2) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraViniculum) + "H742z";
};
var sqrtPath = function sqrtPath2(size, extraViniculum, viewBoxHeight) {
  extraViniculum = 1e3 * extraViniculum;
  var path2 = "";
  switch (size) {
    case "sqrtMain":
      path2 = sqrtMain(extraViniculum, hLinePad);
      break;
    case "sqrtSize1":
      path2 = sqrtSize1(extraViniculum, hLinePad);
      break;
    case "sqrtSize2":
      path2 = sqrtSize2(extraViniculum, hLinePad);
      break;
    case "sqrtSize3":
      path2 = sqrtSize3(extraViniculum, hLinePad);
      break;
    case "sqrtSize4":
      path2 = sqrtSize4(extraViniculum, hLinePad);
      break;
    case "sqrtTall":
      path2 = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
  }
  return path2;
};
var innerPath = function innerPath2(name, height) {
  switch (name) {
    case "\u239C":
      return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
    case "\u2223":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
    case "\u2225":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
    case "\u239F":
      return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
    case "\u23A2":
      return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
    case "\u23A5":
      return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
    case "\u23AA":
      return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
    case "\u23D0":
      return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
    case "\u2016":
      return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
    default:
      return "";
  }
};
var path = {
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
class DocumentFragment {
  constructor(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    var frag = document.createDocumentFragment();
    for (var i2 = 0; i2 < this.children.length; i2++) {
      frag.appendChild(this.children[i2].toNode());
    }
    return frag;
  }
  toMarkup() {
    var markup = "";
    for (var i2 = 0; i2 < this.children.length; i2++) {
      markup += this.children[i2].toMarkup();
    }
    return markup;
  }
  toText() {
    var toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
}
var fontMetricsData = {
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1],
    "8603": [-0.13313, 0.36687, 0, 0, 1],
    "8606": [0.01354, 0.52239, 0, 0, 1],
    "8608": [0.01354, 0.52239, 0, 0, 1],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1],
    "8620": [0, 0.54986, 0, 0, 1],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1],
    "8631": [0, 0.43056, 0, 0, 1],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1],
    "8646": [0.1808, 0.675, 0, 0, 1],
    "8647": [0.1808, 0.675, 0, 0, 1],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1],
    "8652": [0.01354, 0.52239, 0, 0, 1],
    "8653": [-0.13313, 0.36687, 0, 0, 1],
    "8654": [-0.13313, 0.36687, 0, 0, 1],
    "8655": [-0.13313, 0.36687, 0, 0, 1],
    "8666": [0.13667, 0.63667, 0, 0, 1],
    "8667": [0.13667, 0.63667, 0, 0, 1],
    "8669": [-0.13313, 0.37788, 0, 0, 1],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [222e-5, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [222e-5, 0.50222, 0, 0, 0.89444],
    "8801": [222e-5, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1],
    "8599": [0.19444, 0.69444, 0, 0, 1],
    "8600": [0.19444, 0.69444, 0, 0, 1],
    "8601": [0.19444, 0.69444, 0, 0, 1],
    "8614": [0.011, 0.511, 0, 0, 1],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1],
    "8637": [-0.13313, 0.36687, 0, 0, 1],
    "8640": [-0.13313, 0.36687, 0, 0, 1],
    "8641": [-0.13313, 0.36687, 0, 0, 1],
    "8652": [0.011, 0.671, 0, 0, 1],
    "8656": [-0.13313, 0.36687, 0, 0, 1],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1],
    "8811": [0.0391, 0.5391, 0, 0, 1],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [5e-3, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1],
    "8995": [-0.14236, 0.35764, 0, 0, 1],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 421e-5, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 88e-4, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 316e-5, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 981e-5, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-99e-5, 0.601, 0, 0, 0.77778],
    "8593": [1e-5, 0.6, 0, 0, 0.66667],
    "8595": [1e-5, 0.6, 0, 0, 0.66667],
    "8657": [1e-5, 0.6, 0, 0, 0.77778],
    "8659": [1e-5, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1],
    "8739": [-599e-5, 0.606, 0, 0, 0.33333],
    "8741": [-599e-5, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-99e-5, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1],
    "732": [0, 0.75, 0, 0, 1],
    "770": [0, 0.75, 0, 0, 1],
    "771": [0, 0.75, 0, 0, 1],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-5, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-5, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-99e-5, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-99e-5, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-5, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-5, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-499e-5, 0.605, 0, 0, 1.05556],
    "57345": [-499e-5, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
};
var sigmasAndXis = {
  slant: [0.25, 0.25, 0.25],
  space: [0, 0, 0],
  stretch: [0, 0, 0],
  shrink: [0, 0, 0],
  xHeight: [0.431, 0.431, 0.431],
  quad: [1, 1.171, 1.472],
  extraSpace: [0, 0, 0],
  num1: [0.677, 0.732, 0.925],
  num2: [0.394, 0.384, 0.387],
  num3: [0.444, 0.471, 0.504],
  denom1: [0.686, 0.752, 1.025],
  denom2: [0.345, 0.344, 0.532],
  sup1: [0.413, 0.503, 0.504],
  sup2: [0.363, 0.431, 0.404],
  sup3: [0.289, 0.286, 0.294],
  sub1: [0.15, 0.143, 0.2],
  sub2: [0.247, 0.286, 0.4],
  supDrop: [0.386, 0.353, 0.494],
  subDrop: [0.05, 0.071, 0.1],
  delim1: [2.39, 1.7, 1.98],
  delim2: [1.01, 1.157, 1.42],
  axisHeight: [0.25, 0.25, 0.25],
  defaultRuleThickness: [0.04, 0.049, 0.049],
  bigOpSpacing1: [0.111, 0.111, 0.111],
  bigOpSpacing2: [0.166, 0.166, 0.166],
  bigOpSpacing3: [0.2, 0.2, 0.2],
  bigOpSpacing4: [0.6, 0.611, 0.611],
  bigOpSpacing5: [0.1, 0.143, 0.143],
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  ptPerEm: [10, 10, 10],
  doubleRuleSep: [0.2, 0.2, 0.2],
  arrayRuleWidth: [0.04, 0.04, 0.04],
  fboxsep: [0.3, 0.3, 0.3],
  fboxrule: [0.04, 0.04, 0.04]
};
var extraCharacterMap = {
  "\xC5": "A",
  "\xD0": "D",
  "\xDE": "o",
  "\xE5": "a",
  "\xF0": "d",
  "\xFE": "o",
  "\u0410": "A",
  "\u0411": "B",
  "\u0412": "B",
  "\u0413": "F",
  "\u0414": "A",
  "\u0415": "E",
  "\u0416": "K",
  "\u0417": "3",
  "\u0418": "N",
  "\u0419": "N",
  "\u041A": "K",
  "\u041B": "N",
  "\u041C": "M",
  "\u041D": "H",
  "\u041E": "O",
  "\u041F": "N",
  "\u0420": "P",
  "\u0421": "C",
  "\u0422": "T",
  "\u0423": "y",
  "\u0424": "O",
  "\u0425": "X",
  "\u0426": "U",
  "\u0427": "h",
  "\u0428": "W",
  "\u0429": "W",
  "\u042A": "B",
  "\u042B": "X",
  "\u042C": "B",
  "\u042D": "3",
  "\u042E": "X",
  "\u042F": "R",
  "\u0430": "a",
  "\u0431": "b",
  "\u0432": "a",
  "\u0433": "r",
  "\u0434": "y",
  "\u0435": "e",
  "\u0436": "m",
  "\u0437": "e",
  "\u0438": "n",
  "\u0439": "n",
  "\u043A": "n",
  "\u043B": "n",
  "\u043C": "m",
  "\u043D": "n",
  "\u043E": "o",
  "\u043F": "n",
  "\u0440": "p",
  "\u0441": "c",
  "\u0442": "o",
  "\u0443": "y",
  "\u0444": "b",
  "\u0445": "x",
  "\u0446": "n",
  "\u0447": "n",
  "\u0448": "w",
  "\u0449": "w",
  "\u044A": "a",
  "\u044B": "m",
  "\u044C": "a",
  "\u044D": "e",
  "\u044E": "m",
  "\u044F": "r"
};
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }
  var ch2 = character.charCodeAt(0);
  var metrics = fontMetricsData[font][ch2];
  if (!metrics && character[0] in extraCharacterMap) {
    ch2 = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch2];
  }
  if (!metrics && mode === "text") {
    if (supportedCodepoint(ch2)) {
      metrics = fontMetricsData[font][77];
    }
  }
  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
function getGlobalMetrics(size) {
  var sizeIndex;
  if (size >= 5) {
    sizeIndex = 0;
  } else if (size >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }
  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };
    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }
  return fontMetricsBySizeIndex[sizeIndex];
}
var sizeStyleMap = [
  [1, 1, 1],
  [2, 1, 1],
  [3, 1, 1],
  [4, 2, 1],
  [5, 2, 1],
  [6, 3, 1],
  [7, 4, 2],
  [8, 6, 3],
  [9, 7, 6],
  [10, 8, 7],
  [11, 10, 9]
];
var sizeMultipliers = [
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
];
var sizeAtStyle = function sizeAtStyle2(size, style) {
  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
};
class Options {
  constructor(data2) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data2.style;
    this.color = data2.color;
    this.size = data2.size || Options.BASESIZE;
    this.textSize = data2.textSize || this.size;
    this.phantom = !!data2.phantom;
    this.font = data2.font || "";
    this.fontFamily = data2.fontFamily || "";
    this.fontWeight = data2.fontWeight || "";
    this.fontShape = data2.fontShape || "";
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data2.maxSize;
    this.minRuleThickness = data2.minRuleThickness;
    this._fontMetrics = void 0;
  }
  extend(extension) {
    var data2 = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var key in extension) {
      if (extension.hasOwnProperty(key)) {
        data2[key] = extension[key];
      }
    }
    return new Options(data2);
  }
  havingStyle(style) {
    if (this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: sizeAtStyle(this.textSize, style)
      });
    }
  }
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  havingSize(size) {
    if (this.size === size && this.textSize === size) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size,
        textSize: size,
        sizeMultiplier: sizeMultipliers[size - 1]
      });
    }
  }
  havingBaseStyle(style) {
    style = style || this.style.text();
    var wantSize = sizeAtStyle(Options.BASESIZE, style);
    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: wantSize
      });
    }
  }
  havingBaseSizing() {
    var size;
    switch (this.style.id) {
      case 4:
      case 5:
        size = 3;
        break;
      case 6:
      case 7:
        size = 1;
        break;
      default:
        size = 6;
    }
    return this.extend({
      style: this.style.text(),
      size
    });
  }
  withColor(color) {
    return this.extend({
      color
    });
  }
  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  withFont(font) {
    return this.extend({
      font
    });
  }
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  baseSizingClasses() {
    if (this.size !== Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
    } else {
      return [];
    }
  }
  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }
    return this._fontMetrics;
  }
  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }
}
Options.BASESIZE = 6;
var ptPerUnit = {
  "pt": 1,
  "mm": 7227 / 2540,
  "cm": 7227 / 254,
  "in": 72.27,
  "bp": 803 / 800,
  "pc": 12,
  "dd": 1238 / 1157,
  "cc": 14856 / 1157,
  "nd": 685 / 642,
  "nc": 1370 / 107,
  "sp": 1 / 65536,
  "px": 803 / 800
};
var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};
var validUnit = function validUnit2(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
var calculateSize = function calculateSize2(sizeValue, options2) {
  var scale;
  if (sizeValue.unit in ptPerUnit) {
    scale = ptPerUnit[sizeValue.unit] / options2.fontMetrics().ptPerEm / options2.sizeMultiplier;
  } else if (sizeValue.unit === "mu") {
    scale = options2.fontMetrics().cssEmPerMu;
  } else {
    var unitOptions;
    if (options2.style.isTight()) {
      unitOptions = options2.havingStyle(options2.style.text());
    } else {
      unitOptions = options2;
    }
    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }
    if (unitOptions !== options2) {
      scale *= unitOptions.sizeMultiplier / options2.sizeMultiplier;
    }
  }
  return Math.min(sizeValue.number * scale, options2.maxSize);
};
var makeEm = function makeEm2(n2) {
  return +n2.toFixed(4) + "em";
};
var createClass = function createClass2(classes) {
  return classes.filter((cls) => cls).join(" ");
};
var initNode = function initNode2(classes, options2, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style || {};
  if (options2) {
    if (options2.style.isTight()) {
      this.classes.push("mtight");
    }
    var color = options2.getColor();
    if (color) {
      this.style.color = color;
    }
  }
};
var toNode = function toNode2(tagName) {
  var node = document.createElement(tagName);
  node.className = createClass(this.classes);
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      node.style[style] = this.style[style];
    }
  }
  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  }
  for (var i2 = 0; i2 < this.children.length; i2++) {
    node.appendChild(this.children[i2].toNode());
  }
  return node;
};
var toMarkup = function toMarkup2(tagName) {
  var markup = "<" + tagName;
  if (this.classes.length) {
    markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
  }
  var styles2 = "";
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
    }
  }
  if (styles2) {
    markup += ' style="' + utils.escape(styles2) + '"';
  }
  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
    }
  }
  markup += ">";
  for (var i2 = 0; i2 < this.children.length; i2++) {
    markup += this.children[i2].toMarkup();
  }
  markup += "</" + tagName + ">";
  return markup;
};
class Span {
  constructor(classes, children, options2, style) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options2, style);
    this.children = children || [];
  }
  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
}
class Anchor {
  constructor(href, classes, children, options2) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options2);
    this.children = children || [];
    this.setAttribute("href", href);
  }
  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
}
class Img {
  constructor(src, alt, style) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    var node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        node.style[style] = this.style[style];
      }
    }
    return node;
  }
  toMarkup() {
    var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
    var styles2 = "";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    markup += "'/>";
    return markup;
  }
}
var iCombinations = {
  "\xEE": "\u0131\u0302",
  "\xEF": "\u0131\u0308",
  "\xED": "\u0131\u0301",
  "\xEC": "\u0131\u0300"
};
class SymbolNode {
  constructor(text2, height, depth, italic, skew, width, classes, style) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text2;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;
    var script = scriptFromCodepoint(this.text.charCodeAt(0));
    if (script) {
      this.classes.push(script + "_fallback");
    }
    if (/[]/.test(this.text)) {
      this.text = iCombinations[this.text];
    }
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    var node = document.createTextNode(this.text);
    var span = null;
    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }
    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        span = span || document.createElement("span");
        span.style[style] = this.style[style];
      }
    }
    if (span) {
      span.appendChild(node);
      return span;
    } else {
      return node;
    }
  }
  toMarkup() {
    var needsSpan = false;
    var markup = "<span";
    if (this.classes.length) {
      needsSpan = true;
      markup += ' class="';
      markup += utils.escape(createClass(this.classes));
      markup += '"';
    }
    var styles2 = "";
    if (this.italic > 0) {
      styles2 += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      needsSpan = true;
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    var escaped = utils.escape(this.text);
    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }
}
class SvgNode {
  constructor(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "svg");
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    for (var i2 = 0; i2 < this.children.length; i2++) {
      node.appendChild(this.children[i2].toNode());
    }
    return node;
  }
  toMarkup() {
    var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "='" + this.attributes[attr] + "'";
      }
    }
    markup += ">";
    for (var i2 = 0; i2 < this.children.length; i2++) {
      markup += this.children[i2].toMarkup();
    }
    markup += "</svg>";
    return markup;
  }
}
class PathNode {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate;
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "path");
    if (this.alternate) {
      node.setAttribute("d", this.alternate);
    } else {
      node.setAttribute("d", path[this.pathName]);
    }
    return node;
  }
  toMarkup() {
    if (this.alternate) {
      return "<path d='" + this.alternate + "'/>";
    } else {
      return "<path d='" + path[this.pathName] + "'/>";
    }
  }
}
class LineNode {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "line");
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    return node;
  }
  toMarkup() {
    var markup = "<line";
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "='" + this.attributes[attr] + "'";
      }
    }
    markup += "/>";
    return markup;
  }
}
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font,
    group,
    replace
  };
  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
}
var math = "math";
var text = "text";
var main = "main";
var ams = "ams";
var accent = "accent-token";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op-token";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";
defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
defineSymbol(math, main, rel, "\u227A", "\\prec", true);
defineSymbol(math, main, rel, "\u227B", "\\succ", true);
defineSymbol(math, main, rel, "\u223C", "\\sim", true);
defineSymbol(math, main, rel, "\u22A5", "\\perp");
defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
defineSymbol(math, main, rel, "\u2223", "\\mid", true);
defineSymbol(math, main, rel, "\u226A", "\\ll", true);
defineSymbol(math, main, rel, "\u226B", "\\gg", true);
defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
defineSymbol(math, main, rel, "\u2323", "\\smile", true);
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
defineSymbol(math, main, rel, "\u2322", "\\frown", true);
defineSymbol(math, main, rel, "\u220B", "\\ni", true);
defineSymbol(math, main, rel, "\u221D", "\\propto", true);
defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
defineSymbol(math, main, rel, "\u220B", "\\owns");
defineSymbol(math, main, punct, ".", "\\ldotp");
defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
defineSymbol(math, main, textord, "#", "\\#");
defineSymbol(text, main, textord, "#", "\\#");
defineSymbol(math, main, textord, "&", "\\&");
defineSymbol(text, main, textord, "&", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
defineSymbol(math, main, textord, "\u2200", "\\forall", true);
defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
defineSymbol(math, main, textord, "\u2203", "\\exists", true);
defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
defineSymbol(math, main, textord, "\u266D", "\\flat", true);
defineSymbol(math, main, textord, "\u2113", "\\ell", true);
defineSymbol(math, main, textord, "\u266E", "\\natural", true);
defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, main, textord, "\u2118", "\\wp", true);
defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, main, textord, "\u211C", "\\Re", true);
defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, main, textord, "\u2111", "\\Im", true);
defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, main, textord, "\xA7", "\\S", true);
defineSymbol(text, main, textord, "\xA7", "\\S");
defineSymbol(math, main, textord, "\xB6", "\\P", true);
defineSymbol(text, main, textord, "\xB6", "\\P");
defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(text, main, textord, "\u2020", "\\dag");
defineSymbol(text, main, textord, "\u2020", "\\textdagger");
defineSymbol(math, main, textord, "\u2021", "\\ddag");
defineSymbol(text, main, textord, "\u2021", "\\ddag");
defineSymbol(text, main, textord, "\u2021", "\\textdaggerdbl");
defineSymbol(math, main, close, "\u23B1", "\\rmoustache", true);
defineSymbol(math, main, open, "\u23B0", "\\lmoustache", true);
defineSymbol(math, main, close, "\u27EF", "\\rgroup", true);
defineSymbol(math, main, open, "\u27EE", "\\lgroup", true);
defineSymbol(math, main, bin, "\u2213", "\\mp", true);
defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
defineSymbol(math, main, bin, "\u2219", "\\bullet");
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr", true);
defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
defineSymbol(math, main, bin, "&", "\\And");
defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210F", "\\hslash");
defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
defineSymbol(math, ams, textord, "\xAE", "\\circledR");
defineSymbol(text, ams, textord, "\xAE", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
defineSymbol(text, main, textord, "\xF0", "\xF0");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25A1", "\\square");
defineSymbol(math, ams, textord, "\u25A1", "\\Box");
defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
defineSymbol(text, ams, textord, "\xA5", "\\yen", true);
defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
defineSymbol(text, ams, textord, "\u2713", "\\checkmark");
defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
defineSymbol(math, ams, open, "\u250C", "\\@ulcorner", true);
defineSymbol(math, ams, close, "\u2510", "\\@urcorner", true);
defineSymbol(math, ams, open, "\u2514", "\\@llcorner", true);
defineSymbol(math, ams, close, "\u2518", "\\@lrcorner", true);
defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226C", "\\between", true);
defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
defineSymbol(math, ams, rel, "\u2235", "\\because", true);
defineSymbol(math, ams, rel, "\u22D8", "\\llless");
defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, main, rel, "\u22C8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\textdollar");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\textunderscore");
defineSymbol(math, main, textord, "\u2220", "\\angle", true);
defineSymbol(math, main, textord, "\u221E", "\\infty", true);
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25B3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
defineSymbol(math, main, textord, "A", "\u0391");
defineSymbol(math, main, textord, "B", "\u0392");
defineSymbol(math, main, textord, "E", "\u0395");
defineSymbol(math, main, textord, "Z", "\u0396");
defineSymbol(math, main, textord, "H", "\u0397");
defineSymbol(math, main, textord, "I", "\u0399");
defineSymbol(math, main, textord, "K", "\u039A");
defineSymbol(math, main, textord, "M", "\u039C");
defineSymbol(math, main, textord, "N", "\u039D");
defineSymbol(math, main, textord, "O", "\u039F");
defineSymbol(math, main, textord, "P", "\u03A1");
defineSymbol(math, main, textord, "T", "\u03A4");
defineSymbol(math, main, textord, "X", "\u03A7");
defineSymbol(math, main, textord, "\xAC", "\\neg", true);
defineSymbol(math, main, textord, "\xAC", "\\lnot");
defineSymbol(math, main, textord, "\u22A4", "\\top");
defineSymbol(math, main, textord, "\u22A5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
defineSymbol(math, main, bin, "\u2217", "*", true);
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-", true);
defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
defineSymbol(math, main, bin, "\u2218", "\\circ");
defineSymbol(math, main, bin, "\xF7", "\\div", true);
defineSymbol(math, main, bin, "\xB1", "\\pm", true);
defineSymbol(math, main, bin, "\xD7", "\\times", true);
defineSymbol(math, main, bin, "\u2229", "\\cap", true);
defineSymbol(math, main, bin, "\u222A", "\\cup", true);
defineSymbol(math, main, bin, "\u2216", "\\setminus");
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
defineSymbol(math, main, bin, "\u2228", "\\vee", true);
defineSymbol(math, main, textord, "\u221A", "\\surd");
defineSymbol(math, main, open, "\u27E8", "\\langle", true);
defineSymbol(math, main, open, "\u2223", "\\lvert");
defineSymbol(math, main, open, "\u2225", "\\lVert");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "\u27E9", "\\rangle", true);
defineSymbol(math, main, close, "\u2223", "\\rvert");
defineSymbol(math, main, close, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx", true);
defineSymbol(math, main, rel, "\u2245", "\\cong", true);
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq", true);
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt", true);
defineSymbol(math, main, rel, "\u2208", "\\in", true);
defineSymbol(math, main, rel, "\uE020", "\\@not");
defineSymbol(math, main, rel, "\u2282", "\\subset", true);
defineSymbol(math, main, rel, "\u2283", "\\supset", true);
defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, main, rel, "\u22A8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq", true);
defineSymbol(math, main, rel, "<", "\\lt", true);
defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
defineSymbol(math, main, spacing, "\xA0", "\\ ");
defineSymbol(math, main, spacing, "\xA0", "\\space");
defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
defineSymbol(text, main, spacing, "\xA0", "\\ ");
defineSymbol(text, main, spacing, "\xA0", " ");
defineSymbol(text, main, spacing, "\xA0", "\\space");
defineSymbol(text, main, spacing, "\xA0", "\\nobreakspace");
defineSymbol(math, main, spacing, null, "\\nobreak");
defineSymbol(math, main, spacing, null, "\\allowbreak");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
defineSymbol(math, main, bin, "\u2299", "\\odot", true);
defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
defineSymbol(math, main, textord, "\u2202", "\\partial", true);
defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22C4", "\\diamond");
defineSymbol(math, main, bin, "\u22C6", "\\star");
defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\textbraceleft");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\textbraceright");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack", true);
defineSymbol(text, main, textord, "[", "\\lbrack", true);
defineSymbol(math, main, close, "]", "\\rbrack", true);
defineSymbol(text, main, textord, "]", "\\rbrack", true);
defineSymbol(math, main, open, "(", "\\lparen", true);
defineSymbol(math, main, close, ")", "\\rparen", true);
defineSymbol(text, main, textord, "<", "\\textless", true);
defineSymbol(text, main, textord, ">", "\\textgreater", true);
defineSymbol(math, main, open, "\u230A", "\\lfloor", true);
defineSymbol(math, main, close, "\u230B", "\\rfloor", true);
defineSymbol(math, main, open, "\u2308", "\\lceil", true);
defineSymbol(math, main, close, "\u2309", "\\rceil", true);
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(text, main, textord, "|", "\\textbar", true);
defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(text, main, textord, "\u2225", "\\textbardbl");
defineSymbol(text, main, textord, "~", "\\textasciitilde");
defineSymbol(text, main, textord, "\\", "\\textbackslash");
defineSymbol(text, main, textord, "^", "\\textasciicircum");
defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
defineSymbol(math, main, op, "\u2210", "\\coprod");
defineSymbol(math, main, op, "\u22C1", "\\bigvee");
defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
defineSymbol(math, main, op, "\u2A04", "\\biguplus");
defineSymbol(math, main, op, "\u22C2", "\\bigcap");
defineSymbol(math, main, op, "\u22C3", "\\bigcup");
defineSymbol(math, main, op, "\u222B", "\\int");
defineSymbol(math, main, op, "\u222B", "\\intop");
defineSymbol(math, main, op, "\u222C", "\\iint");
defineSymbol(math, main, op, "\u222D", "\\iiint");
defineSymbol(math, main, op, "\u220F", "\\prod");
defineSymbol(math, main, op, "\u2211", "\\sum");
defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
defineSymbol(math, main, op, "\u2A00", "\\bigodot");
defineSymbol(math, main, op, "\u222E", "\\oint");
defineSymbol(math, main, op, "\u222F", "\\oiint");
defineSymbol(math, main, op, "\u2230", "\\oiiint");
defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
defineSymbol(math, main, op, "\u222B", "\\smallint");
defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
defineSymbol(math, main, accent, "\u02CA", "\\acute");
defineSymbol(math, main, accent, "\u02CB", "\\grave");
defineSymbol(math, main, accent, "\xA8", "\\ddot");
defineSymbol(math, main, accent, "~", "\\tilde");
defineSymbol(math, main, accent, "\u02C9", "\\bar");
defineSymbol(math, main, accent, "\u02D8", "\\breve");
defineSymbol(math, main, accent, "\u02C7", "\\check");
defineSymbol(math, main, accent, "^", "\\hat");
defineSymbol(math, main, accent, "\u20D7", "\\vec");
defineSymbol(math, main, accent, "\u02D9", "\\dot");
defineSymbol(math, main, accent, "\u02DA", "\\mathring");
defineSymbol(math, main, mathord, "\uE131", "\\@imath");
defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
defineSymbol(math, main, textord, "\u0131", "\u0131");
defineSymbol(math, main, textord, "\u0237", "\u0237");
defineSymbol(text, main, textord, "\u0131", "\\i", true);
defineSymbol(text, main, textord, "\u0237", "\\j", true);
defineSymbol(text, main, textord, "\xDF", "\\ss", true);
defineSymbol(text, main, textord, "\xE6", "\\ae", true);
defineSymbol(text, main, textord, "\u0153", "\\oe", true);
defineSymbol(text, main, textord, "\xF8", "\\o", true);
defineSymbol(text, main, textord, "\xC6", "\\AE", true);
defineSymbol(text, main, textord, "\u0152", "\\OE", true);
defineSymbol(text, main, textord, "\xD8", "\\O", true);
defineSymbol(text, main, accent, "\u02CA", "\\'");
defineSymbol(text, main, accent, "\u02CB", "\\`");
defineSymbol(text, main, accent, "\u02C6", "\\^");
defineSymbol(text, main, accent, "\u02DC", "\\~");
defineSymbol(text, main, accent, "\u02C9", "\\=");
defineSymbol(text, main, accent, "\u02D8", "\\u");
defineSymbol(text, main, accent, "\u02D9", "\\.");
defineSymbol(text, main, accent, "\xB8", "\\c");
defineSymbol(text, main, accent, "\u02DA", "\\r");
defineSymbol(text, main, accent, "\u02C7", "\\v");
defineSymbol(text, main, accent, "\xA8", '\\"');
defineSymbol(text, main, accent, "\u02DD", "\\H");
defineSymbol(text, main, accent, "\u25EF", "\\textcircled");
var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(text, main, textord, "\u2013", "--", true);
defineSymbol(text, main, textord, "\u2013", "\\textendash");
defineSymbol(text, main, textord, "\u2014", "---", true);
defineSymbol(text, main, textord, "\u2014", "\\textemdash");
defineSymbol(text, main, textord, "\u2018", "`", true);
defineSymbol(text, main, textord, "\u2018", "\\textquoteleft");
defineSymbol(text, main, textord, "\u2019", "'", true);
defineSymbol(text, main, textord, "\u2019", "\\textquoteright");
defineSymbol(text, main, textord, "\u201C", "``", true);
defineSymbol(text, main, textord, "\u201C", "\\textquotedblleft");
defineSymbol(text, main, textord, "\u201D", "''", true);
defineSymbol(text, main, textord, "\u201D", "\\textquotedblright");
defineSymbol(math, main, textord, "\xB0", "\\degree", true);
defineSymbol(text, main, textord, "\xB0", "\\degree");
defineSymbol(text, main, textord, "\xB0", "\\textdegree", true);
defineSymbol(math, main, textord, "\xA3", "\\pounds");
defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
defineSymbol(text, main, textord, "\xA3", "\\pounds");
defineSymbol(text, main, textord, "\xA3", "\\textsterling", true);
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(text, ams, textord, "\u2720", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (var i = 0; i < mathTextSymbols.length; i++) {
  var ch = mathTextSymbols.charAt(i);
  defineSymbol(math, main, textord, ch, ch);
}
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (var _i = 0; _i < textSymbols.length; _i++) {
  var _ch = textSymbols.charAt(_i);
  defineSymbol(text, main, textord, _ch, _ch);
}
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var _i2 = 0; _i2 < letters.length; _i2++) {
  var _ch2 = letters.charAt(_i2);
  defineSymbol(math, main, mathord, _ch2, _ch2);
  defineSymbol(text, main, textord, _ch2, _ch2);
}
defineSymbol(math, ams, textord, "C", "\u2102");
defineSymbol(text, ams, textord, "C", "\u2102");
defineSymbol(math, ams, textord, "H", "\u210D");
defineSymbol(text, ams, textord, "H", "\u210D");
defineSymbol(math, ams, textord, "N", "\u2115");
defineSymbol(text, ams, textord, "N", "\u2115");
defineSymbol(math, ams, textord, "P", "\u2119");
defineSymbol(text, ams, textord, "P", "\u2119");
defineSymbol(math, ams, textord, "Q", "\u211A");
defineSymbol(text, ams, textord, "Q", "\u211A");
defineSymbol(math, ams, textord, "R", "\u211D");
defineSymbol(text, ams, textord, "R", "\u211D");
defineSymbol(math, ams, textord, "Z", "\u2124");
defineSymbol(text, ams, textord, "Z", "\u2124");
defineSymbol(math, main, mathord, "h", "\u210E");
defineSymbol(text, main, mathord, "h", "\u210E");
var wideChar = "";
for (var _i3 = 0; _i3 < letters.length; _i3++) {
  var _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56372 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56424 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56580 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56736 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56788 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56840 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56944 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  if (_i3 < 26) {
    wideChar = String.fromCharCode(55349, 56632 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56476 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
  }
}
wideChar = String.fromCharCode(55349, 56668);
defineSymbol(math, main, mathord, "k", wideChar);
defineSymbol(text, main, textord, "k", wideChar);
for (var _i4 = 0; _i4 < 10; _i4++) {
  var _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57314 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57324 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57334 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
}
var extraLatin = "\xD0\xDE\xFE";
for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
  var _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math, main, mathord, _ch5, _ch5);
  defineSymbol(text, main, textord, _ch5, _ch5);
}
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  ["mathbf", "textbf", "Main-Bold"],
  ["mathnormal", "textit", "Math-Italic"],
  ["mathnormal", "textit", "Math-Italic"],
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  ["mathscr", "textscr", "Script-Regular"],
  ["", "", ""],
  ["", "", ""],
  ["", "", ""],
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  ["mathbb", "textbb", "AMS-Regular"],
  ["mathbb", "textbb", "AMS-Regular"],
  ["", "", ""],
  ["", "", ""],
  ["mathsf", "textsf", "SansSerif-Regular"],
  ["mathsf", "textsf", "SansSerif-Regular"],
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  ["", "", ""],
  ["", "", ""],
  ["mathtt", "texttt", "Typewriter-Regular"],
  ["mathtt", "texttt", "Typewriter-Regular"]
];
var wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  ["", "", ""],
  ["mathsf", "textsf", "SansSerif-Regular"],
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  ["mathtt", "texttt", "Typewriter-Regular"]
];
var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
  var H2 = wideChar2.charCodeAt(0);
  var L2 = wideChar2.charCodeAt(1);
  var codePoint = (H2 - 55296) * 1024 + (L2 - 56320) + 65536;
  var j2 = mode === "math" ? 0 : 1;
  if (119808 <= codePoint && codePoint < 120484) {
    var i2 = Math.floor((codePoint - 119808) / 26);
    return [wideLatinLetterData[i2][2], wideLatinLetterData[i2][j2]];
  } else if (120782 <= codePoint && codePoint <= 120831) {
    var _i6 = Math.floor((codePoint - 120782) / 10);
    return [wideNumeralData[_i6][2], wideNumeralData[_i6][j2]];
  } else if (codePoint === 120485 || codePoint === 120486) {
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j2]];
  } else if (120486 < codePoint && codePoint < 120782) {
    return ["", ""];
  } else {
    throw new ParseError("Unsupported character: " + wideChar2);
  }
};
var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
  if (symbols[mode][value] && symbols[mode][value].replace) {
    value = symbols[mode][value].replace;
  }
  return {
    value,
    metrics: getCharacterMetrics(value, fontName, mode)
  };
};
var makeSymbol = function makeSymbol2(value, fontName, mode, options2, classes) {
  var lookup = lookupSymbol(value, fontName, mode);
  var metrics = lookup.metrics;
  value = lookup.value;
  var symbolNode;
  if (metrics) {
    var italic = metrics.italic;
    if (mode === "text" || options2 && options2.font === "mathit") {
      italic = 0;
    }
    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
  } else {
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
  }
  if (options2) {
    symbolNode.maxFontSize = options2.sizeMultiplier;
    if (options2.style.isTight()) {
      symbolNode.classes.push("mtight");
    }
    var color = options2.getColor();
    if (color) {
      symbolNode.style.color = color;
    }
  }
  return symbolNode;
};
var mathsym = function mathsym2(value, mode, options2, classes) {
  if (classes === void 0) {
    classes = [];
  }
  if (options2.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
    return makeSymbol(value, "Main-Bold", mode, options2, classes.concat(["mathbf"]));
  } else if (value === "\\" || symbols[mode][value].font === "main") {
    return makeSymbol(value, "Main-Regular", mode, options2, classes);
  } else {
    return makeSymbol(value, "AMS-Regular", mode, options2, classes.concat(["amsrm"]));
  }
};
var boldsymbol = function boldsymbol2(value, mode, options2, classes, type) {
  if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
var makeOrd = function makeOrd2(group, options2, type) {
  var mode = group.mode;
  var text2 = group.text;
  var classes = ["mord"];
  var isFont = mode === "math" || mode === "text" && options2.font;
  var fontOrFamily = isFont ? options2.font : options2.fontFamily;
  if (text2.charCodeAt(0) === 55349) {
    var [wideFontName, wideFontClass] = wideCharacterFont(text2, mode);
    return makeSymbol(text2, wideFontName, mode, options2, classes.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;
    if (fontOrFamily === "boldsymbol") {
      var fontData = boldsymbol(text2, mode, options2, classes, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options2.fontWeight, options2.fontShape);
      fontClasses = [fontOrFamily, options2.fontWeight, options2.fontShape];
    }
    if (lookupSymbol(text2, fontName, mode).metrics) {
      return makeSymbol(text2, fontName, mode, options2, classes.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text2) && fontName.substr(0, 10) === "Typewriter") {
      var parts = [];
      for (var i2 = 0; i2 < text2.length; i2++) {
        parts.push(makeSymbol(text2[i2], fontName, mode, options2, classes.concat(fontClasses)));
      }
      return makeFragment(parts);
    }
  }
  if (type === "mathord") {
    return makeSymbol(text2, "Math-Italic", mode, options2, classes.concat(["mathnormal"]));
  } else if (type === "textord") {
    var font = symbols[mode][text2] && symbols[mode][text2].font;
    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options2.fontWeight, options2.fontShape);
      return makeSymbol(text2, _fontName, mode, options2, classes.concat("amsrm", options2.fontWeight, options2.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options2.fontWeight, options2.fontShape);
      return makeSymbol(text2, _fontName2, mode, options2, classes.concat(options2.fontWeight, options2.fontShape));
    } else {
      var _fontName3 = retrieveTextFontName(font, options2.fontWeight, options2.fontShape);
      return makeSymbol(text2, _fontName3, mode, options2, classes.concat(_fontName3, options2.fontWeight, options2.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
var canCombine = (prev, next) => {
  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
    return false;
  }
  if (prev.classes.length === 1) {
    var cls = prev.classes[0];
    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }
  for (var style in prev.style) {
    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
      return false;
    }
  }
  for (var _style in next.style) {
    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
      return false;
    }
  }
  return true;
};
var tryCombineChars = (chars) => {
  for (var i2 = 0; i2 < chars.length - 1; i2++) {
    var prev = chars[i2];
    var next = chars[i2 + 1];
    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
      prev.text += next.text;
      prev.height = Math.max(prev.height, next.height);
      prev.depth = Math.max(prev.depth, next.depth);
      prev.italic = next.italic;
      chars.splice(i2 + 1, 1);
      i2--;
    }
  }
  return chars;
};
var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
  var height = 0;
  var depth = 0;
  var maxFontSize = 0;
  for (var i2 = 0; i2 < elem.children.length; i2++) {
    var child = elem.children[i2];
    if (child.height > height) {
      height = child.height;
    }
    if (child.depth > depth) {
      depth = child.depth;
    }
    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }
  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
var makeSpan$2 = function makeSpan2(classes, children, options2, style) {
  var span = new Span(classes, children, options2, style);
  sizeElementFromChildren(span);
  return span;
};
var makeSvgSpan = (classes, children, options2, style) => new Span(classes, children, options2, style);
var makeLineSpan = function makeLineSpan2(className, options2, thickness) {
  var line = makeSpan$2([className], [], options2);
  line.height = Math.max(thickness || options2.fontMetrics().defaultRuleThickness, options2.minRuleThickness);
  line.style.borderBottomWidth = makeEm(line.height);
  line.maxFontSize = 1;
  return line;
};
var makeAnchor = function makeAnchor2(href, classes, children, options2) {
  var anchor = new Anchor(href, classes, children, options2);
  sizeElementFromChildren(anchor);
  return anchor;
};
var makeFragment = function makeFragment2(children) {
  var fragment = new DocumentFragment(children);
  sizeElementFromChildren(fragment);
  return fragment;
};
var wrapFragment = function wrapFragment2(group, options2) {
  if (group instanceof DocumentFragment) {
    return makeSpan$2([], [group], options2);
  }
  return group;
};
var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children = [oldChildren[0]];
    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
    var currPos = _depth;
    for (var i2 = 1; i2 < oldChildren.length; i2++) {
      var diff = -oldChildren[i2].shift - currPos - oldChildren[i2].elem.depth;
      var size = diff - (oldChildren[i2 - 1].elem.height + oldChildren[i2 - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size
      });
      children.push(oldChildren[i2]);
    }
    return {
      children,
      depth: _depth
    };
  }
  var depth;
  if (params.positionType === "top") {
    var bottom = params.positionData;
    for (var _i6 = 0; _i6 < params.children.length; _i6++) {
      var child = params.children[_i6];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }
    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];
    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }
    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }
  return {
    children: params.children,
    depth
  };
};
var makeVList = function makeVList2(params, options2) {
  var {
    children,
    depth
  } = getVListChildrenAndDepth(params);
  var pstrutSize = 0;
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }
  pstrutSize += 2;
  var pstrut = makeSpan$2(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize);
  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;
  for (var _i22 = 0; _i22 < children.length; _i22++) {
    var _child = children[_i22];
    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes = _child.wrapperClasses || [];
      var style = _child.wrapperStyle || {};
      var childWrap = makeSpan$2(classes, [pstrut, _elem], void 0, style);
      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }
      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }
      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }
    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  }
  var vlist = makeSpan$2(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos);
  var rows;
  if (minPos < 0) {
    var emptySpan = makeSpan$2([], []);
    var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos);
    var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200B")]);
    rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan$2(["vlist-r"], [vlist])];
  }
  var vtable = makeSpan$2(["vlist-t"], rows);
  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }
  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
};
var makeGlue = (measurement, options2) => {
  var rule = makeSpan$2(["mspace"], [], options2);
  var size = calculateSize(measurement, options2);
  rule.style.marginRight = makeEm(size);
  return rule;
};
var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";
  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;
    case "textrm":
      baseFontName = "Main";
      break;
    case "textsf":
      baseFontName = "SansSerif";
      break;
    case "texttt":
      baseFontName = "Typewriter";
      break;
    default:
      baseFontName = fontFamily;
  }
  var fontStylesName;
  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }
  return baseFontName + "-" + fontStylesName;
};
var fontMap = {
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  vec: ["vec", 0.471, 0.714],
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};
var staticSvg = function staticSvg2(value, options2) {
  var [pathName, width, height] = svgData[value];
  var path2 = new PathNode(pathName);
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = makeSvgSpan(["overlay"], [svgNode], options2);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return span;
};
var buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
};
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
};
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
};
var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
var _functions = {};
var _htmlGroupBuilders = {};
var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data2 = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler
  };
  for (var i2 = 0; i2 < names.length; ++i2) {
    _functions[names[i2]] = data2;
  }
  if (type) {
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
}
function defineFunctionBuilders(_ref2) {
  var {
    type,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  });
}
var normalizeArgument = function normalizeArgument2(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
};
var ordargument = function ordargument2(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};
var makeSpan$1 = buildCommon.makeSpan;
var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var styleMap$1 = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};
var buildExpression$1 = function buildExpression2(expression, options2, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }
  var groups = [];
  for (var i2 = 0; i2 < expression.length; i2++) {
    var output = buildGroup$1(expression[i2], options2);
    if (output instanceof DocumentFragment) {
      var children = output.children;
      groups.push(...children);
    } else {
      groups.push(output);
    }
  }
  buildCommon.tryCombineChars(groups);
  if (!isRealGroup) {
    return groups;
  }
  var glueOptions = options2;
  if (expression.length === 1) {
    var node = expression[0];
    if (node.type === "sizing") {
      glueOptions = options2.havingSize(node.size);
    } else if (node.type === "styling") {
      glueOptions = options2.havingStyle(styleMap$1[node.style]);
    }
  }
  var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options2);
  var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options2);
  var isRoot = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node2, prev) => {
    var prevType = prev.classes[0];
    var type = node2.classes[0];
    if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
      prev.classes[0] = "mord";
    } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
      node2.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  traverseNonSpaceNodes(groups, (node2, prev) => {
    var prevType = getTypeOfDomTree(prev);
    var type = getTypeOfDomTree(node2);
    var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
    if (space) {
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  return groups;
};
var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next, isRoot) {
  if (next) {
    nodes.push(next);
  }
  var i2 = 0;
  for (; i2 < nodes.length; i2++) {
    var node = nodes[i2];
    var partialGroup = checkPartialGroup(node);
    if (partialGroup) {
      traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
      continue;
    }
    var nonspace = !node.hasClass("mspace");
    if (nonspace) {
      var result2 = callback(node, prev.node);
      if (result2) {
        if (prev.insertAfter) {
          prev.insertAfter(result2);
        } else {
          nodes.unshift(result2);
          i2++;
        }
      }
    }
    if (nonspace) {
      prev.node = node;
    } else if (isRoot && node.hasClass("newline")) {
      prev.node = makeSpan$1(["leftmost"]);
    }
    prev.insertAfter = ((index) => (n2) => {
      nodes.splice(index + 1, 0, n2);
      i2++;
    })(i2);
  }
  if (next) {
    nodes.pop();
  }
};
var checkPartialGroup = function checkPartialGroup2(node) {
  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
    return node;
  }
  return null;
};
var getOutermostNode = function getOutermostNode2(node, side2) {
  var partialGroup = checkPartialGroup(node);
  if (partialGroup) {
    var children = partialGroup.children;
    if (children.length) {
      if (side2 === "right") {
        return getOutermostNode2(children[children.length - 1], "right");
      } else if (side2 === "left") {
        return getOutermostNode2(children[0], "left");
      }
    }
  }
  return node;
};
var getTypeOfDomTree = function getTypeOfDomTree2(node, side2) {
  if (!node) {
    return null;
  }
  if (side2) {
    node = getOutermostNode(node, side2);
  }
  return DomEnum[node.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter2(options2, classes) {
  var moreClasses = ["nulldelimiter"].concat(options2.baseSizingClasses());
  return makeSpan$1(classes.concat(moreClasses));
};
var buildGroup$1 = function buildGroup2(group, options2, baseOptions) {
  if (!group) {
    return makeSpan$1();
  }
  if (_htmlGroupBuilders[group.type]) {
    var groupNode = _htmlGroupBuilders[group.type](group, options2);
    if (baseOptions && options2.size !== baseOptions.size) {
      groupNode = makeSpan$1(options2.sizingClasses(baseOptions), [groupNode], options2);
      var multiplier = options2.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }
    return groupNode;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildHTMLUnbreakable(children, options2) {
  var body = makeSpan$1(["base"], children, options2);
  var strut = makeSpan$1(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);
  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }
  body.children.unshift(strut);
  return body;
}
function buildHTML(tree, options2) {
  var tag2 = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag2 = tree[0].tag;
    tree = tree[0].body;
  }
  var expression = buildExpression$1(tree, options2, "root");
  var eqnNum;
  if (expression.length === 2 && expression[1].hasClass("tag")) {
    eqnNum = expression.pop();
  }
  var children = [];
  var parts = [];
  for (var i2 = 0; i2 < expression.length; i2++) {
    parts.push(expression[i2]);
    if (expression[i2].hasClass("mbin") || expression[i2].hasClass("mrel") || expression[i2].hasClass("allowbreak")) {
      var nobreak = false;
      while (i2 < expression.length - 1 && expression[i2 + 1].hasClass("mspace") && !expression[i2 + 1].hasClass("newline")) {
        i2++;
        parts.push(expression[i2]);
        if (expression[i2].hasClass("nobreak")) {
          nobreak = true;
        }
      }
      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts, options2));
        parts = [];
      }
    } else if (expression[i2].hasClass("newline")) {
      parts.pop();
      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options2));
        parts = [];
      }
      children.push(expression[i2]);
    }
  }
  if (parts.length > 0) {
    children.push(buildHTMLUnbreakable(parts, options2));
  }
  var tagChild;
  if (tag2) {
    tagChild = buildHTMLUnbreakable(buildExpression$1(tag2, options2, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  } else if (eqnNum) {
    children.push(eqnNum);
  }
  var htmlNode = makeSpan$1(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true");
  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }
  return htmlNode;
}
function newDocumentFragment(children) {
  return new DocumentFragment(children);
}
class MathNode {
  constructor(type, children, classes) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
  }
  setAttribute(name, value) {
    this.attributes[name] = value;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  toNode() {
    var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }
    for (var i2 = 0; i2 < this.children.length; i2++) {
      node.appendChild(this.children[i2].toNode());
    }
    return node;
  }
  toMarkup() {
    var markup = "<" + this.type;
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="';
        markup += utils.escape(this.attributes[attr]);
        markup += '"';
      }
    }
    if (this.classes.length > 0) {
      markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
    }
    markup += ">";
    for (var i2 = 0; i2 < this.children.length; i2++) {
      markup += this.children[i2].toMarkup();
    }
    markup += "</" + this.type + ">";
    return markup;
  }
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
}
class TextNode {
  constructor(text2) {
    this.text = void 0;
    this.text = text2;
  }
  toNode() {
    return document.createTextNode(this.text);
  }
  toMarkup() {
    return utils.escape(this.toText());
  }
  toText() {
    return this.text;
  }
}
class SpaceNode {
  constructor(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width;
    if (width >= 0.05555 && width <= 0.05556) {
      this.character = "\u200A";
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = "\u2009";
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = "\u2005";
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "\u2005\u200A";
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = "\u200A\u2063";
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = "\u2009\u2063";
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = "\u205F\u2063";
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = "\u2005\u2063";
    } else {
      this.character = null;
    }
  }
  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node.setAttribute("width", makeEm(this.width));
      return node;
    }
  }
  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return '<mspace width="' + makeEm(this.width) + '"/>';
    }
  }
  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }
}
var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
};
var makeText = function makeText2(text2, mode, options2) {
  if (symbols[mode][text2] && symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options2 && (options2.fontFamily && options2.fontFamily.substr(4, 2) === "tt" || options2.font && options2.font.substr(4, 2) === "tt"))) {
    text2 = symbols[mode][text2].replace;
  }
  return new mathMLTree.TextNode(text2);
};
var makeRow = function makeRow2(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
var getVariant = function getVariant2(group, options2) {
  if (options2.fontFamily === "texttt") {
    return "monospace";
  } else if (options2.fontFamily === "textsf") {
    if (options2.fontShape === "textit" && options2.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options2.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options2.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options2.fontShape === "textit" && options2.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options2.fontShape === "textit") {
    return "italic";
  } else if (options2.fontWeight === "textbf") {
    return "bold";
  }
  var font = options2.font;
  if (!font || font === "mathnormal") {
    return null;
  }
  var mode = group.mode;
  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }
  var text2 = group.text;
  if (utils.contains(["\\imath", "\\jmath"], text2)) {
    return null;
  }
  if (symbols[mode][text2] && symbols[mode][text2].replace) {
    text2 = symbols[mode][text2].replace;
  }
  var fontName = buildCommon.fontMap[font].fontName;
  if (getCharacterMetrics(text2, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }
  return null;
};
var buildExpression = function buildExpression3(expression, options2, isOrdgroup) {
  if (expression.length === 1) {
    var group = buildGroup(expression[0], options2);
    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }
  var groups = [];
  var lastGroup;
  for (var i2 = 0; i2 < expression.length; i2++) {
    var _group = buildGroup(expression[i2], options2);
    if (_group instanceof MathNode && lastGroup instanceof MathNode) {
      if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
        var child = _group.children[0];
        if (child instanceof TextNode && child.text === ".") {
          lastGroup.children.push(..._group.children);
          continue;
        }
      } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];
        if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
          var _child = _group.children[0];
          if (_child instanceof TextNode && _child.text.length > 0) {
            _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
            groups.pop();
          }
        }
      }
    }
    groups.push(_group);
    lastGroup = _group;
  }
  return groups;
};
var buildExpressionRow = function buildExpressionRow2(expression, options2, isOrdgroup) {
  return makeRow(buildExpression(expression, options2, isOrdgroup));
};
var buildGroup = function buildGroup3(group, options2) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }
  if (_mathmlGroupBuilders[group.type]) {
    var result2 = _mathmlGroupBuilders[group.type](group, options2);
    return result2;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildMathML(tree, texExpression, options2, isDisplayMode, forMathmlOnly) {
  var expression = buildExpression(tree, options2);
  var wrapper;
  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }
  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math2 = new mathMLTree.MathNode("math", [semantics]);
  math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  if (isDisplayMode) {
    math2.setAttribute("display", "block");
  }
  var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
  return buildCommon.makeSpan([wrapperClass], [math2]);
}
var optionsFromSettings = function optionsFromSettings2(settings) {
  return new Options({
    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};
var displayWrap = function displayWrap2(node, settings) {
  if (settings.displayMode) {
    var classes = ["katex-display"];
    if (settings.leqno) {
      classes.push("leqno");
    }
    if (settings.fleqn) {
      classes.push("fleqn");
    }
    node = buildCommon.makeSpan(classes, [node]);
  }
  return node;
};
var buildTree = function buildTree2(tree, expression, settings) {
  var options2 = optionsFromSettings(settings);
  var katexNode;
  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options2, settings.displayMode, true);
  } else if (settings.output === "html") {
    var htmlNode = buildHTML(tree, options2);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    var mathMLNode = buildMathML(tree, expression, options2, settings.displayMode, false);
    var _htmlNode = buildHTML(tree, options2);
    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
  }
  return displayWrap(katexNode, settings);
};
var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
  var options2 = optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options2);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};
var stretchyCodePoint = {
  widehat: "^",
  widecheck: "\u02C7",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23DF",
  overbrace: "\u23DE",
  overgroup: "\u23E0",
  undergroup: "\u23E1",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21D2",
  xRightarrow: "\u21D2",
  overleftharpoon: "\u21BC",
  xleftharpoonup: "\u21BC",
  overrightharpoon: "\u21C0",
  xrightharpoonup: "\u21C0",
  xLeftarrow: "\u21D0",
  xLeftrightarrow: "\u21D4",
  xhookleftarrow: "\u21A9",
  xhookrightarrow: "\u21AA",
  xmapsto: "\u21A6",
  xrightharpoondown: "\u21C1",
  xleftharpoondown: "\u21BD",
  xrightleftharpoons: "\u21CC",
  xleftrightharpoons: "\u21CB",
  xtwoheadleftarrow: "\u219E",
  xtwoheadrightarrow: "\u21A0",
  xlongequal: "=",
  xtofrom: "\u21C4",
  xrightleftarrows: "\u21C4",
  xrightequilibrium: "\u21CC",
  xleftequilibrium: "\u21CB",
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};
var mathMLnode = function mathMLnode2(label) {
  var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
  node.setAttribute("stretchy", "true");
  return node;
};
var katexImagesData = {
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};
var groupLength = function groupLength2(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};
var svgSpan = function svgSpan2(group, options2) {
  function buildSvgSpan_() {
    var viewBoxWidth = 4e5;
    var label = group.label.substr(1);
    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
      var grp = group;
      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;
      var _height;
      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }
      var path2 = new PathNode(pathName);
      var svgNode = new SvgNode([path2], {
        "width": "100%",
        "height": makeEm(_height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options2),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data2 = katexImagesData[label];
      var [paths, _minWidth, _viewBoxHeight] = data2;
      var _height2 = _viewBoxHeight / 1e3;
      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;
      if (numSvgChildren === 1) {
        var align1 = data2[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }
      for (var i2 = 0; i2 < numSvgChildren; i2++) {
        var _path = new PathNode(paths[i2]);
        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": makeEm(_height2),
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i2] + " slice"
        });
        var _span = buildCommon.makeSvgSpan([widthClasses[i2]], [_svgNode], options2);
        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = makeEm(_height2);
          spans.push(_span);
        }
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options2),
        minWidth: _minWidth,
        height: _height2
      };
    }
  }
  var {
    span,
    minWidth,
    height
  } = buildSvgSpan_();
  span.height = height;
  span.style.height = makeEm(height);
  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }
  return span;
};
var encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options2) {
  var img;
  var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
  if (/fbox|color|angl/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options2);
    if (label === "fbox") {
      var color = options2.color && options2.getColor();
      if (color) {
        img.style.borderColor = color;
      }
    }
  } else {
    var lines = [];
    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }
    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }
    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options2);
  }
  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};
var stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
  }
  return node;
}
function assertSymbolNodeType(node) {
  var typedNode = checkSymbolNodeType(node);
  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
  }
  return typedNode;
}
function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
    return node;
  }
  return null;
}
var htmlBuilder$a = (grp, options2) => {
  var base2;
  var group;
  var supSubGroup;
  if (grp && grp.type === "supsub") {
    group = assertNodeType(grp.base, "accent");
    base2 = group.base;
    grp.base = base2;
    supSubGroup = assertSpan(buildGroup$1(grp, options2));
    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base2 = group.base;
  }
  var body = buildGroup$1(base2, options2.havingCrampedStyle());
  var mustShift = group.isShifty && utils.isCharacterBox(base2);
  var skew = 0;
  if (mustShift) {
    var baseChar = utils.getBaseElem(base2);
    var baseGroup = buildGroup$1(baseChar, options2.havingCrampedStyle());
    skew = assertSymbolDomNode(baseGroup).skew;
  }
  var accentBelow = group.label === "\\c";
  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options2.fontMetrics().xHeight);
  var accentBody;
  if (!group.isStretchy) {
    var accent2;
    var width;
    if (group.label === "\\vec") {
      accent2 = buildCommon.staticSvg("vec", options2);
      width = buildCommon.svgData.vec[1];
    } else {
      accent2 = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options2, "textord");
      accent2 = assertSymbolDomNode(accent2);
      accent2.italic = 0;
      width = accent2.width;
      if (accentBelow) {
        clearance += accent2.depth;
      }
    }
    accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
    var accentFull = group.label === "\\textcircled";
    if (accentFull) {
      accentBody.classes.push("accent-full");
      clearance = body.height;
    }
    var left2 = skew;
    if (!accentFull) {
      left2 -= width / 2;
    }
    accentBody.style.left = makeEm(left2);
    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options2);
  } else {
    accentBody = stretchy.svgSpan(group, options2);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew) + ")",
          marginLeft: makeEm(2 * skew)
        } : void 0
      }]
    }, options2);
  }
  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options2);
  if (supSubGroup) {
    supSubGroup.children[0] = accentWrap;
    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};
var mathmlBuilder$9 = (group, options2) => {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  var node = new mathMLTree.MathNode("mover", [buildGroup(group.base, options2), accentNode]);
  node.setAttribute("accent", "true");
  return node;
};
var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context2, args) => {
    var base2 = normalizeArgument(args[0]);
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context2.funcName);
    var isShifty = !isStretchy || context2.funcName === "\\widehat" || context2.funcName === "\\widetilde" || context2.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context2.parser.mode,
      label: context2.funcName,
      isStretchy,
      isShifty,
      base: base2
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["primitive"]
  },
  handler: (context2, args) => {
    var base2 = args[0];
    var mode = context2.parser.mode;
    if (mode === "math") {
      context2.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context2.funcName + " works only in text mode");
      mode = "text";
    }
    return {
      type: "accent",
      mode,
      label: context2.funcName,
      isStretchy: false,
      isShifty: true,
      base: base2
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var base2 = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base2
    };
  },
  htmlBuilder: (group, options2) => {
    var innerGroup = buildGroup$1(group.base, options2);
    var accentBody = stretchy.svgSpan(group, options2);
    var kern = group.label === "\\utilde" ? 0.12 : 0;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options2);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options2);
  },
  mathmlBuilder: (group, options2) => {
    var accentNode = stretchy.mathMLnode(group.label);
    var node = new mathMLTree.MathNode("munder", [buildGroup(group.base, options2), accentNode]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
var paddedNode = (group) => {
  var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node.setAttribute("width", "+0.6em");
  node.setAttribute("lspace", "0.3em");
  return node;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  htmlBuilder(group, options2) {
    var style = options2.style;
    var newOptions = options2.havingStyle(style.sup());
    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options2), options2);
    var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    var lowerGroup;
    if (group.below) {
      newOptions = options2.havingStyle(style.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options2), options2);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }
    var arrowBody = stretchy.svgSpan(group, options2);
    var arrowShift = -options2.fontMetrics().axisHeight + 0.5 * arrowBody.height;
    var upperShift = -options2.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth;
    }
    var vlist;
    if (lowerGroup) {
      var lowerShift = -options2.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options2);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options2);
    }
    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options2);
  },
  mathmlBuilder(group, options2) {
    var arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var node;
    if (group.body) {
      var upperNode = paddedNode(buildGroup(group.body, options2));
      if (group.below) {
        var lowerNode = paddedNode(buildGroup(group.below, options2));
        node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = paddedNode(buildGroup(group.below, options2));
      node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      node = paddedNode();
      node = new mathMLTree.MathNode("mover", [arrowNode, node]);
    }
    return node;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};
var newCell = () => {
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};
var isStartOfArrow = (node) => {
  return node.type === "textord" && node.text === "@";
};
var isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};
function cdArrow(arrowChar, labels, parser) {
  var funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      var bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      var arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel]
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var arrow = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return parser.callFunction("\\Big", [arrow], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(parser) {
  var parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    var next = parser.fetch().text;
    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop();
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  var row = [];
  var body = [row];
  for (var i2 = 0; i2 < parsedRows.length; i2++) {
    var rowNodes = parsedRows[i2];
    var cell = newCell();
    for (var j2 = 0; j2 < rowNodes.length; j2++) {
      if (!isStartOfArrow(rowNodes[j2])) {
        cell.body.push(rowNodes[j2]);
      } else {
        row.push(cell);
        j2 += 1;
        var arrowChar = assertSymbolNodeType(rowNodes[j2]).text;
        var labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        if ("=|.".indexOf(arrowChar) > -1)
          ;
        else if ("<>AV".indexOf(arrowChar) > -1) {
          for (var labelNum = 0; labelNum < 2; labelNum++) {
            var inLabel = true;
            for (var k2 = j2 + 1; k2 < rowNodes.length; k2++) {
              if (isLabelEnd(rowNodes[k2], arrowChar)) {
                inLabel = false;
                j2 = k2;
                break;
              }
              if (isStartOfArrow(rowNodes[k2])) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k2]);
              }
              labels[labelNum].body.push(rowNodes[k2]);
            }
            if (inLabel) {
              throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j2]);
            }
          }
        } else {
          throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j2]);
        }
        var arrow = cdArrow(arrowChar, labels, parser);
        var wrappedArrow = {
          type: "styling",
          body: [arrow],
          mode: "math",
          style: "display"
        };
        row.push(wrappedArrow);
        cell = newCell();
      }
    }
    if (i2 % 2 === 0) {
      row.push(cell);
    } else {
      row.shift();
    }
    row = [];
    body.push(row);
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  var cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    postgap: 0.25
  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  htmlBuilder(group, options2) {
    var newOptions = options2.havingStyle(options2.style.sup());
    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options2), options2);
    label.classes.push("cd-label-" + group.side);
    label.style.bottom = makeEm(0.8 - label.depth);
    label.height = 0;
    label.depth = 0;
    return label;
  },
  mathmlBuilder(group, options2) {
    var label = new mathMLTree.MathNode("mrow", [buildGroup(group.label, options2)]);
    label = new mathMLTree.MathNode("mpadded", [label]);
    label.setAttribute("width", "0");
    if (group.side === "left") {
      label.setAttribute("lspace", "-1width");
    }
    label.setAttribute("voffset", "0.7em");
    label = new mathMLTree.MathNode("mstyle", [label]);
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    return label;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  htmlBuilder(group, options2) {
    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options2), options2);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },
  mathmlBuilder(group, options2) {
    return new mathMLTree.MathNode("mrow", [buildGroup(group.fragment, options2)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number = "";
    for (var i2 = 0; i2 < group.length; i2++) {
      var node = assertNodeType(group[i2], "textord");
      number += node.text;
    }
    var code2 = parseInt(number);
    var text2;
    if (isNaN(code2)) {
      throw new ParseError("\\@char has non-numeric argument " + number);
    } else if (code2 < 0 || code2 >= 1114111) {
      throw new ParseError("\\@char with invalid code point " + number);
    } else if (code2 <= 65535) {
      text2 = String.fromCharCode(code2);
    } else {
      code2 -= 65536;
      text2 = String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: text2
    };
  }
});
var htmlBuilder$9 = (group, options2) => {
  var elements = buildExpression$1(group.body, options2.withColor(group.color), false);
  return buildCommon.makeFragment(elements);
};
var mathmlBuilder$8 = (group, options2) => {
  var inner2 = buildExpression(group.body, options2.withColor(group.color));
  var node = new mathMLTree.MathNode("mstyle", inner2);
  node.setAttribute("mathcolor", group.color);
  return node;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },
  handler(_ref2, args) {
    var {
      parser,
      breakOnTokenText
    } = _ref2;
    var color = assertNodeType(args[0], "color-token").color;
    parser.gullet.macros.set("\\current@color", color);
    var body = parser.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser.mode,
      color,
      body
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 1,
    argTypes: ["size"],
    allowedInText: true
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var size = optArgs[0];
    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    };
  },
  htmlBuilder(group, options2) {
    var span = buildCommon.makeSpan(["mspace"], [], options2);
    if (group.newLine) {
      span.classes.push("newline");
      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options2));
      }
    }
    return span;
  },
  mathmlBuilder(group, options2) {
    var node = new mathMLTree.MathNode("mspace");
    if (group.newLine) {
      node.setAttribute("linebreak", "newline");
      if (group.size) {
        node.setAttribute("height", makeEm(calculateSize(group.size, options2)));
      }
    }
    return node;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};
var checkControlSequence = (tok) => {
  var name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};
var getRHS = (parser) => {
  var tok = parser.gullet.popToken();
  if (tok.text === "=") {
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};
var letCommand = (parser, name, tok, global2) => {
  var macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name, macro, global2);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser,
      funcName
    } = _ref;
    parser.consumeSpaces();
    var token = parser.fetch();
    if (globalMap[token.text]) {
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError("Invalid token after macro prefix", token);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref2) {
    var {
      parser,
      funcName
    } = _ref2;
    var tok = parser.gullet.popToken();
    var name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }
    var numArgs = 0;
    var insert;
    var delimiters2 = [[]];
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters2[numArgs].push("{");
          break;
        }
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError('Invalid argument number "' + tok.text + '"');
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError('Argument number "' + tok.text + '" out of order');
        }
        numArgs++;
        delimiters2.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters2[numArgs].push(tok.text);
      }
    }
    var {
      tokens
    } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }
    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      tokens.reverse();
    }
    parser.gullet.macros.set(name, {
      tokens,
      numArgs,
      delimiters: delimiters2
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    var name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    var tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    var name = checkControlSequence(parser.gullet.popToken());
    var middle = parser.gullet.popToken();
    var tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
var getMetrics = function getMetrics2(symbol, font, mode) {
  var replace = symbols.math[symbol] && symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace || symbol, font, mode);
  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }
  return metrics;
};
var styleWrap = function styleWrap2(delim, toStyle, options2, classes) {
  var newOptions = options2.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options2)), [delim], options2);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options2.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};
var centerSpan = function centerSpan2(span, options2, style) {
  var newOptions = options2.havingBaseStyle(style);
  var shift = (1 - options2.sizeMultiplier / newOptions.sizeMultiplier) * options2.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift);
  span.height -= shift;
  span.depth += shift;
};
var makeSmallDelim = function makeSmallDelim2(delim, style, center, options2, mode, classes) {
  var text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options2);
  var span = styleWrap(text2, style, options2, classes);
  if (center) {
    centerSpan(span, options2, style);
  }
  return span;
};
var mathrmSize = function mathrmSize2(value, size, mode, options2) {
  return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options2);
};
var makeLargeDelim = function makeLargeDelim2(delim, size, center, options2, mode, classes) {
  var inner2 = mathrmSize(delim, size, mode, options2);
  var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options2), Style$1.TEXT, options2, classes);
  if (center) {
    centerSpan(span, options2, Style$1.TEXT);
  }
  return span;
};
var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
  var sizeClass;
  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else {
    sizeClass = "delim-size4";
  }
  var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
  return {
    type: "elem",
    elem: corner
  };
};
var makeInner = function makeInner2(ch2, height, options2) {
  var width = fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch2.charCodeAt(0)][4];
  var path2 = new PathNode("inner", innerPath(ch2, Math.round(1e3 * height)));
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon.makeSvgSpan([], [svgNode], options2);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return {
    type: "elem",
    elem: span
  };
};
var lapInEms = 8e-3;
var lap = {
  type: "kern",
  size: -1 * lapInEms
};
var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options2, mode, classes) {
  var top;
  var middle;
  var repeat;
  var bottom;
  top = repeat = bottom = delim;
  middle = null;
  var font = "Size1-Regular";
  if (delim === "\\uparrow") {
    repeat = bottom = "\u23D0";
  } else if (delim === "\\Uparrow") {
    repeat = bottom = "\u2016";
  } else if (delim === "\\downarrow") {
    top = repeat = "\u23D0";
  } else if (delim === "\\Downarrow") {
    top = repeat = "\u2016";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat = "\u23D0";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat = "\u2016";
    bottom = "\\Downarrow";
  } else if (utils.contains(verts, delim)) {
    repeat = "\u2223";
  } else if (utils.contains(doubleVerts, delim)) {
    repeat = "\u2225";
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "\u23A1";
    repeat = "\u23A2";
    bottom = "\u23A3";
    font = "Size4-Regular";
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "\u23A4";
    repeat = "\u23A5";
    bottom = "\u23A6";
    font = "Size4-Regular";
  } else if (delim === "\\lfloor" || delim === "\u230A") {
    repeat = top = "\u23A2";
    bottom = "\u23A3";
    font = "Size4-Regular";
  } else if (delim === "\\lceil" || delim === "\u2308") {
    top = "\u23A1";
    repeat = bottom = "\u23A2";
    font = "Size4-Regular";
  } else if (delim === "\\rfloor" || delim === "\u230B") {
    repeat = top = "\u23A5";
    bottom = "\u23A6";
    font = "Size4-Regular";
  } else if (delim === "\\rceil" || delim === "\u2309") {
    top = "\u23A4";
    repeat = bottom = "\u23A5";
    font = "Size4-Regular";
  } else if (delim === "(" || delim === "\\lparen") {
    top = "\u239B";
    repeat = "\u239C";
    bottom = "\u239D";
    font = "Size4-Regular";
  } else if (delim === ")" || delim === "\\rparen") {
    top = "\u239E";
    repeat = "\u239F";
    bottom = "\u23A0";
    font = "Size4-Regular";
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "\u23A7";
    middle = "\u23A8";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "\u23AB";
    middle = "\u23AC";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "\u27EE") {
    top = "\u23A7";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "\u27EF") {
    top = "\u23AB";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "\u23B0") {
    top = "\u23A7";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "\u23B1") {
    top = "\u23AB";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  }
  var topMetrics = getMetrics(top, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = getMetrics(repeat, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = getMetrics(bottom, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;
  if (middle !== null) {
    var middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2;
  }
  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
  var axisHeight = options2.fontMetrics().axisHeight;
  if (center) {
    axisHeight *= options2.sizeMultiplier;
  }
  var depth = realHeightTotal / 2 - axisHeight;
  var stack = [];
  stack.push(makeGlyphSpan(bottom, font, mode));
  stack.push(lap);
  if (middle === null) {
    var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
    stack.push(makeInner(repeat, innerHeight, options2));
  } else {
    var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
    stack.push(makeInner(repeat, _innerHeight, options2));
    stack.push(lap);
    stack.push(makeGlyphSpan(middle, font, mode));
    stack.push(lap);
    stack.push(makeInner(repeat, _innerHeight, options2));
  }
  stack.push(lap);
  stack.push(makeGlyphSpan(top, font, mode));
  var newOptions = options2.havingBaseStyle(Style$1.TEXT);
  var inner2 = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options2, classes);
};
var vbPad = 80;
var emPad = 0.08;
var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraViniculum, options2) {
  var path2 = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
  var pathNode = new PathNode(sqrtName, path2);
  var svg = new SvgNode([pathNode], {
    "width": "400em",
    "height": makeEm(height),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg], options2);
};
var makeSqrtImage = function makeSqrtImage2(height, options2) {
  var newOptions = options2.havingBaseSizing();
  var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier;
  var extraViniculum = Math.max(0, options2.minRuleThickness - options2.fontMetrics().sqrtRuleThickness);
  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth;
  if (delim.type === "small") {
    viewBoxHeight = 1e3 + 1e3 * extraViniculum + vbPad;
    if (height < 1) {
      sizeMultiplier = 1;
    } else if (height < 1.4) {
      sizeMultiplier = 0.7;
    }
    spanHeight = (1 + extraViniculum + emPad) / sizeMultiplier;
    texHeight = (1 + extraViniculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options2);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier;
  } else if (delim.type === "large") {
    viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options2);
    span.style.minWidth = "1.02em";
    advanceWidth = 1 / sizeMultiplier;
  } else {
    spanHeight = height + extraViniculum + emPad;
    texHeight = height + extraViniculum;
    viewBoxHeight = Math.floor(1e3 * height + extraViniculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options2);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }
  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    ruleWidth: (options2.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
  };
};
var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
var makeSizedDelim = function makeSizedDelim2(delim, size, options2, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  }
  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
    return makeLargeDelim(delim, size, false, options2, mode, classes);
  } else if (utils.contains(stackAlwaysDelimiters, delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options2, mode, classes);
  } else {
    throw new ParseError("Illegal delimiter: '" + delim + "'");
  }
};
var stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}];
var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}];
var stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
var delimTypeToFont = function delimTypeToFont2(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
var traverseSequence = function traverseSequence2(delim, height, sequence, options2) {
  var start = Math.min(2, 3 - options2.style.size);
  for (var i2 = start; i2 < sequence.length; i2++) {
    if (sequence[i2].type === "stack") {
      break;
    }
    var metrics = getMetrics(delim, delimTypeToFont(sequence[i2]), "math");
    var heightDepth = metrics.height + metrics.depth;
    if (sequence[i2].type === "small") {
      var newOptions = options2.havingBaseStyle(sequence[i2].style);
      heightDepth *= newOptions.sizeMultiplier;
    }
    if (heightDepth > height) {
      return sequence[i2];
    }
  }
  return sequence[sequence.length - 1];
};
var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options2, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  }
  var sequence;
  if (utils.contains(stackNeverDelimiters, delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (utils.contains(stackLargeDelimiters, delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  }
  var delimType = traverseSequence(delim, height, sequence, options2);
  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center, options2, mode, classes);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, options2, mode, classes);
  } else {
    return makeStackedDelim(delim, height, center, options2, mode, classes);
  }
};
var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options2, mode, classes) {
  var axisHeight = options2.fontMetrics().axisHeight * options2.sizeMultiplier;
  var delimiterFactor = 901;
  var delimiterExtend = 5 / options2.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  var totalHeight = Math.max(maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);
  return makeCustomSizedDelim(delim, totalHeight, true, options2, mode, classes);
};
var delimiter = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
};
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(delim, context2) {
  var symDelim = checkSymbolNodeType(delim);
  if (symDelim && utils.contains(delimiters, symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context2.funcName + "'", delim);
  } else {
    throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
  }
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context2, args) => {
    var delim = checkDelimiter(args[0], context2);
    return {
      type: "delimsizing",
      mode: context2.parser.mode,
      size: delimiterSizes[context2.funcName].size,
      mclass: delimiterSizes[context2.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options2) => {
    if (group.delim === ".") {
      return buildCommon.makeSpan([group.mclass]);
    }
    return delimiter.sizedDelim(group.delim, group.size, options2, group.mode, [group.mclass]);
  },
  mathmlBuilder: (group) => {
    var children = [];
    if (group.delim !== ".") {
      children.push(makeText(group.delim, group.mode));
    }
    var node = new mathMLTree.MathNode("mo", children);
    if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.setAttribute("fence", "true");
    } else {
      node.setAttribute("fence", "false");
    }
    node.setAttribute("stretchy", "true");
    var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
    node.setAttribute("minsize", size);
    node.setAttribute("maxsize", size);
    return node;
  }
});
function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context2, args) => {
    var color = context2.parser.gullet.macros.get("\\current@color");
    if (color && typeof color !== "string") {
      throw new ParseError("\\current@color set to non-string in \\right");
    }
    return {
      type: "leftright-right",
      mode: context2.parser.mode,
      delim: checkDelimiter(args[0], context2).text,
      color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context2, args) => {
    var delim = checkDelimiter(args[0], context2);
    var parser = context2.parser;
    ++parser.leftrightDepth;
    var body = parser.parseExpression(false);
    --parser.leftrightDepth;
    parser.expect("\\right", false);
    var right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim,
      rightColor: right.color
    };
  },
  htmlBuilder: (group, options2) => {
    assertParsed(group);
    var inner2 = buildExpression$1(group.body, options2, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;
    for (var i2 = 0; i2 < inner2.length; i2++) {
      if (inner2[i2].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner2[i2].height, innerHeight);
        innerDepth = Math.max(inner2[i2].depth, innerDepth);
      }
    }
    innerHeight *= options2.sizeMultiplier;
    innerDepth *= options2.sizeMultiplier;
    var leftDelim;
    if (group.left === ".") {
      leftDelim = makeNullDelimiter(options2, ["mopen"]);
    } else {
      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options2, group.mode, ["mopen"]);
    }
    inner2.unshift(leftDelim);
    if (hadMiddle) {
      for (var _i6 = 1; _i6 < inner2.length; _i6++) {
        var middleDelim = inner2[_i6];
        var isMiddle = middleDelim.isMiddle;
        if (isMiddle) {
          inner2[_i6] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }
    var rightDelim;
    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options2, ["mclose"]);
    } else {
      var colorOptions = group.rightColor ? options2.withColor(group.rightColor) : options2;
      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    }
    inner2.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner2, options2);
  },
  mathmlBuilder: (group, options2) => {
    assertParsed(group);
    var inner2 = buildExpression(group.body, options2);
    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner2.unshift(leftNode);
    }
    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");
      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }
      inner2.push(rightNode);
    }
    return makeRow(inner2);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context2, args) => {
    var delim = checkDelimiter(args[0], context2);
    if (!context2.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }
    return {
      type: "middle",
      mode: context2.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options2) => {
    var middleDelim;
    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options2, []);
    } else {
      middleDelim = delimiter.sizedDelim(group.delim, 1, options2, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options: options2
      };
      middleDelim.isMiddle = isMiddle;
    }
    return middleDelim;
  },
  mathmlBuilder: (group, options2) => {
    var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
var htmlBuilder$8 = (group, options2) => {
  var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options2), options2);
  var label = group.label.substr(1);
  var scale = options2.sizeMultiplier;
  var img;
  var imgShift = 0;
  var isSingleChar = utils.isCharacterBox(group.body);
  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options2.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options2.fontMetrics().xHeight;
  } else if (label === "phase") {
    var lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options2);
    var clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options2);
    var newOptions = options2.havingBaseSizing();
    scale = scale / newOptions.sizeMultiplier;
    var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
    inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
    var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
    var path2 = phasePath(viewBoxHeight);
    var svgNode = new SvgNode([new PathNode("phase", path2)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1e3),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    });
    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options2);
    img.style.height = makeEm(angleHeight);
    imgShift = inner2.depth + lineWeight + clearance;
  } else {
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner2.classes.push("cancel-pad");
      }
    } else if (label === "angl") {
      inner2.classes.push("anglpad");
    } else {
      inner2.classes.push("boxpad");
    }
    var topPad = 0;
    var bottomPad = 0;
    var ruleThickness = 0;
    if (/box/.test(label)) {
      ruleThickness = Math.max(options2.fontMetrics().fboxrule, options2.minRuleThickness);
      topPad = options2.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label === "angl") {
      ruleThickness = Math.max(options2.fontMetrics().defaultRuleThickness, options2.minRuleThickness);
      topPad = 4 * ruleThickness;
      bottomPad = Math.max(0, 0.25 - inner2.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }
    img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options2);
    if (/fbox|boxed|fcolorbox/.test(label)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }
    imgShift = inner2.depth + bottomPad;
    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;
      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }
  var vlist;
  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        {
          type: "elem",
          elem: img,
          shift: imgShift
        },
        {
          type: "elem",
          elem: inner2,
          shift: 0
        }
      ]
    }, options2);
  } else {
    var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        {
          type: "elem",
          elem: inner2,
          shift: 0
        },
        {
          type: "elem",
          elem: img,
          shift: imgShift,
          wrapperClasses: classes
        }
      ]
    }, options2);
  }
  if (/cancel/.test(label)) {
    vlist.height = inner2.height;
    vlist.depth = inner2.depth;
  }
  if (/cancel/.test(label) && !isSingleChar) {
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options2);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options2);
  }
};
var mathmlBuilder$7 = (group, options2) => {
  var fboxsep = 0;
  var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup(group.body, options2)]);
  switch (group.label) {
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      node.setAttribute("notation", "box");
      break;
    case "\\angl":
      node.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      fboxsep = options2.fontMetrics().fboxsep * options2.fontMetrics().ptPerEm;
      node.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node.setAttribute("lspace", fboxsep + "pt");
      node.setAttribute("voffset", fboxsep + "pt");
      if (group.label === "\\fcolorbox") {
        var thk = Math.max(options2.fontMetrics().fboxrule, options2.minRuleThickness);
        node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }
      break;
    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }
  return node;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },
  handler(_ref2, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref2;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler(_ref3, args) {
    var {
      parser
    } = _ref3;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(_ref4, args) {
    var {
      parser,
      funcName
    } = _ref4;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },
  handler(_ref5, args) {
    var {
      parser
    } = _ref5;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\angl",
      body: args[0]
    };
  }
});
var _environments = {};
function defineEnvironment(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data2 = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (var i2 = 0; i2 < names.length; ++i2) {
    _environments[names[i2]] = data2;
  }
  if (htmlBuilder3) {
    _htmlGroupBuilders[type] = htmlBuilder3;
  }
  if (mathmlBuilder3) {
    _mathmlGroupBuilders[type] = mathmlBuilder3;
  }
}
function getHLines(parser) {
  var hlineInfo = [];
  parser.consumeSpaces();
  var nxt = parser.fetch().text;
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}
var validateAmsEnvironmentContext = (context2) => {
  var settings = context2.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError("{" + context2.envName + "} can be used only in display mode.");
  }
};
function parseArray(parser, _ref, style) {
  var {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    addEqnNum,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser.gullet.beginGroup();
  if (!singleRow) {
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }
  if (!arraystretch) {
    var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
    if (stretch == null) {
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);
      if (!arraystretch || arraystretch < 0) {
        throw new ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  }
  parser.gullet.beginGroup();
  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = [];
  hLinesBeforeRow.push(getHLines(parser));
  while (true) {
    var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell
    };
    if (style) {
      cell = {
        type: "styling",
        mode: parser.mode,
        style,
        body: [cell]
      };
    }
    row.push(cell);
    var next = parser.fetch().text;
    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          throw new ParseError("Too many tab characters: &", parser.nextToken);
        } else {
          parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
        }
      }
      parser.consume();
    } else if (next === "\\end") {
      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next === "\\\\") {
      parser.consume();
      var size = void 0;
      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      hLinesBeforeRow.push(getHLines(parser));
      row = [];
      body.push(row);
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  return {
    type: "array",
    mode: parser.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    addEqnNum,
    leqno
  };
}
function dCellStyle(envName) {
  if (envName.substr(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}
var htmlBuilder$7 = function htmlBuilder2(group, options2) {
  var r2;
  var c2;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = [];
  var ruleThickness = Math.max(options2.fontMetrics().arrayRuleWidth, options2.minRuleThickness);
  var pt = 1 / options2.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt;
  if (group.colSeparationType && group.colSeparationType === "small") {
    var localMultiplier = options2.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options2.sizeMultiplier);
  }
  var baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options2) : 12 * pt;
  var jot = 3 * pt;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip;
  var arstrutDepth = 0.3 * arrayskip;
  var totalHeight = 0;
  function setHLinePos(hlinesInGap) {
    for (var i2 = 0; i2 < hlinesInGap.length; ++i2) {
      if (i2 > 0) {
        totalHeight += 0.25;
      }
      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i2]
      });
    }
  }
  setHLinePos(hLinesBeforeRow[0]);
  for (r2 = 0; r2 < group.body.length; ++r2) {
    var inrow = group.body[r2];
    var height = arstrutHeight;
    var depth = arstrutDepth;
    if (nc < inrow.length) {
      nc = inrow.length;
    }
    var outrow = new Array(inrow.length);
    for (c2 = 0; c2 < inrow.length; ++c2) {
      var elt = buildGroup$1(inrow[c2], options2);
      if (depth < elt.depth) {
        depth = elt.depth;
      }
      if (height < elt.height) {
        height = elt.height;
      }
      outrow[c2] = elt;
    }
    var rowGap = group.rowGaps[r2];
    var gap = 0;
    if (rowGap) {
      gap = calculateSize(rowGap, options2);
      if (gap > 0) {
        gap += arstrutDepth;
        if (depth < gap) {
          depth = gap;
        }
        gap = 0;
      }
    }
    if (group.addJot) {
      depth += jot;
    }
    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap;
    body[r2] = outrow;
    setHLinePos(hLinesBeforeRow[r2 + 1]);
  }
  var offset = totalHeight / 2 + options2.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;
  var eqnNumSpans = [];
  if (group.addEqnNum) {
    for (r2 = 0; r2 < nr; ++r2) {
      var rw = body[r2];
      var shift = rw.pos - offset;
      var eqnTag = buildCommon.makeSpan(["eqn-num"], [], options2);
      eqnTag.depth = rw.depth;
      eqnTag.height = rw.height;
      eqnNumSpans.push({
        type: "elem",
        elem: eqnTag,
        shift
      });
    }
  }
  for (c2 = 0, colDescrNum = 0; c2 < nc || colDescrNum < colDescriptions.length; ++c2, ++colDescrNum) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;
    while (colDescr.type === "separator") {
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options2.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }
      if (colDescr.separator === "|" || colDescr.separator === ":") {
        var lineType = colDescr.separator === "|" ? "solid" : "dashed";
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options2);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
        var _shift = totalHeight - offset;
        if (_shift) {
          separator.style.verticalAlign = makeEm(-_shift);
        }
        cols.push(separator);
      } else {
        throw new ParseError("Invalid separator type: " + colDescr.separator);
      }
      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }
    if (c2 >= nc) {
      continue;
    }
    var sepwidth = void 0;
    if (c2 > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
    var col = [];
    for (r2 = 0; r2 < nr; ++r2) {
      var row = body[r2];
      var elem = row[c2];
      if (!elem) {
        continue;
      }
      var _shift2 = row.pos - offset;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem,
        shift: _shift2
      });
    }
    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options2);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);
    if (c2 < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }
  body = buildCommon.makeSpan(["mtable"], cols);
  if (hlines.length > 0) {
    var line = buildCommon.makeLineSpan("hline", options2, ruleThickness);
    var dashes = buildCommon.makeLineSpan("hdashline", options2, ruleThickness);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];
    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset;
      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }
    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options2);
  }
  if (!group.addEqnNum) {
    return buildCommon.makeSpan(["mord"], [body], options2);
  } else {
    var eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: eqnNumSpans
    }, options2);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options2);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};
var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};
var mathmlBuilder$6 = function mathmlBuilder2(group, options2) {
  var tbl = [];
  var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  var tag2 = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
  for (var i2 = 0; i2 < group.body.length; i2++) {
    var rw = group.body[i2];
    var row = [];
    for (var j2 = 0; j2 < rw.length; j2++) {
      row.push(new mathMLTree.MathNode("mtd", [buildGroup(rw[j2], options2)]));
    }
    if (group.addEqnNum) {
      row.unshift(glue);
      row.push(glue);
      if (group.leqno) {
        row.unshift(tag2);
      } else {
        row.push(tag2);
      }
    }
    tbl.push(new mathMLTree.MathNode("mtr", row));
  }
  var table = new mathMLTree.MathNode("mtable", tbl);
  var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table.setAttribute("rowspacing", makeEm(gap));
  var menclose = "";
  var align = "";
  if (group.cols && group.cols.length > 0) {
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;
    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }
    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }
    for (var _i6 = iStart; _i6 < iEnd; _i6++) {
      if (cols[_i6].type === "align") {
        align += alignMap[cols[_i6].align];
        if (prevTypeWasAlign) {
          columnLines += "none ";
        }
        prevTypeWasAlign = true;
      } else if (cols[_i6].type === "separator") {
        if (prevTypeWasAlign) {
          columnLines += cols[_i6].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }
    table.setAttribute("columnalign", align.trim());
    if (/[sd]/.test(columnLines)) {
      table.setAttribute("columnlines", columnLines.trim());
    }
  }
  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];
    var spacing2 = "";
    for (var _i22 = 1; _i22 < _cols.length; _i22++) {
      spacing2 += _i22 % 2 ? "0em " : "1em ";
    }
    table.setAttribute("columnspacing", spacing2.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table.setAttribute("columnspacing", "0.5em");
  } else {
    table.setAttribute("columnspacing", "1em");
  }
  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
  for (var _i32 = 1; _i32 < hlines.length - 1; _i32++) {
    rowLines += hlines[_i32].length === 0 ? "none " : hlines[_i32][0] ? "dashed " : "solid ";
  }
  if (/[sd]/.test(rowLines)) {
    table.setAttribute("rowlines", rowLines.trim());
  }
  if (menclose !== "") {
    table = new mathMLTree.MathNode("menclose", [table]);
    table.setAttribute("notation", menclose.trim());
  }
  if (group.arraystretch && group.arraystretch < 1) {
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }
  return table;
};
var alignedHandler = function alignedHandler2(context2, args) {
  if (context2.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context2);
  }
  var cols = [];
  var separationType = context2.envName.indexOf("at") > -1 ? "alignat" : "align";
  var res = parseArray(context2.parser, {
    cols,
    addJot: true,
    addEqnNum: context2.envName === "align" || context2.envName === "alignat",
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: context2.envName === "split" ? 2 : void 0,
    leqno: context2.parser.settings.leqno
  }, "display");
  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context2.mode,
    body: []
  };
  if (args[0] && args[0].type === "ordgroup") {
    var arg0 = "";
    for (var i2 = 0; i2 < args[0].body.length; i2++) {
      var textord2 = assertNodeType(args[0].body[i2], "textord");
      arg0 += textord2.text;
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  var isAligned = !numCols;
  res.body.forEach(function(row) {
    for (var _i42 = 1; _i42 < row.length; _i42 += 2) {
      var styling = assertNodeType(row[_i42], "styling");
      var ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }
    if (!isAligned) {
      var curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      numCols = row.length;
    }
  });
  for (var _i52 = 0; _i52 < numCols; ++_i52) {
    var align = "r";
    var pregap = 0;
    if (_i52 % 2 === 1) {
      align = "l";
    } else if (_i52 > 0 && isAligned) {
      pregap = 1;
    }
    cols[_i52] = {
      type: "align",
      align,
      pregap,
      postgap: 0
    };
  }
  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context2, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    var res = {
      cols,
      hskipBeforeAndAfter: true,
      maxNumCols: cols.length
    };
    return parseArray(context2.parser, res, dCellStyle(context2.envName));
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(context2) {
    var delimiters2 = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context2.envName.replace("*", "")];
    var colAlign = "c";
    var payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };
    if (context2.envName.charAt(context2.envName.length - 1) === "*") {
      var parser = context2.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }
    var res = parseArray(context2.parser, payload, dCellStyle(context2.envName));
    var numCols = Math.max(0, ...res.body.map((row) => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters2 ? {
      type: "leftright",
      mode: context2.mode,
      body: [res],
      left: delimiters2[0],
      right: delimiters2[1],
      rightColor: void 0
    } : res;
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context2) {
    var payload = {
      arraystretch: 0.5
    };
    var res = parseArray(context2.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context2, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text;
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    var res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context2.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context2) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 1
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context2.parser, payload, dCellStyle(context2.envName));
    return {
      type: "leftright",
      mode: context2.mode,
      body: [res],
      left: context2.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context2.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context2) {
    if (utils.contains(["gather", "gather*"], context2.envName)) {
      validateAmsEnvironmentContext(context2);
    }
    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      addEqnNum: context2.envName === "gather",
      emptySingleRow: true,
      leqno: context2.parser.settings.leqno
    };
    return parseArray(context2.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context2) {
    validateAmsEnvironmentContext(context2);
    var res = {
      addEqnNum: context2.envName === "equation",
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context2.parser.settings.leqno
    };
    return parseArray(context2.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context2) {
    validateAmsEnvironmentContext(context2);
    return parseCD(context2.parser);
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "text",
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context2, args) {
    throw new ParseError(context2.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    var envName = "";
    for (var i2 = 0; i2 < nameGroup.body.length; ++i2) {
      envName += assertNodeType(nameGroup.body[i2], "textord").text;
    }
    if (funcName === "\\begin") {
      if (!environments.hasOwnProperty(envName)) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      var env = environments[envName];
      var {
        args: _args,
        optArgs
      } = parser.parseArguments("\\begin{" + envName + "}", env);
      var context2 = {
        mode: parser.mode,
        envName,
        parser
      };
      var result2 = env.handler(context2, _args, optArgs);
      parser.expect("\\end", false);
      var endNameToken = parser.nextToken;
      var end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      }
      return result2;
    }
    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});
var makeSpan = buildCommon.makeSpan;
function htmlBuilder$6(group, options2) {
  var elements = buildExpression$1(group.body, options2, true);
  return makeSpan([group.mclass], elements, options2);
}
function mathmlBuilder$5(group, options2) {
  var node;
  var inner2 = buildExpression(group.body, options2);
  if (group.mclass === "minner") {
    return mathMLTree.newDocumentFragment(inner2);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node = inner2[0];
      node.type = "mi";
    } else {
      node = new mathMLTree.MathNode("mi", inner2);
    }
  } else {
    if (group.isCharacterBox) {
      node = inner2[0];
      node.type = "mo";
    } else {
      node = new mathMLTree.MathNode("mo", inner2);
    }
    if (group.mclass === "mbin") {
      node.attributes.lspace = "0.22em";
      node.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0.17em";
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0em";
    }
  }
  return node;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: "m" + funcName.substr(5),
      body: ordargument(body),
      isCharacterBox: utils.isCharacterBox(body)
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
var binrelClass = (arg) => {
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(_ref3, args) {
    var {
      parser,
      funcName
    } = _ref3;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;
    if (funcName !== "\\stackrel") {
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel";
    }
    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils.isCharacterBox(supsub)
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
var htmlBuilder$5 = (group, options2) => {
  var font = group.font;
  var newOptions = options2.withFont(font);
  return buildGroup$1(group.body, newOptions);
};
var mathmlBuilder$4 = (group, options2) => {
  var font = group.font;
  var newOptions = options2.withFont(font);
  return buildGroup(group.body, newOptions);
};
var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = normalizeArgument(args[0]);
    var func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    var isCharacterBox3 = utils.isCharacterBox(body);
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox3
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser,
      funcName,
      breakOnTokenText
    } = _ref3;
    var {
      mode
    } = parser;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = "math" + funcName.slice(1);
    return {
      type: "font",
      mode,
      font: style,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (size, originalStyle) => {
  var style = originalStyle;
  if (size === "display") {
    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
  } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
    style = Style$1.TEXT;
  } else if (size === "script") {
    style = Style$1.SCRIPT;
  } else if (size === "scriptscript") {
    style = Style$1.SCRIPTSCRIPT;
  }
  return style;
};
var htmlBuilder$4 = (group, options2) => {
  var style = adjustStyle(group.size, options2.style);
  var nstyle = style.fracNum();
  var dstyle = style.fracDen();
  var newOptions;
  newOptions = options2.havingStyle(nstyle);
  var numerm = buildGroup$1(group.numer, newOptions, options2);
  if (group.continued) {
    var hStrut = 8.5 / options2.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options2.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }
  newOptions = options2.havingStyle(dstyle);
  var denomm = buildGroup$1(group.denom, newOptions, options2);
  var rule;
  var ruleWidth;
  var ruleSpacing;
  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options2);
      rule = buildCommon.makeLineSpan("frac-line", options2, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options2);
    }
    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options2.fontMetrics().defaultRuleThickness;
  }
  var numShift;
  var clearance;
  var denomShift;
  if (style.size === Style$1.DISPLAY.size || group.size === "display") {
    numShift = options2.fontMetrics().num1;
    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }
    denomShift = options2.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options2.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options2.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }
    denomShift = options2.fontMetrics().denom2;
  }
  var frac;
  if (!rule) {
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options2);
  } else {
    var axisHeight = options2.fontMetrics().axisHeight;
    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }
    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }
    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options2);
  }
  newOptions = options2.havingStyle(style);
  frac.height *= newOptions.sizeMultiplier / options2.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options2.sizeMultiplier;
  var delimSize;
  if (style.size === Style$1.DISPLAY.size) {
    delimSize = options2.fontMetrics().delim1;
  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
    delimSize = options2.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options2.fontMetrics().delim2;
  }
  var leftDelim;
  var rightDelim;
  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options2, ["mopen"]);
  } else {
    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options2.havingStyle(style), group.mode, ["mopen"]);
  }
  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]);
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options2, ["mclose"]);
  } else {
    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options2.havingStyle(style), group.mode, ["mclose"]);
  }
  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options2)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options2);
};
var mathmlBuilder$3 = (group, options2) => {
  var node = new mathMLTree.MathNode("mfrac", [buildGroup(group.numer, options2), buildGroup(group.denom, options2)]);
  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = calculateSize(group.barSize, options2);
    node.setAttribute("linethickness", makeEm(ruleWidth));
  }
  var style = adjustStyle(group.size, options2.style);
  if (style.size !== options2.style.size) {
    node = new mathMLTree.MathNode("mstyle", [node]);
    var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
    node.setAttribute("displaystyle", isDisplay);
    node.setAttribute("scriptlevel", "0");
  }
  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];
    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }
    withDelims.push(node);
    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }
    return makeRow(withDelims);
  }
  return node;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    "\\\\bracefrac",
    "\\\\brackfrac"
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";
    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        size = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    var {
      parser,
      funcName
    } = _ref2;
    var numer = args[0];
    var denom = args[1];
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName,
      token
    } = _ref3;
    var replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"];
var delimFromValue = function delimFromValue2(delimString) {
  var delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(_ref4, args) {
    var {
      parser
    } = _ref4;
    var numer = args[4];
    var denom = args[5];
    var leftNode = normalizeArgument(args[0]);
    var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    var rightNode = normalizeArgument(args[1]);
    var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;
    if (barNode.isBlank) {
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }
    var size = "auto";
    var styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size = stylArray[Number(styl.text)];
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler(_ref5, args) {
    var {
      parser,
      funcName,
      token
    } = _ref5;
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    var {
      parser,
      funcName
    } = _ref6;
    var numer = args[0];
    var barSize = assert(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (grp, options2) => {
  var style = options2.style;
  var supSubGroup;
  var group;
  if (grp.type === "supsub") {
    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options2.havingStyle(style.sup()), options2) : buildGroup$1(grp.sub, options2.havingStyle(style.sub()), options2);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  }
  var body = buildGroup$1(group.base, options2.havingBaseStyle(Style$1.DISPLAY));
  var braceBody = stretchy.svgSpan(group, options2);
  var vlist;
  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options2);
    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options2);
    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }
  if (supSubGroup) {
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options2);
    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options2);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options2);
    }
  }
  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options2);
};
var mathmlBuilder$2 = (group, options2) => {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup(group.base, options2), accentNode]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\href");
    }
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options2) => {
    var elements = buildExpression$1(group.body, options2, false);
    return buildCommon.makeAnchor(group.href, [], elements, options2);
  },
  mathmlBuilder: (group, options2) => {
    var math2 = buildExpressionRow(group.body, options2);
    if (!(math2 instanceof MathNode)) {
      math2 = new MathNode("mrow", [math2]);
    }
    math2.setAttribute("href", group.href);
    return math2;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\url");
    }
    var chars = [];
    for (var i2 = 0; i2 < href.length; i2++) {
      var c2 = href[i2];
      if (c2 === "~") {
        c2 = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c2
      });
    }
    var body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options2) {
    var elements = buildExpression$1(group.body, options2, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder(group, options2) {
    return new mathMLTree.MathNode("mrow", buildExpression(group.body, options2));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName,
      token
    } = _ref;
    var value = assertNodeType(args[0], "raw").string;
    var body = args[1];
    if (parser.settings.strict) {
      parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }
    var trustContext;
    var attributes = {};
    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value;
        trustContext = {
          command: "\\htmlClass",
          class: value
        };
        break;
      case "\\htmlId":
        attributes.id = value;
        trustContext = {
          command: "\\htmlId",
          id: value
        };
        break;
      case "\\htmlStyle":
        attributes.style = value;
        trustContext = {
          command: "\\htmlStyle",
          style: value
        };
        break;
      case "\\htmlData": {
        var data2 = value.split(",");
        for (var i2 = 0; i2 < data2.length; i2++) {
          var keyVal = data2[i2].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\htmlData");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }
        trustContext = {
          command: "\\htmlData",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    if (!parser.settings.isTrusted(trustContext)) {
      return parser.formatUnsupportedCmd(funcName);
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options2) => {
    var elements = buildExpression$1(group.body, options2, false);
    var classes = ["enclosing"];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    var span = buildCommon.makeSpan(classes, elements, options2);
    for (var attr in group.attributes) {
      if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
        span.setAttribute(attr, group.attributes[attr]);
      }
    }
    return span;
  },
  mathmlBuilder: (group, options2) => {
    return buildExpressionRow(group.body, options2);
  }
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options2) => {
    var elements = buildExpression$1(group.html, options2, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options2) => {
    return buildExpressionRow(group.mathml, options2);
  }
});
var sizeData = function sizeData2(str2) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str2)) {
    return {
      number: +str2,
      unit: "bp"
    };
  } else {
    var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str2);
    if (!match2) {
      throw new ParseError("Invalid size: '" + str2 + "' in \\includegraphics");
    }
    var data2 = {
      number: +(match2[1] + match2[2]),
      unit: match2[3]
    };
    if (!validUnit(data2)) {
      throw new ParseError("Invalid unit: '" + data2.unit + "' in \\includegraphics.");
    }
    return data2;
  }
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var width = {
      number: 0,
      unit: "em"
    };
    var height = {
      number: 0.9,
      unit: "em"
    };
    var totalheight = {
      number: 0,
      unit: "em"
    };
    var alt = "";
    if (optArgs[0]) {
      var attributeStr = assertNodeType(optArgs[0], "raw").string;
      var attributes = attributeStr.split(",");
      for (var i2 = 0; i2 < attributes.length; i2++) {
        var keyVal = attributes[i2].split("=");
        if (keyVal.length === 2) {
          var str2 = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str2;
              break;
            case "width":
              width = sizeData(str2);
              break;
            case "height":
              height = sizeData(str2);
              break;
            case "totalheight":
              totalheight = sizeData(str2);
              break;
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }
    var src = assertNodeType(args[0], "url").url;
    if (alt === "") {
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }
    if (!parser.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser.formatUnsupportedCmd("\\includegraphics");
    }
    return {
      type: "includegraphics",
      mode: parser.mode,
      alt,
      width,
      height,
      totalheight,
      src
    };
  },
  htmlBuilder: (group, options2) => {
    var height = calculateSize(group.height, options2);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options2) - height;
    }
    var width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, options2);
    }
    var style = {
      height: makeEm(height + depth)
    };
    if (width > 0) {
      style.width = makeEm(width);
    }
    if (depth > 0) {
      style.verticalAlign = makeEm(-depth);
    }
    var node = new Img(group.src, group.alt, style);
    node.height = height;
    node.depth = depth;
    return node;
  },
  mathmlBuilder: (group, options2) => {
    var node = new mathMLTree.MathNode("mglyph", []);
    node.setAttribute("alt", group.alt);
    var height = calculateSize(group.height, options2);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options2) - height;
      node.setAttribute("valign", makeEm(-depth));
    }
    node.setAttribute("height", makeEm(height + depth));
    if (group.width.number > 0) {
      var width = calculateSize(group.width, options2);
      node.setAttribute("width", makeEm(width));
    }
    node.setAttribute("src", group.src);
    return node;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var size = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      var mathFunction = funcName[1] === "m";
      var muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
        }
        if (parser.mode !== "math") {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        if (muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  htmlBuilder(group, options2) {
    return buildCommon.makeGlue(group.dimension, options2);
  },
  mathmlBuilder(group, options2) {
    var dimension = calculateSize(group.dimension, options2);
    return new mathMLTree.SpaceNode(dimension);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options2) => {
    var inner2;
    if (group.alignment === "clap") {
      inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options2)]);
      inner2 = buildCommon.makeSpan(["inner"], [inner2], options2);
    } else {
      inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options2)]);
    }
    var fix2 = buildCommon.makeSpan(["fix"], []);
    var node = buildCommon.makeSpan([group.alignment], [inner2, fix2], options2);
    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node.height + node.depth);
    if (node.depth) {
      strut.style.verticalAlign = makeEm(-node.depth);
    }
    node.children.unshift(strut);
    node = buildCommon.makeSpan(["thinbox"], [node], options2);
    return buildCommon.makeSpan(["mord", "vbox"], [node], options2);
  },
  mathmlBuilder: (group, options2) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options2)]);
    if (group.alignment !== "rlap") {
      var offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
    }
    node.setAttribute("width", "0px");
    return node;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(_ref, args) {
    var {
      funcName,
      parser
    } = _ref;
    var outerMode = parser.mode;
    parser.switchMode("math");
    var close2 = funcName === "\\(" ? "\\)" : "$";
    var body = parser.parseExpression(false, close2);
    parser.expect(close2);
    parser.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser.mode,
      style: "text",
      body
    };
  }
});
defineFunction({
  type: "text",
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context2, args) {
    throw new ParseError("Mismatched " + context2.funcName);
  }
});
var chooseMathStyle = (group, options2) => {
  switch (options2.style.size) {
    case Style$1.DISPLAY.size:
      return group.display;
    case Style$1.TEXT.size:
      return group.text;
    case Style$1.SCRIPT.size:
      return group.script;
    case Style$1.SCRIPTSCRIPT.size:
      return group.scriptscript;
    default:
      return group.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options2) => {
    var body = chooseMathStyle(group, options2);
    var elements = buildExpression$1(body, options2, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options2) => {
    var body = chooseMathStyle(group, options2);
    return buildExpressionRow(body, options2);
  }
});
var assembleSupSub = (base2, supGroup, subGroup, options2, style, slant, baseShift) => {
  base2 = buildCommon.makeSpan([], [base2]);
  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
  var sub2;
  var sup2;
  if (supGroup) {
    var elem = buildGroup$1(supGroup, options2.havingStyle(style.sup()), options2);
    sup2 = {
      elem,
      kern: Math.max(options2.fontMetrics().bigOpSpacing1, options2.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }
  if (subGroup) {
    var _elem = buildGroup$1(subGroup, options2.havingStyle(style.sub()), options2);
    sub2 = {
      elem: _elem,
      kern: Math.max(options2.fontMetrics().bigOpSpacing2, options2.fontMetrics().bigOpSpacing4 - _elem.height)
    };
  }
  var finalGroup;
  if (sup2 && sub2) {
    var bottom = options2.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base2.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "kern",
        size: options2.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base2
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options2.fontMetrics().bigOpSpacing5
      }]
    }, options2);
  } else if (sub2) {
    var top = base2.height - baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top,
      children: [{
        type: "kern",
        size: options2.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base2
      }]
    }, options2);
  } else if (sup2) {
    var _bottom = base2.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _bottom,
      children: [{
        type: "elem",
        elem: base2
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options2.fontMetrics().bigOpSpacing5
      }]
    }, options2);
  } else {
    return base2;
  }
  var parts = [finalGroup];
  if (sub2 && slant !== 0 && !subIsSingleCharacter) {
    var spacer = buildCommon.makeSpan(["mspace"], [], options2);
    spacer.style.marginRight = makeEm(slant);
    parts.unshift(spacer);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], parts, options2);
};
var noSuccessor = ["\\smallint"];
var htmlBuilder$2 = (grp, options2) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }
  var style = options2.style;
  var large = false;
  if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
    large = true;
  }
  var base2;
  if (group.symbol) {
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";
    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      stash = group.name.substr(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }
    base2 = buildCommon.makeSymbol(group.name, fontName, "math", options2, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
    if (stash.length > 0) {
      var italic = base2.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options2);
      base2 = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base2,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options2);
      group.name = "\\" + stash;
      base2.classes.unshift("mop");
      base2.italic = italic;
    }
  } else if (group.body) {
    var inner2 = buildExpression$1(group.body, options2, true);
    if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
      base2 = inner2[0];
      base2.classes[0] = "mop";
    } else {
      base2 = buildCommon.makeSpan(["mop"], inner2, options2);
    }
  } else {
    var output = [];
    for (var i2 = 1; i2 < group.name.length; i2++) {
      output.push(buildCommon.mathsym(group.name[i2], group.mode, options2));
    }
    base2 = buildCommon.makeSpan(["mop"], output, options2);
  }
  var baseShift = 0;
  var slant = 0;
  if ((base2 instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    baseShift = (base2.height - base2.depth) / 2 - options2.fontMetrics().axisHeight;
    slant = base2.italic;
  }
  if (hasLimits) {
    return assembleSupSub(base2, supGroup, subGroup, options2, style, slant, baseShift);
  } else {
    if (baseShift) {
      base2.style.position = "relative";
      base2.style.top = makeEm(baseShift);
    }
    return base2;
  }
};
var mathmlBuilder$1 = (group, options2) => {
  var node;
  if (group.symbol) {
    node = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (utils.contains(noSuccessor, group.name)) {
      node.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    node = new MathNode("mo", buildExpression(group.body, options2));
  } else {
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
    var operator = new MathNode("mo", [makeText("\u2061", "text")]);
    if (group.parentIsSupSub) {
      node = new MathNode("mrow", [node, operator]);
    } else {
      node = newDocumentFragment([node, operator]);
    }
  }
  return node;
};
var singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22C0": "\\bigwedge",
  "\u22C1": "\\bigvee",
  "\u22C2": "\\bigcap",
  "\u22C3": "\\bigcup",
  "\u2A00": "\\bigodot",
  "\u2A01": "\\bigoplus",
  "\u2A02": "\\bigotimes",
  "\u2A04": "\\biguplus",
  "\u2A06": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "\u222B": "\\int",
  "\u222C": "\\iint",
  "\u222D": "\\iiint",
  "\u222E": "\\oint",
  "\u222F": "\\oiint",
  "\u2230": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
  props: {
    numArgs: 0
  },
  handler(_ref5) {
    var {
      parser,
      funcName
    } = _ref5;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var _macros = {};
function defineMacro(name, body) {
  _macros[name] = body;
}
var htmlBuilder$1 = (grp, options2) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }
  var base2;
  if (group.body.length > 0) {
    var body = group.body.map((child2) => {
      var childText = child2.text;
      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child2.mode,
          text: childText
        };
      } else {
        return child2;
      }
    });
    var expression = buildExpression$1(body, options2.withFont("mathrm"), true);
    for (var i2 = 0; i2 < expression.length; i2++) {
      var child = expression[i2];
      if (child instanceof SymbolNode) {
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }
    base2 = buildCommon.makeSpan(["mop"], expression, options2);
  } else {
    base2 = buildCommon.makeSpan(["mop"], [], options2);
  }
  if (hasLimits) {
    return assembleSupSub(base2, supGroup, subGroup, options2, options2.style, 0, 0);
  } else {
    return base2;
  }
};
var mathmlBuilder = (group, options2) => {
  var expression = buildExpression(group.body, options2.withFont("mathrm"));
  var isAllString = true;
  for (var i2 = 0; i2 < expression.length; i2++) {
    var node = expression[i2];
    if (node instanceof mathMLTree.SpaceNode)
      ;
    else if (node instanceof mathMLTree.MathNode) {
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var child = node.children[0];
          if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break;
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }
  if (isAllString) {
    var word = expression.map((node2) => node2.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }
  var identifier = new mathMLTree.MathNode("mi", expression);
  identifier.setAttribute("mathvariant", "normal");
  var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(group, options2) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression$1(group.body, options2, false));
    }
    return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options2, true), options2);
  },
  mathmlBuilder(group, options2) {
    return buildExpressionRow(group.body, options2, true);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "overline",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder(group, options2) {
    var innerGroup = buildGroup$1(group.body, options2.havingCrampedStyle());
    var line = buildCommon.makeLineSpan("overline-line", options2);
    var defaultRuleThickness = options2.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options2);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options2);
  },
  mathmlBuilder(group, options2) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("mover", [buildGroup(group.body, options2), operator]);
    node.setAttribute("accent", "true");
    return node;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options2) => {
    var elements = buildExpression$1(group.body, options2.withPhantom(), false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options2) => {
    var inner2 = buildExpression(group.body, options2);
    return new mathMLTree.MathNode("mphantom", inner2);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options2) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options2.withPhantom())]);
    node.height = 0;
    node.depth = 0;
    if (node.children) {
      for (var i2 = 0; i2 < node.children.length; i2++) {
        node.children[i2].height = 0;
        node.children[i2].depth = 0;
      }
    }
    node = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options2);
    return buildCommon.makeSpan(["mord"], [node], options2);
  },
  mathmlBuilder: (group, options2) => {
    var inner2 = buildExpression(ordargument(group.body), options2);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser
    } = _ref3;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options2) => {
    var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options2.withPhantom())]);
    var fix2 = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix2], options2);
  },
  mathmlBuilder: (group, options2) => {
    var inner2 = buildExpression(ordargument(group.body), options2);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  htmlBuilder(group, options2) {
    var body = buildGroup$1(group.body, options2);
    var dy = calculateSize(group.dy, options2);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options2);
  },
  mathmlBuilder(group, options2) {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options2)]);
    var dy = group.dy.number + group.dy.unit;
    node.setAttribute("voffset", dy);
    return node;
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var shift = optArgs[0];
    var width = assertNodeType(args[0], "size");
    var height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  htmlBuilder(group, options2) {
    var rule = buildCommon.makeSpan(["mord", "rule"], [], options2);
    var width = calculateSize(group.width, options2);
    var height = calculateSize(group.height, options2);
    var shift = group.shift ? calculateSize(group.shift, options2) : 0;
    rule.style.borderRightWidth = makeEm(width);
    rule.style.borderTopWidth = makeEm(height);
    rule.style.bottom = makeEm(shift);
    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift;
    rule.maxFontSize = height * 1.125 * options2.sizeMultiplier;
    return rule;
  },
  mathmlBuilder(group, options2) {
    var width = calculateSize(group.width, options2);
    var height = calculateSize(group.height, options2);
    var shift = group.shift ? calculateSize(group.shift, options2) : 0;
    var color = options2.color && options2.getColor() || "black";
    var rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color);
    rule.setAttribute("width", makeEm(width));
    rule.setAttribute("height", makeEm(height));
    var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift >= 0) {
      wrapper.setAttribute("height", makeEm(shift));
    } else {
      wrapper.setAttribute("height", makeEm(shift));
      wrapper.setAttribute("depth", makeEm(-shift));
    }
    wrapper.setAttribute("voffset", makeEm(shift));
    return wrapper;
  }
});
function sizingGroup(value, options2, baseOptions) {
  var inner2 = buildExpression$1(value, options2, false);
  var multiplier = options2.sizeMultiplier / baseOptions.sizeMultiplier;
  for (var i2 = 0; i2 < inner2.length; i2++) {
    var pos = inner2[i2].classes.indexOf("sizing");
    if (pos < 0) {
      Array.prototype.push.apply(inner2[i2].classes, options2.sizingClasses(baseOptions));
    } else if (inner2[i2].classes[pos + 1] === "reset-size" + options2.size) {
      inner2[i2].classes[pos + 1] = "reset-size" + baseOptions.size;
    }
    inner2[i2].height *= multiplier;
    inner2[i2].depth *= multiplier;
  }
  return buildCommon.makeFragment(inner2);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var htmlBuilder = (group, options2) => {
  var newOptions = options2.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options2);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser.mode,
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder,
  mathmlBuilder: (group, options2) => {
    var newOptions = options2.havingSize(group.size);
    var inner2 = buildExpression(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      var letter = "";
      for (var i2 = 0; i2 < tbArg.body.length; ++i2) {
        var node = tbArg.body[i2];
        letter = node.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }
    var body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options2) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options2)]);
    if (!group.smashHeight && !group.smashDepth) {
      return node;
    }
    if (group.smashHeight) {
      node.height = 0;
      if (node.children) {
        for (var i2 = 0; i2 < node.children.length; i2++) {
          node.children[i2].height = 0;
        }
      }
    }
    if (group.smashDepth) {
      node.depth = 0;
      if (node.children) {
        for (var _i6 = 0; _i6 < node.children.length; _i6++) {
          node.children[_i6].depth = 0;
        }
      }
    }
    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options2);
    return buildCommon.makeSpan(["mord"], [smashedNode], options2);
  },
  mathmlBuilder: (group, options2) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options2)]);
    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }
    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }
    return node;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var index = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },
  htmlBuilder(group, options2) {
    var inner2 = buildGroup$1(group.body, options2.havingCrampedStyle());
    if (inner2.height === 0) {
      inner2.height = options2.fontMetrics().xHeight;
    }
    inner2 = buildCommon.wrapFragment(inner2, options2);
    var metrics = options2.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;
    if (options2.style.id < Style$1.TEXT.id) {
      phi = options2.fontMetrics().xHeight;
    }
    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
    var {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter.sqrtImage(minDelimiterHeight, options2);
    var delimDepth = img.height - ruleWidth;
    if (delimDepth > inner2.height + inner2.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
    }
    var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
    inner2.style.paddingLeft = makeEm(advanceWidth);
    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner2,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner2.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options2);
    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options2);
    } else {
      var newOptions = options2.havingStyle(Style$1.SCRIPTSCRIPT);
      var rootm = buildGroup$1(group.index, newOptions, options2);
      var toShift = 0.6 * (body.height - body.depth);
      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options2);
      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options2);
    }
  },
  mathmlBuilder(group, options2) {
    var {
      body,
      index
    } = group;
    return index ? new mathMLTree.MathNode("mroot", [buildGroup(body, options2), buildGroup(index, options2)]) : new mathMLTree.MathNode("msqrt", [buildGroup(body, options2)]);
  }
});
var styleMap = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      style,
      body
    };
  },
  htmlBuilder(group, options2) {
    var newStyle = styleMap[group.style];
    var newOptions = options2.havingStyle(newStyle).withFont("");
    return sizingGroup(group.body, newOptions, options2);
  },
  mathmlBuilder(group, options2) {
    var newStyle = styleMap[group.style];
    var newOptions = options2.havingStyle(newStyle);
    var inner2 = buildExpression(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr = styleAttributes[group.style];
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);
    return node;
  }
});
var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options2) {
  var base2 = group.base;
  if (!base2) {
    return null;
  } else if (base2.type === "op") {
    var delegate = base2.limits && (options2.style.size === Style$1.DISPLAY.size || base2.alwaysHandleSupSub);
    return delegate ? htmlBuilder$2 : null;
  } else if (base2.type === "operatorname") {
    var _delegate = base2.alwaysHandleSupSub && (options2.style.size === Style$1.DISPLAY.size || base2.limits);
    return _delegate ? htmlBuilder$1 : null;
  } else if (base2.type === "accent") {
    return utils.isCharacterBox(base2.base) ? htmlBuilder$a : null;
  } else if (base2.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base2.isOver ? htmlBuilder$3 : null;
  } else {
    return null;
  }
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(group, options2) {
    var builderDelegate = htmlBuilderDelegate(group, options2);
    if (builderDelegate) {
      return builderDelegate(group, options2);
    }
    var {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    var base2 = buildGroup$1(valueBase, options2);
    var supm;
    var subm;
    var metrics = options2.fontMetrics();
    var supShift = 0;
    var subShift = 0;
    var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
    if (valueSup) {
      var newOptions = options2.havingStyle(options2.style.sup());
      supm = buildGroup$1(valueSup, newOptions, options2);
      if (!isCharacterBox3) {
        supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options2.sizeMultiplier;
      }
    }
    if (valueSub) {
      var _newOptions = options2.havingStyle(options2.style.sub());
      subm = buildGroup$1(valueSub, _newOptions, options2);
      if (!isCharacterBox3) {
        subShift = base2.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options2.sizeMultiplier;
      }
    }
    var minSupShift;
    if (options2.style === Style$1.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options2.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    }
    var multiplier = options2.sizeMultiplier;
    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    var marginLeft = null;
    if (subm) {
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
      if (base2 instanceof SymbolNode || isOiint) {
        marginLeft = makeEm(-base2.italic);
      }
    }
    var supsub;
    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness;
      var maxWidth = 4 * ruleWidth;
      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }
      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options2);
    } else if (subm) {
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options2);
    } else if (supm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options2);
    } else {
      throw new Error("supsub must have either sup or sub.");
    }
    var mclass = getTypeOfDomTree(base2, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base2, buildCommon.makeSpan(["msupsub"], [supsub])], options2);
  },
  mathmlBuilder(group, options2) {
    var isBrace = false;
    var isOver;
    var isSup;
    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }
    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }
    var children = [buildGroup(group.base, options2)];
    if (group.sub) {
      children.push(buildGroup(group.sub, options2));
    }
    if (group.sup) {
      children.push(buildGroup(group.sup, options2));
    }
    var nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base2 = group.base;
      if (base2 && base2.type === "op" && base2.limits && (options2.style === Style$1.DISPLAY || base2.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options2.style === Style$1.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;
      if (_base && _base.type === "op" && _base.limits && (options2.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options2.style === Style$1.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;
      if (_base2 && _base2.type === "op" && _base2.limits && options2.style === Style$1.DISPLAY) {
        nodeType = "munderover";
      } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options2.style === Style$1.DISPLAY || _base2.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }
    return new mathMLTree.MathNode(nodeType, children);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(group, options2) {
    return buildCommon.mathsym(group.text, group.mode, options2, ["m" + group.family]);
  },
  mathmlBuilder(group, options2) {
    var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "bin") {
      var variant = getVariant(group, options2);
      if (variant === "bold-italic") {
        node.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      node.setAttribute("stretchy", "false");
    }
    return node;
  }
});
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(group, options2) {
    return buildCommon.makeOrd(group, options2, "mathord");
  },
  mathmlBuilder(group, options2) {
    var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options2)]);
    var variant = getVariant(group, options2) || "italic";
    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }
    return node;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(group, options2) {
    return buildCommon.makeOrd(group, options2, "textord");
  },
  mathmlBuilder(group, options2) {
    var text2 = makeText(group.text, group.mode, options2);
    var variant = getVariant(group, options2) || "normal";
    var node;
    if (group.mode === "text") {
      node = new mathMLTree.MathNode("mtext", [text2]);
    } else if (/[0-9]/.test(group.text)) {
      node = new mathMLTree.MathNode("mn", [text2]);
    } else if (group.text === "\\prime") {
      node = new mathMLTree.MathNode("mo", [text2]);
    } else {
      node = new mathMLTree.MathNode("mi", [text2]);
    }
    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }
    return node;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};
var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(group, options2) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || "";
      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options2, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options2)], options2);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options2);
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
  },
  mathmlBuilder(group, options2) {
    var node;
    if (regularSpace.hasOwnProperty(group.text)) {
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
    return node;
  }
});
var pad = () => {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(group, options2) {
    var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options2)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options2)])])]);
    table.setAttribute("width", "100%");
    return table;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};
var optionsWithFont = (group, options2) => {
  var font = group.font;
  if (!font) {
    return options2;
  } else if (textFontFamilies[font]) {
    return options2.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options2.withTextFontWeight(textFontWeights[font]);
  } else {
    return options2.withTextFontShape(textFontShapes[font]);
  }
};
defineFunction({
  type: "text",
  names: [
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    "\\textbf",
    "\\textmd",
    "\\textit",
    "\\textup"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  htmlBuilder(group, options2) {
    var newOptions = optionsWithFont(group, options2);
    var inner2 = buildExpression$1(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
  },
  mathmlBuilder(group, options2) {
    var newOptions = optionsWithFont(group, options2);
    return buildExpressionRow(group.body, newOptions);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "underline",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options2) {
    var innerGroup = buildGroup$1(group.body, options2);
    var line = buildCommon.makeLineSpan("underline-line", options2);
    var defaultRuleThickness = options2.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options2);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options2);
  },
  mathmlBuilder(group, options2) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("munder", [buildGroup(group.body, options2), operator]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    allowedInText: false
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options2) {
    var body = buildGroup$1(group.body, options2);
    var axisHeight = options2.fontMetrics().axisHeight;
    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options2);
  },
  mathmlBuilder(group, options2) {
    return new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options2)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context2, args, optArgs) {
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(group, options2) {
    var text2 = makeVerb(group);
    var body = [];
    var newOptions = options2.havingStyle(options2.style.text());
    for (var i2 = 0; i2 < text2.length; i2++) {
      var c2 = text2[i2];
      if (c2 === "~") {
        c2 = "\\textasciitilde";
      }
      body.push(buildCommon.makeSymbol(c2, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options2)), buildCommon.tryCombineChars(body), newOptions);
  },
  mathmlBuilder(group, options2) {
    var text2 = new mathMLTree.TextNode(makeVerb(group));
    var node = new mathMLTree.MathNode("mtext", [text2]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});
var makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
var functions = _functions;
var spaceRegexString = "[ \r\n	]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
var combiningDiacriticalMarkString = "[\u0300-\u036F]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + (controlSpaceRegexString + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (combiningDiacriticalMarkString + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (combiningDiacriticalMarkString + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + controlWordWhitespaceRegexString) + ("|" + controlSymbolRegexString + ")");
class Lexer {
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, "g");
    this.catcodes = {
      "%": 14,
      "~": 13
    };
  }
  setCatcode(char, code2) {
    this.catcodes[char] = code2;
  }
  lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    var match2 = this.tokenRegex.exec(input);
    if (match2 === null || match2.index !== pos) {
      throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }
    var text2 = match2[6] || match2[3] || (match2[2] ? "\\ " : " ");
    if (this.catcodes[text2] === 14) {
      var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length;
        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }
    return new Token(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
}
class Namespace {
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }
    if (globalMacros === void 0) {
      globalMacros = {};
    }
    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  beginGroup() {
    this.undefStack.push({});
  }
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    }
    var undefs = this.undefStack.pop();
    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] === void 0) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  set(name, value, global2) {
    if (global2 === void 0) {
      global2 = false;
    }
    if (global2) {
      for (var i2 = 0; i2 < this.undefStack.length; i2++) {
        delete this.undefStack[i2][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      var top = this.undefStack[this.undefStack.length - 1];
      if (top && !top.hasOwnProperty(name)) {
        top[name] = this.current[name];
      }
    }
    this.current[name] = value;
  }
}
var macros = _macros;
defineMacro("\\noexpand", function(context2) {
  var t2 = context2.popToken();
  if (context2.isExpandable(t2.text)) {
    t2.noexpand = true;
    t2.treatAsRelax = true;
  }
  return {
    tokens: [t2],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(context2) {
  var t2 = context2.popToken();
  context2.expandOnce(true);
  return {
    tokens: [t2],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(context2) {
  var args = context2.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(context2) {
  var args = context2.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(context2) {
  var args = context2.consumeArgs(3);
  context2.consumeSpaces();
  var nextToken = context2.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(context2) {
  var args = context2.consumeArgs(2);
  if (context2.mode === "text") {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
});
var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
defineMacro("\\char", function(context2) {
  var token = context2.popToken();
  var base2;
  var number = "";
  if (token.text === "'") {
    base2 = 8;
    token = context2.popToken();
  } else if (token.text === '"') {
    base2 = 16;
    token = context2.popToken();
  } else if (token.text === "`") {
    token = context2.popToken();
    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base2 = 10;
  }
  if (base2) {
    number = digitToNumber[token.text];
    if (number == null || number >= base2) {
      throw new ParseError("Invalid base-" + base2 + " digit " + token.text);
    }
    var digit;
    while ((digit = digitToNumber[context2.future().text]) != null && digit < base2) {
      number *= base2;
      number += digit;
      context2.popToken();
    }
  }
  return "\\@char{" + number + "}";
});
var newcommand = (context2, existsOK, nonexistsOK) => {
  var arg = context2.consumeArg().tokens;
  if (arg.length !== 1) {
    throw new ParseError("\\newcommand's first argument must be a macro name");
  }
  var name = arg[0].text;
  var exists = context2.isDefined(name);
  if (exists && !existsOK) {
    throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }
  if (!exists && !nonexistsOK) {
    throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
  }
  var numArgs = 0;
  arg = context2.consumeArg().tokens;
  if (arg.length === 1 && arg[0].text === "[") {
    var argText = "";
    var token = context2.expandNextToken();
    while (token.text !== "]" && token.text !== "EOF") {
      argText += token.text;
      token = context2.expandNextToken();
    }
    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new ParseError("Invalid number of arguments: " + argText);
    }
    numArgs = parseInt(argText);
    arg = context2.consumeArg().tokens;
  }
  context2.macros.set(name, {
    tokens: arg,
    numArgs
  });
  return "";
};
defineMacro("\\newcommand", (context2) => newcommand(context2, false, true));
defineMacro("\\renewcommand", (context2) => newcommand(context2, true, false));
defineMacro("\\providecommand", (context2) => newcommand(context2, true, true));
defineMacro("\\message", (context2) => {
  var arg = context2.consumeArgs(1)[0];
  console.log(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\errmessage", (context2) => {
  var arg = context2.consumeArgs(1)[0];
  console.error(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\show", (context2) => {
  var tok = context2.popToken();
  var name = tok.text;
  console.log(tok, context2.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
  return "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
defineMacro("\u212C", "\\mathscr{B}");
defineMacro("\u2130", "\\mathscr{E}");
defineMacro("\u2131", "\\mathscr{F}");
defineMacro("\u210B", "\\mathscr{H}");
defineMacro("\u2110", "\\mathscr{I}");
defineMacro("\u2112", "\\mathscr{L}");
defineMacro("\u2133", "\\mathscr{M}");
defineMacro("\u211B", "\\mathscr{R}");
defineMacro("\u212D", "\\mathfrak{C}");
defineMacro("\u210C", "\\mathfrak{H}");
defineMacro("\u2128", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("\xB7", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
defineMacro("\\ne", "\\neq");
defineMacro("\u2260", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
defineMacro("\u2209", "\\notin");
defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
defineMacro("\u27C2", "\\perp");
defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("\u220C", "\\notni");
defineMacro("\u231C", "\\ulcorner");
defineMacro("\u231D", "\\urcorner");
defineMacro("\u231E", "\\llcorner");
defineMacro("\u231F", "\\lrcorner");
defineMacro("\xA9", "\\copyright");
defineMacro("\xAE", "\\textregistered");
defineMacro("\uFE0F", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22EE", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  "\\mathbin": "\\dotsb",
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(context2) {
  var thedots = "\\dotso";
  var next = context2.expandAfterFuture().text;
  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.substr(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next in symbols.math) {
    if (utils.contains(["bin", "rel"], symbols.math[next].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});
var spaceAfterDots = {
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  "$": true,
  ";": true,
  ".": true,
  ",": true
};
defineMacro("\\dotso", function(context2) {
  var next = context2.future().text;
  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function(context2) {
  var next = context2.future().text;
  if (next in spaceAfterDots && next !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function(context2) {
  var next = context2.future().text;
  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context2) => {
  if (context2.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\pmb", "\\html@mathml{\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}{\\mathbf{#1}}");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("\u2237", "\\dblcolon");
defineMacro("\u2239", "\\eqcolon");
defineMacro("\u2254", "\\coloneqq");
defineMacro("\u2255", "\\eqqcolon");
defineMacro("\u2A74", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
defineMacro("\u27E6", "\\llbracket");
defineMacro("\u27E7", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
defineMacro("\u2983", "\\lBrace");
defineMacro("\u2984", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
defineMacro("\u29B5", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
var implicitCommands = {
  "\\relax": true,
  "^": true,
  "_": true,
  "\\limits": true,
  "\\nolimits": true
};
class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = [];
  }
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }
  switchMode(newMode) {
    this.mode = newMode;
  }
  beginGroup() {
    this.macros.beginGroup();
  }
  endGroup() {
    this.macros.endGroup();
  }
  endGroups() {
    this.macros.endGroups();
  }
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1];
  }
  popToken() {
    this.future();
    return this.stack.pop();
  }
  pushToken(token) {
    this.stack.push(token);
  }
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  scanArgument(isOptional) {
    var start;
    var end;
    var tokens;
    if (isOptional) {
      this.consumeSpaces();
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken();
      ({
        tokens,
        end
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start,
        end
      } = this.consumeArg());
    }
    this.pushToken(new Token("EOF", end.loc));
    this.pushTokens(tokens);
    return start.range(end, "");
  }
  consumeSpaces() {
    for (; ; ) {
      var token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  consumeArg(delims) {
    var tokens = [];
    var isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      this.consumeSpaces();
    }
    var start = this.future();
    var tok;
    var depth = 0;
    var match2 = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match2] : "}") + "'", tok);
      }
      if (delims && isDelimited) {
        if ((depth === 0 || depth === 1 && delims[match2] === "{") && tok.text === delims[match2]) {
          ++match2;
          if (match2 === delims.length) {
            tokens.splice(-match2, match2);
            break;
          }
        } else {
          match2 = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse();
    return {
      tokens,
      start,
      end: tok
    };
  }
  consumeArgs(numArgs, delimiters2) {
    if (delimiters2) {
      if (delimiters2.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      var delims = delimiters2[0];
      for (var i2 = 0; i2 < delims.length; i2++) {
        var tok = this.popToken();
        if (delims[i2] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }
    var args = [];
    for (var _i6 = 0; _i6 < numArgs; _i6++) {
      args.push(this.consumeArg(delimiters2 && delimiters2[_i6 + 1]).tokens);
    }
    return args;
  }
  expandOnce(expandableOnly) {
    var topToken = this.popToken();
    var name = topToken.text;
    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return topToken;
    }
    this.expansionCount++;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
    }
    var tokens = expansion.tokens;
    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      tokens = tokens.slice();
      for (var i2 = tokens.length - 1; i2 >= 0; --i2) {
        var tok = tokens[i2];
        if (tok.text === "#") {
          if (i2 === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i2];
          if (tok.text === "#") {
            tokens.splice(i2 + 1, 1);
          } else if (/^[1-9]$/.test(tok.text)) {
            tokens.splice(i2, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    this.pushTokens(tokens);
    return tokens;
  }
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  expandNextToken() {
    for (; ; ) {
      var expanded = this.expandOnce();
      if (expanded instanceof Token) {
        if (expanded.text === "\\relax" || expanded.treatAsRelax) {
          this.stack.pop();
        } else {
          return this.stack.pop();
        }
      }
    }
    throw new Error();
  }
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
  }
  expandTokens(tokens) {
    var output = [];
    var oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      var expanded = this.expandOnce(true);
      if (expanded instanceof Token) {
        if (expanded.treatAsRelax) {
          expanded.noexpand = false;
          expanded.treatAsRelax = false;
        }
        output.push(this.stack.pop());
      }
    }
    return output;
  }
  expandMacroAsText(name) {
    var tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }
  _getExpansion(name) {
    var definition = this.macros.get(name);
    if (definition == null) {
      return definition;
    }
    if (name.length === 1) {
      var catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return;
      }
    }
    var expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      var numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      var bodyLexer = new Lexer(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse();
      var expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }
    return expansion;
  }
  isDefined(name) {
    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  }
  isExpandable(name) {
    var macro = this.macros.get(name);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
  }
}
var unicodeAccents = {
  "\u0301": {
    "text": "\\'",
    "math": "\\acute"
  },
  "\u0300": {
    "text": "\\`",
    "math": "\\grave"
  },
  "\u0308": {
    "text": '\\"',
    "math": "\\ddot"
  },
  "\u0303": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "\u0304": {
    "text": "\\=",
    "math": "\\bar"
  },
  "\u0306": {
    "text": "\\u",
    "math": "\\breve"
  },
  "\u030C": {
    "text": "\\v",
    "math": "\\check"
  },
  "\u0302": {
    "text": "\\^",
    "math": "\\hat"
  },
  "\u0307": {
    "text": "\\.",
    "math": "\\dot"
  },
  "\u030A": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "\u030B": {
    "text": "\\H"
  },
  "\u0327": {
    "text": "\\c"
  }
};
var unicodeSymbols = {
  "\xE1": "a\u0301",
  "\xE0": "a\u0300",
  "\xE4": "a\u0308",
  "\u01DF": "a\u0308\u0304",
  "\xE3": "a\u0303",
  "\u0101": "a\u0304",
  "\u0103": "a\u0306",
  "\u1EAF": "a\u0306\u0301",
  "\u1EB1": "a\u0306\u0300",
  "\u1EB5": "a\u0306\u0303",
  "\u01CE": "a\u030C",
  "\xE2": "a\u0302",
  "\u1EA5": "a\u0302\u0301",
  "\u1EA7": "a\u0302\u0300",
  "\u1EAB": "a\u0302\u0303",
  "\u0227": "a\u0307",
  "\u01E1": "a\u0307\u0304",
  "\xE5": "a\u030A",
  "\u01FB": "a\u030A\u0301",
  "\u1E03": "b\u0307",
  "\u0107": "c\u0301",
  "\u1E09": "c\u0327\u0301",
  "\u010D": "c\u030C",
  "\u0109": "c\u0302",
  "\u010B": "c\u0307",
  "\xE7": "c\u0327",
  "\u010F": "d\u030C",
  "\u1E0B": "d\u0307",
  "\u1E11": "d\u0327",
  "\xE9": "e\u0301",
  "\xE8": "e\u0300",
  "\xEB": "e\u0308",
  "\u1EBD": "e\u0303",
  "\u0113": "e\u0304",
  "\u1E17": "e\u0304\u0301",
  "\u1E15": "e\u0304\u0300",
  "\u0115": "e\u0306",
  "\u1E1D": "e\u0327\u0306",
  "\u011B": "e\u030C",
  "\xEA": "e\u0302",
  "\u1EBF": "e\u0302\u0301",
  "\u1EC1": "e\u0302\u0300",
  "\u1EC5": "e\u0302\u0303",
  "\u0117": "e\u0307",
  "\u0229": "e\u0327",
  "\u1E1F": "f\u0307",
  "\u01F5": "g\u0301",
  "\u1E21": "g\u0304",
  "\u011F": "g\u0306",
  "\u01E7": "g\u030C",
  "\u011D": "g\u0302",
  "\u0121": "g\u0307",
  "\u0123": "g\u0327",
  "\u1E27": "h\u0308",
  "\u021F": "h\u030C",
  "\u0125": "h\u0302",
  "\u1E23": "h\u0307",
  "\u1E29": "h\u0327",
  "\xED": "i\u0301",
  "\xEC": "i\u0300",
  "\xEF": "i\u0308",
  "\u1E2F": "i\u0308\u0301",
  "\u0129": "i\u0303",
  "\u012B": "i\u0304",
  "\u012D": "i\u0306",
  "\u01D0": "i\u030C",
  "\xEE": "i\u0302",
  "\u01F0": "j\u030C",
  "\u0135": "j\u0302",
  "\u1E31": "k\u0301",
  "\u01E9": "k\u030C",
  "\u0137": "k\u0327",
  "\u013A": "l\u0301",
  "\u013E": "l\u030C",
  "\u013C": "l\u0327",
  "\u1E3F": "m\u0301",
  "\u1E41": "m\u0307",
  "\u0144": "n\u0301",
  "\u01F9": "n\u0300",
  "\xF1": "n\u0303",
  "\u0148": "n\u030C",
  "\u1E45": "n\u0307",
  "\u0146": "n\u0327",
  "\xF3": "o\u0301",
  "\xF2": "o\u0300",
  "\xF6": "o\u0308",
  "\u022B": "o\u0308\u0304",
  "\xF5": "o\u0303",
  "\u1E4D": "o\u0303\u0301",
  "\u1E4F": "o\u0303\u0308",
  "\u022D": "o\u0303\u0304",
  "\u014D": "o\u0304",
  "\u1E53": "o\u0304\u0301",
  "\u1E51": "o\u0304\u0300",
  "\u014F": "o\u0306",
  "\u01D2": "o\u030C",
  "\xF4": "o\u0302",
  "\u1ED1": "o\u0302\u0301",
  "\u1ED3": "o\u0302\u0300",
  "\u1ED7": "o\u0302\u0303",
  "\u022F": "o\u0307",
  "\u0231": "o\u0307\u0304",
  "\u0151": "o\u030B",
  "\u1E55": "p\u0301",
  "\u1E57": "p\u0307",
  "\u0155": "r\u0301",
  "\u0159": "r\u030C",
  "\u1E59": "r\u0307",
  "\u0157": "r\u0327",
  "\u015B": "s\u0301",
  "\u1E65": "s\u0301\u0307",
  "\u0161": "s\u030C",
  "\u1E67": "s\u030C\u0307",
  "\u015D": "s\u0302",
  "\u1E61": "s\u0307",
  "\u015F": "s\u0327",
  "\u1E97": "t\u0308",
  "\u0165": "t\u030C",
  "\u1E6B": "t\u0307",
  "\u0163": "t\u0327",
  "\xFA": "u\u0301",
  "\xF9": "u\u0300",
  "\xFC": "u\u0308",
  "\u01D8": "u\u0308\u0301",
  "\u01DC": "u\u0308\u0300",
  "\u01D6": "u\u0308\u0304",
  "\u01DA": "u\u0308\u030C",
  "\u0169": "u\u0303",
  "\u1E79": "u\u0303\u0301",
  "\u016B": "u\u0304",
  "\u1E7B": "u\u0304\u0308",
  "\u016D": "u\u0306",
  "\u01D4": "u\u030C",
  "\xFB": "u\u0302",
  "\u016F": "u\u030A",
  "\u0171": "u\u030B",
  "\u1E7D": "v\u0303",
  "\u1E83": "w\u0301",
  "\u1E81": "w\u0300",
  "\u1E85": "w\u0308",
  "\u0175": "w\u0302",
  "\u1E87": "w\u0307",
  "\u1E98": "w\u030A",
  "\u1E8D": "x\u0308",
  "\u1E8B": "x\u0307",
  "\xFD": "y\u0301",
  "\u1EF3": "y\u0300",
  "\xFF": "y\u0308",
  "\u1EF9": "y\u0303",
  "\u0233": "y\u0304",
  "\u0177": "y\u0302",
  "\u1E8F": "y\u0307",
  "\u1E99": "y\u030A",
  "\u017A": "z\u0301",
  "\u017E": "z\u030C",
  "\u1E91": "z\u0302",
  "\u017C": "z\u0307",
  "\xC1": "A\u0301",
  "\xC0": "A\u0300",
  "\xC4": "A\u0308",
  "\u01DE": "A\u0308\u0304",
  "\xC3": "A\u0303",
  "\u0100": "A\u0304",
  "\u0102": "A\u0306",
  "\u1EAE": "A\u0306\u0301",
  "\u1EB0": "A\u0306\u0300",
  "\u1EB4": "A\u0306\u0303",
  "\u01CD": "A\u030C",
  "\xC2": "A\u0302",
  "\u1EA4": "A\u0302\u0301",
  "\u1EA6": "A\u0302\u0300",
  "\u1EAA": "A\u0302\u0303",
  "\u0226": "A\u0307",
  "\u01E0": "A\u0307\u0304",
  "\xC5": "A\u030A",
  "\u01FA": "A\u030A\u0301",
  "\u1E02": "B\u0307",
  "\u0106": "C\u0301",
  "\u1E08": "C\u0327\u0301",
  "\u010C": "C\u030C",
  "\u0108": "C\u0302",
  "\u010A": "C\u0307",
  "\xC7": "C\u0327",
  "\u010E": "D\u030C",
  "\u1E0A": "D\u0307",
  "\u1E10": "D\u0327",
  "\xC9": "E\u0301",
  "\xC8": "E\u0300",
  "\xCB": "E\u0308",
  "\u1EBC": "E\u0303",
  "\u0112": "E\u0304",
  "\u1E16": "E\u0304\u0301",
  "\u1E14": "E\u0304\u0300",
  "\u0114": "E\u0306",
  "\u1E1C": "E\u0327\u0306",
  "\u011A": "E\u030C",
  "\xCA": "E\u0302",
  "\u1EBE": "E\u0302\u0301",
  "\u1EC0": "E\u0302\u0300",
  "\u1EC4": "E\u0302\u0303",
  "\u0116": "E\u0307",
  "\u0228": "E\u0327",
  "\u1E1E": "F\u0307",
  "\u01F4": "G\u0301",
  "\u1E20": "G\u0304",
  "\u011E": "G\u0306",
  "\u01E6": "G\u030C",
  "\u011C": "G\u0302",
  "\u0120": "G\u0307",
  "\u0122": "G\u0327",
  "\u1E26": "H\u0308",
  "\u021E": "H\u030C",
  "\u0124": "H\u0302",
  "\u1E22": "H\u0307",
  "\u1E28": "H\u0327",
  "\xCD": "I\u0301",
  "\xCC": "I\u0300",
  "\xCF": "I\u0308",
  "\u1E2E": "I\u0308\u0301",
  "\u0128": "I\u0303",
  "\u012A": "I\u0304",
  "\u012C": "I\u0306",
  "\u01CF": "I\u030C",
  "\xCE": "I\u0302",
  "\u0130": "I\u0307",
  "\u0134": "J\u0302",
  "\u1E30": "K\u0301",
  "\u01E8": "K\u030C",
  "\u0136": "K\u0327",
  "\u0139": "L\u0301",
  "\u013D": "L\u030C",
  "\u013B": "L\u0327",
  "\u1E3E": "M\u0301",
  "\u1E40": "M\u0307",
  "\u0143": "N\u0301",
  "\u01F8": "N\u0300",
  "\xD1": "N\u0303",
  "\u0147": "N\u030C",
  "\u1E44": "N\u0307",
  "\u0145": "N\u0327",
  "\xD3": "O\u0301",
  "\xD2": "O\u0300",
  "\xD6": "O\u0308",
  "\u022A": "O\u0308\u0304",
  "\xD5": "O\u0303",
  "\u1E4C": "O\u0303\u0301",
  "\u1E4E": "O\u0303\u0308",
  "\u022C": "O\u0303\u0304",
  "\u014C": "O\u0304",
  "\u1E52": "O\u0304\u0301",
  "\u1E50": "O\u0304\u0300",
  "\u014E": "O\u0306",
  "\u01D1": "O\u030C",
  "\xD4": "O\u0302",
  "\u1ED0": "O\u0302\u0301",
  "\u1ED2": "O\u0302\u0300",
  "\u1ED6": "O\u0302\u0303",
  "\u022E": "O\u0307",
  "\u0230": "O\u0307\u0304",
  "\u0150": "O\u030B",
  "\u1E54": "P\u0301",
  "\u1E56": "P\u0307",
  "\u0154": "R\u0301",
  "\u0158": "R\u030C",
  "\u1E58": "R\u0307",
  "\u0156": "R\u0327",
  "\u015A": "S\u0301",
  "\u1E64": "S\u0301\u0307",
  "\u0160": "S\u030C",
  "\u1E66": "S\u030C\u0307",
  "\u015C": "S\u0302",
  "\u1E60": "S\u0307",
  "\u015E": "S\u0327",
  "\u0164": "T\u030C",
  "\u1E6A": "T\u0307",
  "\u0162": "T\u0327",
  "\xDA": "U\u0301",
  "\xD9": "U\u0300",
  "\xDC": "U\u0308",
  "\u01D7": "U\u0308\u0301",
  "\u01DB": "U\u0308\u0300",
  "\u01D5": "U\u0308\u0304",
  "\u01D9": "U\u0308\u030C",
  "\u0168": "U\u0303",
  "\u1E78": "U\u0303\u0301",
  "\u016A": "U\u0304",
  "\u1E7A": "U\u0304\u0308",
  "\u016C": "U\u0306",
  "\u01D3": "U\u030C",
  "\xDB": "U\u0302",
  "\u016E": "U\u030A",
  "\u0170": "U\u030B",
  "\u1E7C": "V\u0303",
  "\u1E82": "W\u0301",
  "\u1E80": "W\u0300",
  "\u1E84": "W\u0308",
  "\u0174": "W\u0302",
  "\u1E86": "W\u0307",
  "\u1E8C": "X\u0308",
  "\u1E8A": "X\u0307",
  "\xDD": "Y\u0301",
  "\u1EF2": "Y\u0300",
  "\u0178": "Y\u0308",
  "\u1EF8": "Y\u0303",
  "\u0232": "Y\u0304",
  "\u0176": "Y\u0302",
  "\u1E8E": "Y\u0307",
  "\u0179": "Z\u0301",
  "\u017D": "Z\u030C",
  "\u1E90": "Z\u0302",
  "\u017B": "Z\u0307",
  "\u03AC": "\u03B1\u0301",
  "\u1F70": "\u03B1\u0300",
  "\u1FB1": "\u03B1\u0304",
  "\u1FB0": "\u03B1\u0306",
  "\u03AD": "\u03B5\u0301",
  "\u1F72": "\u03B5\u0300",
  "\u03AE": "\u03B7\u0301",
  "\u1F74": "\u03B7\u0300",
  "\u03AF": "\u03B9\u0301",
  "\u1F76": "\u03B9\u0300",
  "\u03CA": "\u03B9\u0308",
  "\u0390": "\u03B9\u0308\u0301",
  "\u1FD2": "\u03B9\u0308\u0300",
  "\u1FD1": "\u03B9\u0304",
  "\u1FD0": "\u03B9\u0306",
  "\u03CC": "\u03BF\u0301",
  "\u1F78": "\u03BF\u0300",
  "\u03CD": "\u03C5\u0301",
  "\u1F7A": "\u03C5\u0300",
  "\u03CB": "\u03C5\u0308",
  "\u03B0": "\u03C5\u0308\u0301",
  "\u1FE2": "\u03C5\u0308\u0300",
  "\u1FE1": "\u03C5\u0304",
  "\u1FE0": "\u03C5\u0306",
  "\u03CE": "\u03C9\u0301",
  "\u1F7C": "\u03C9\u0300",
  "\u038E": "\u03A5\u0301",
  "\u1FEA": "\u03A5\u0300",
  "\u03AB": "\u03A5\u0308",
  "\u1FE9": "\u03A5\u0304",
  "\u1FE8": "\u03A5\u0306",
  "\u038F": "\u03A9\u0301",
  "\u1FFA": "\u03A9\u0300"
};
class Parser {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    this.mode = "math";
    this.gullet = new MacroExpander(input, settings, this.mode);
    this.settings = settings;
    this.leftrightDepth = 0;
  }
  expect(text2, consume) {
    if (consume === void 0) {
      consume = true;
    }
    if (this.fetch().text !== text2) {
      throw new ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }
  consume() {
    this.nextToken = null;
  }
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  parse() {
    if (!this.settings.globalGroup) {
      this.gullet.beginGroup();
    }
    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }
    try {
      var parse = this.parseExpression(false);
      this.expect("EOF");
      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }
      return parse;
    } finally {
      this.gullet.endGroups();
    }
  }
  parseExpression(breakOnInfix, breakOnTokenText) {
    var body = [];
    while (true) {
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      var lex = this.fetch();
      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      var atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }
  handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;
    for (var i2 = 0; i2 < body.length; i2++) {
      if (body[i2].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i2].token);
        }
        overIndex = i2;
        funcName = body[i2].replaceWith;
      }
    }
    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);
      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }
      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }
      var node;
      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node];
    } else {
      return body;
    }
  }
  handleSupSubscript(name) {
    var symbolToken = this.fetch();
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces();
    var group = this.parseGroup(name);
    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }
    return group;
  }
  formatUnsupportedCmd(text2) {
    var textordArray = [];
    for (var i2 = 0; i2 < text2.length; i2++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text2[i2]
      });
    }
    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  parseAtom(breakOnTokenText) {
    var base2 = this.parseGroup("atom", breakOnTokenText);
    if (this.mode === "text") {
      return base2;
    }
    var superscript;
    var subscript;
    while (true) {
      this.consumeSpaces();
      var lex = this.fetch();
      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        if (base2 && base2.type === "op") {
          var limits = lex.text === "\\limits";
          base2.limits = limits;
          base2.alwaysHandleSupSub = true;
        } else if (base2 && base2.type === "operatorname") {
          if (base2.alwaysHandleSupSub) {
            base2.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        var prime2 = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        };
        var primes2 = [prime2];
        this.consume();
        while (this.fetch().text === "'") {
          primes2.push(prime2);
          this.consume();
        }
        if (this.fetch().text === "^") {
          primes2.push(this.handleSupSubscript("superscript"));
        }
        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes2
        };
      } else {
        break;
      }
    }
    if (superscript || subscript) {
      return {
        type: "supsub",
        mode: this.mode,
        base: base2,
        sup: superscript,
        sub: subscript
      };
    } else {
      return base2;
    }
  }
  parseFunction(breakOnTokenText, name) {
    var token = this.fetch();
    var func = token.text;
    var funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume();
    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }
    var {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    var context2 = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    var func = functions[name];
    if (func && func.handler) {
      return func.handler(context2, args, optArgs);
    } else {
      throw new ParseError("No function handler for " + name);
    }
  }
  parseArguments(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }
    var args = [];
    var optArgs = [];
    for (var i2 = 0; i2 < totalArgs; i2++) {
      var argType = funcData.argTypes && funcData.argTypes[i2];
      var isOptional = i2 < funcData.numOptionalArgs;
      if (funcData.primitive && argType == null || funcData.type === "sqrt" && i2 === 1 && optArgs[0] == null) {
        argType = "primitive";
      }
      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        throw new ParseError("Null argument, please report this as a bug");
      }
    }
    return {
      args,
      optArgs
    };
  }
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        var group = this.parseArgumentGroup(optional, "text");
        return group != null ? {
          type: "styling",
          mode: group.mode,
          body: [group],
          style: "text"
        } : null;
      }
      case "raw": {
        var token = this.parseStringGroup("raw", optional);
        return token != null ? {
          type: "raw",
          mode: "text",
          string: token.text
        } : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        var _group = this.parseGroup(name);
        if (_group == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return _group;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }
  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  parseStringGroup(modeName, optional) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var str2 = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str2 += nextToken.text;
      this.consume();
    }
    this.consume();
    argToken.text = str2;
    return argToken;
  }
  parseRegexGroup(regex, modeName) {
    var firstToken = this.fetch();
    var lastToken = firstToken;
    var str2 = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str2 + nextToken.text)) {
      lastToken = nextToken;
      str2 += lastToken.text;
      this.consume();
    }
    if (str2 === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str2);
  }
  parseColorGroup(optional) {
    var res = this.parseStringGroup("color", optional);
    if (res == null) {
      return null;
    }
    var match2 = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
    if (!match2) {
      throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    var color = match2[0];
    if (/^[0-9a-f]{6}$/i.test(color)) {
      color = "#" + color;
    }
    return {
      type: "color-token",
      mode: this.mode,
      color
    };
  }
  parseSizeGroup(optional) {
    var res;
    var isBlank = false;
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      res.text = "0pt";
      isBlank = true;
    }
    var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
    if (!match2) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data2 = {
      number: +(match2[1] + match2[2]),
      unit: match2[3]
    };
    if (!validUnit(data2)) {
      throw new ParseError("Invalid unit: '" + data2.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data2,
      isBlank
    };
  }
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13);
    this.gullet.lexer.setCatcode("~", 12);
    var res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14);
    this.gullet.lexer.setCatcode("~", 13);
    if (res == null) {
      return null;
    }
    var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }
  parseArgumentGroup(optional, mode) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var outerMode = this.mode;
    if (mode) {
      this.switchMode(mode);
    }
    this.gullet.beginGroup();
    var expression = this.parseExpression(false, "EOF");
    this.expect("EOF");
    this.gullet.endGroup();
    var result2 = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };
    if (mode) {
      this.switchMode(outerMode);
    }
    return result2;
  }
  parseGroup(name, breakOnTokenText) {
    var firstToken = this.fetch();
    var text2 = firstToken.text;
    var result2;
    if (text2 === "{" || text2 === "\\begingroup") {
      this.consume();
      var groupEnd = text2 === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.fetch();
      this.expect(groupEnd);
      this.gullet.endGroup();
      result2 = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        semisimple: text2 === "\\begingroup" || void 0
      };
    } else {
      result2 = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result2 == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
        if (this.settings.throwOnError) {
          throw new ParseError("Undefined control sequence: " + text2, firstToken);
        }
        result2 = this.formatUnsupportedCmd(text2);
        this.consume();
      }
    }
    return result2;
  }
  formLigatures(group) {
    var n2 = group.length - 1;
    for (var i2 = 0; i2 < n2; ++i2) {
      var a2 = group[i2];
      var v2 = a2.text;
      if (v2 === "-" && group[i2 + 1].text === "-") {
        if (i2 + 1 < n2 && group[i2 + 2].text === "-") {
          group.splice(i2, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a2, group[i2 + 2]),
            text: "---"
          });
          n2 -= 2;
        } else {
          group.splice(i2, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a2, group[i2 + 1]),
            text: "--"
          });
          n2 -= 1;
        }
      }
      if ((v2 === "'" || v2 === "`") && group[i2 + 1].text === v2) {
        group.splice(i2, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a2, group[i2 + 1]),
          text: v2 + v2
        });
        n2 -= 1;
      }
    }
  }
  parseSymbol() {
    var nucleus = this.fetch();
    var text2 = nucleus.text;
    if (/^\\verb[^a-zA-Z]/.test(text2)) {
      this.consume();
      var arg = text2.slice(5);
      var star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }
      arg = arg.slice(1, -1);
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    if (unicodeSymbols.hasOwnProperty(text2[0]) && !symbols[this.mode][text2[0]]) {
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      text2 = unicodeSymbols[text2[0]] + text2.substr(1);
    }
    var match2 = combiningDiacriticalMarksEndRegex.exec(text2);
    if (match2) {
      text2 = text2.substring(0, match2.index);
      if (text2 === "i") {
        text2 = "\u0131";
      } else if (text2 === "j") {
        text2 = "\u0237";
      }
    }
    var symbol;
    if (symbols[this.mode][text2]) {
      if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      var group = symbols[this.mode][text2].group;
      var loc = SourceLocation.range(nucleus);
      var s2;
      if (ATOMS.hasOwnProperty(group)) {
        var family = group;
        s2 = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text: text2
        };
      } else {
        s2 = {
          type: group,
          mode: this.mode,
          loc,
          text: text2
        };
      }
      symbol = s2;
    } else if (text2.charCodeAt(0) >= 128) {
      if (this.settings.strict) {
        if (!supportedCodepoint(text2.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
        }
      }
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text: text2
      };
    } else {
      return null;
    }
    this.consume();
    if (match2) {
      for (var i2 = 0; i2 < match2[0].length; i2++) {
        var accent2 = match2[0][i2];
        if (!unicodeAccents[accent2]) {
          throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
        }
        var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
        if (!command) {
          throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          base: symbol
        };
      }
    }
    return symbol;
  }
}
Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var parseTree = function parseTree2(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("KaTeX can only parse string typed expression");
  }
  var parser = new Parser(toParse, settings);
  delete parser.gullet.macros.current["\\df@tag"];
  var tree = parser.parse();
  delete parser.gullet.macros.current["\\current@color"];
  delete parser.gullet.macros.current["\\color"];
  if (parser.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new ParseError("\\tag works only in display equations");
    }
    parser.gullet.feed("\\df@tag");
    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser.parse()
    }];
  }
  return tree;
};
var render = function render2(expression, baseNode, options2) {
  baseNode.textContent = "";
  var node = renderToDomTree(expression, options2).toNode();
  baseNode.appendChild(node);
};
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
    render = function render3() {
      throw new ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
var renderToString = function renderToString2(expression, options2) {
  var markup = renderToDomTree(expression, options2).toMarkup();
  return markup;
};
var generateParseTree = function generateParseTree2(expression, options2) {
  var settings = new Settings(options2);
  return parseTree(expression, settings);
};
var renderError = function renderError2(error2, expression, options2) {
  if (options2.throwOnError || !(error2 instanceof ParseError)) {
    throw error2;
  }
  var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node.setAttribute("title", error2.toString());
  node.setAttribute("style", "color:" + options2.errorColor);
  return node;
};
var renderToDomTree = function renderToDomTree2(expression, options2) {
  var settings = new Settings(options2);
  try {
    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error2) {
    return renderError(error2, expression, settings);
  }
};
var renderToHTMLTree = function renderToHTMLTree2(expression, options2) {
  var settings = new Settings(options2);
  try {
    var tree = parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error2) {
    return renderError(error2, expression, settings);
  }
};
var katex$2 = {
  version: "0.13.24",
  render,
  renderToString,
  ParseError,
  __parse: generateParseTree,
  __renderToDomTree: renderToDomTree,
  __renderToHTMLTree: renderToHTMLTree,
  __setFontMetrics: setFontMetrics,
  __defineSymbol: defineSymbol,
  __defineMacro: defineMacro,
  __domTree: {
    Span,
    Anchor,
    SymbolNode,
    SvgNode,
    PathNode,
    LineNode
  }
};
var findEndOfMath = function findEndOfMath2(delimiter2, text2, startIndex) {
  var index = startIndex;
  var braceLevel = 0;
  var delimLength = delimiter2.length;
  while (index < text2.length) {
    var character = text2[index];
    if (braceLevel <= 0 && text2.slice(index, index + delimLength) === delimiter2) {
      return index;
    } else if (character === "\\") {
      index++;
    } else if (character === "{") {
      braceLevel++;
    } else if (character === "}") {
      braceLevel--;
    }
    index++;
  }
  return -1;
};
var escapeRegex = function escapeRegex2(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};
var amsRegex = /^\\begin{/;
var splitAtDelimiters = function splitAtDelimiters2(text2, delimiters2) {
  var index;
  var data2 = [];
  var regexLeft = new RegExp("(" + delimiters2.map((x2) => escapeRegex(x2.left)).join("|") + ")");
  while (true) {
    index = text2.search(regexLeft);
    if (index === -1) {
      break;
    }
    if (index > 0) {
      data2.push({
        type: "text",
        data: text2.slice(0, index)
      });
      text2 = text2.slice(index);
    }
    var i2 = delimiters2.findIndex((delim) => text2.startsWith(delim.left));
    index = findEndOfMath(delimiters2[i2].right, text2, delimiters2[i2].left.length);
    if (index === -1) {
      break;
    }
    var rawData = text2.slice(0, index + delimiters2[i2].right.length);
    var math2 = amsRegex.test(rawData) ? rawData : text2.slice(delimiters2[i2].left.length, index);
    data2.push({
      type: "math",
      data: math2,
      rawData,
      display: delimiters2[i2].display
    });
    text2 = text2.slice(index + delimiters2[i2].right.length);
  }
  if (text2 !== "") {
    data2.push({
      type: "text",
      data: text2
    });
  }
  return data2;
};
var renderMathInText = function renderMathInText2(text2, optionsCopy) {
  var data2 = splitAtDelimiters(text2, optionsCopy.delimiters);
  if (data2.length === 1 && data2[0].type === "text") {
    return null;
  }
  var fragment = document.createDocumentFragment();
  for (var i2 = 0; i2 < data2.length; i2++) {
    if (data2[i2].type === "text") {
      fragment.appendChild(document.createTextNode(data2[i2].data));
    } else {
      var span = document.createElement("span");
      var math2 = data2[i2].data;
      optionsCopy.displayMode = data2[i2].display;
      try {
        if (optionsCopy.preProcess) {
          math2 = optionsCopy.preProcess(math2);
        }
        katex$2.render(math2, span, optionsCopy);
      } catch (e2) {
        if (!(e2 instanceof katex$2.ParseError)) {
          throw e2;
        }
        optionsCopy.errorCallback("KaTeX auto-render: Failed to parse `" + data2[i2].data + "` with ", e2);
        fragment.appendChild(document.createTextNode(data2[i2].rawData));
        continue;
      }
      fragment.appendChild(span);
    }
  }
  return fragment;
};
var renderElem = function renderElem2(elem, optionsCopy) {
  for (var i2 = 0; i2 < elem.childNodes.length; i2++) {
    var childNode = elem.childNodes[i2];
    if (childNode.nodeType === 3) {
      var frag = renderMathInText(childNode.textContent, optionsCopy);
      if (frag) {
        i2 += frag.childNodes.length - 1;
        elem.replaceChild(frag, childNode);
      }
    } else if (childNode.nodeType === 1) {
      (function() {
        var className = " " + childNode.className + " ";
        var shouldRender = optionsCopy.ignoredTags.indexOf(childNode.nodeName.toLowerCase()) === -1 && optionsCopy.ignoredClasses.every((x2) => className.indexOf(" " + x2 + " ") === -1);
        if (shouldRender) {
          renderElem2(childNode, optionsCopy);
        }
      })();
    }
  }
};
var renderMathInElement = function renderMathInElement2(elem, options2) {
  if (!elem) {
    throw new Error("No element provided to render");
  }
  var optionsCopy = {};
  for (var option in options2) {
    if (options2.hasOwnProperty(option)) {
      optionsCopy[option] = options2[option];
    }
  }
  optionsCopy.delimiters = optionsCopy.delimiters || [
    {
      left: "$$",
      right: "$$",
      display: true
    },
    {
      left: "\\(",
      right: "\\)",
      display: false
    },
    {
      left: "\\begin{equation}",
      right: "\\end{equation}",
      display: true
    },
    {
      left: "\\begin{align}",
      right: "\\end{align}",
      display: true
    },
    {
      left: "\\begin{alignat}",
      right: "\\end{alignat}",
      display: true
    },
    {
      left: "\\begin{gather}",
      right: "\\end{gather}",
      display: true
    },
    {
      left: "\\begin{CD}",
      right: "\\end{CD}",
      display: true
    },
    {
      left: "\\[",
      right: "\\]",
      display: true
    }
  ];
  optionsCopy.ignoredTags = optionsCopy.ignoredTags || ["script", "noscript", "style", "textarea", "pre", "code", "option"];
  optionsCopy.ignoredClasses = optionsCopy.ignoredClasses || [];
  optionsCopy.errorCallback = optionsCopy.errorCallback || console.error;
  optionsCopy.macros = optionsCopy.macros || {};
  renderElem(elem, optionsCopy);
};
function katex$1(html) {
  let ele = document.createElement("div");
  ele.innerHTML = html;
  renderMathInElement(ele);
  let T2 = ele.innerHTML;
  ele.remove();
  return T2;
}
class Timer {
  constructor(limit) {
    this.limit = limit;
    this.start = Date.now();
  }
  elapsed() {
    return (Date.now() - this.start) / 1e3;
  }
  over() {
    return this.elapsed() > this.limit;
  }
  check() {
    if (this.over())
      throw CustomError("TimeoutError", "running too long: > " + this.limit + "s");
  }
}
class ErrorLogger {
  constructor() {
    this.pile = [];
  }
  add(e2) {
    let err2 = toError(e2);
    this.pile.push("[" + err2.name + "] " + err2.message);
  }
  readHtml(delimiter2) {
    return this.pile.map(($) => $.replaceAll("\n", "<br/>")).join(delimiter2);
  }
  logs() {
    return [...this.pile];
  }
  html() {
    let text2 = this.readHtml("<br/><br/>");
    let len = text2.length;
    if (len > 1e3)
      text2 = text2.substring(0, 1e3) + ` ... (${len} chars)`;
    return text2;
  }
  lastLogHtml() {
    return this.pile[this.pile.length - 1].replaceAll("\n", "<br/>");
  }
}
class Soil {
  constructor(gene) {
    this.gene = gene;
    this.qn = "";
    this.sol = "";
    this.dict = new Dict();
    this.config = new Config();
    this.counter = 0;
    this.timer = new Timer(10);
    this.logger = new ErrorLogger();
    this.reset();
  }
  reset() {
    this.qn = this.gene.qn;
    this.sol = this.gene.sol;
    this.dict = new Dict();
    this.config = new Config();
  }
  evalCode(code2) {
    let { result: result2, context: context2 } = evaluate(code2, {
      dict: this.dict,
      sections: this.config.sections,
      answer: this.config.answer,
      options: this.config.options,
      shuffle: this.config.shuffle,
      qn: this.qn,
      sol: this.sol
    });
    this.dict = context2.dict;
    this.config = {
      sections: context2.sections,
      answer: context2.answer,
      options: context2.options,
      shuffle: context2.shuffle
    };
    this.qn = context2.qn;
    this.sol = context2.sol;
    return result2;
  }
  pushDict() {
    this.counter++;
    this.evalCode(this.gene.populate);
  }
  isValidated() {
    let v2 = this.gene.validate;
    if (v2 === "")
      return true;
    v2 = v2.replace("\n", " ");
    return this.evalCode(v2) === true;
  }
  runPopulate() {
    while (this.counter <= 1e3) {
      this.timer.check();
      try {
        this.pushDict();
        if (!this.dict.checked())
          throw CustomError("PopulationError", "Dict Check Failed.");
        if (!this.isValidated())
          throw CustomError("PopulationError", "Cannot pass validate.");
        return true;
      } catch (e2) {
        if (e2 instanceof Error) {
          switch (e2.name) {
            case "ContractError":
              this.logger.add(e2);
              break;
            case "MathError":
              this.logger.add(e2);
              break;
            case "PopulationError":
              this.logger.add(e2);
              break;
            default:
              throw e2;
          }
        } else {
          throw e2;
        }
      }
    }
    throw CustomError("PopulationError", "No population found after 1000 trials!");
  }
  runSection() {
    this.qn = ExecSection(this.qn, this.config.sections, this.dict);
    this.sol = ExecSection(this.sol, this.config.sections, this.dict);
    return true;
  }
  runPreprocess() {
    this.evalCode(this.gene.preprocess);
    return true;
  }
  runOption() {
    let nTrial = 0;
    while (nTrial <= 100) {
      nTrial++;
      try {
        this.qn = AutoOptions(this.config.options, this.qn, this.dict);
        return true;
      } catch (e2) {
        this.logger.add(e2);
        continue;
      }
    }
    throw CustomError("OptionError", "No valid option generated after 100 trials");
  }
  runIntrapolate() {
    this.qn = intrapolate(this.qn, this.dict);
    this.sol = intrapolate(this.sol, this.dict);
    return true;
  }
  runSubstitute() {
    this.qn = this.dict.substitute(this.qn);
    this.sol = this.dict.substitute(this.sol);
    this.qn = dress(this.qn);
    this.sol = dress(this.sol);
    return true;
  }
  runPostprocess() {
    this.evalCode(this.gene.postprocess);
    return true;
  }
  runShuffle() {
    let shuffler = new OptionShuffler(this.qn, this.sol, this.config.answer, this.config.shuffle);
    if (shuffler.AreOptionsDuplicated()) {
      this.logger.add(CustomError("ShuffleError", "Duplicated options found!"));
      return false;
    }
    this.qn = shuffler.genQn();
    this.sol = shuffler.genSol();
    this.config.answer = shuffler.genAns();
    return true;
  }
  runKatex() {
    this.qn = katex$1(this.qn);
    this.sol = katex$1(this.sol);
    return true;
  }
  successFruit() {
    return {
      qn: this.qn,
      sol: this.sol,
      ans: this.config.answer,
      counter: this.counter,
      success: true,
      logs: this.logger.logs(),
      time: this.timer.elapsed()
    };
  }
  errorFruit() {
    return {
      qn: "Error!<br/>" + this.logger.lastLogHtml(),
      sol: this.logger.html(),
      ans: "X",
      counter: this.counter,
      success: false,
      logs: this.logger.logs(),
      time: this.timer.elapsed()
    };
  }
  nurture() {
    try {
      do {
        this.reset();
        this.runPopulate();
        this.runSection();
        this.runPreprocess();
        this.runOption();
        this.runIntrapolate();
        this.runSubstitute();
        this.runPostprocess();
        if (!this.runShuffle())
          continue;
        this.runKatex();
        break;
      } while (true);
      return this.successFruit();
    } catch (e2) {
      this.logger.add(e2);
      return this.errorFruit();
    }
  }
}
class MathSoilCls {
  reap(seed) {
    let soil = new Soil(seed.gene);
    return soil.nurture();
  }
  grow(seed) {
    seed.fruit = this.reap(seed);
  }
  growAll(seeds) {
    seeds.forEach((x2) => this.grow(x2));
  }
  test(seed, repeat = 100) {
    let counters = [];
    for (let i2 = 1; i2 <= repeat; i2++) {
      this.grow(seed);
      if (!seed.fruit.success)
        return;
      counters.push(seed.fruit.counter);
    }
    seed.fruit.counter = Mean(...counters);
  }
}
var MathSoil = new MathSoilCls();
globalThis.MathSoil = MathSoil;
class MathSoil2Cls {
  reap(gene) {
    let soil = new Soil(gene);
    return soil.nurture();
  }
  inspect(gene, repeat) {
    let counters = [];
    let times = [];
    for (let i2 = 1; i2 <= repeat; i2++) {
      let fruit = this.reap(gene);
      if (!fruit.success)
        return {
          counter: 0,
          success: false,
          logs: fruit.logs,
          time: 0
        };
      counters.push(fruit.counter);
      times.push(fruit.time);
    }
    return {
      counter: Mean(...counters),
      success: true,
      logs: [],
      time: Mean(...times)
    };
  }
}
var MathSoil2 = new MathSoil2Cls();
globalThis.MathSoil2 = MathSoil2;
var katex = { exports: {} };
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return function() {
      var __webpack_require__ = {};
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      var __webpack_exports__ = {};
      __webpack_require__.d(__webpack_exports__, {
        "default": function() {
          return katex_webpack;
        }
      });
      var ParseError2 = function ParseError3(message, token) {
        this.position = void 0;
        var error2 = "KaTeX parse error: " + message;
        var start;
        var loc = token && token.loc;
        if (loc && loc.start <= loc.end) {
          var input = loc.lexer.input;
          start = loc.start;
          var end = loc.end;
          if (start === input.length) {
            error2 += " at end of input: ";
          } else {
            error2 += " at position " + (start + 1) + ": ";
          }
          var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
          var left2;
          if (start > 15) {
            left2 = "\u2026" + input.slice(start - 15, start);
          } else {
            left2 = input.slice(0, start);
          }
          var right;
          if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "\u2026";
          } else {
            right = input.slice(end);
          }
          error2 += left2 + underlined + right;
        }
        var self2 = new Error(error2);
        self2.name = "ParseError";
        self2.__proto__ = ParseError3.prototype;
        self2.position = start;
        return self2;
      };
      ParseError2.prototype.__proto__ = Error.prototype;
      var src_ParseError = ParseError2;
      var contains3 = function contains4(list2, elem) {
        return list2.indexOf(elem) !== -1;
      };
      var deflt3 = function deflt4(setting, defaultIfUndefined) {
        return setting === void 0 ? defaultIfUndefined : setting;
      };
      var uppercase2 = /([A-Z])/g;
      var hyphenate3 = function hyphenate4(str2) {
        return str2.replace(uppercase2, "-$1").toLowerCase();
      };
      var ESCAPE_LOOKUP2 = {
        "&": "&amp;",
        ">": "&gt;",
        "<": "&lt;",
        '"': "&quot;",
        "'": "&#x27;"
      };
      var ESCAPE_REGEX2 = /[&><"']/g;
      function utils_escape(text2) {
        return String(text2).replace(ESCAPE_REGEX2, function(match2) {
          return ESCAPE_LOOKUP2[match2];
        });
      }
      var getBaseElem3 = function getBaseElem4(group) {
        if (group.type === "ordgroup") {
          if (group.body.length === 1) {
            return getBaseElem4(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "color") {
          if (group.body.length === 1) {
            return getBaseElem4(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "font") {
          return getBaseElem4(group.body);
        } else {
          return group;
        }
      };
      var isCharacterBox3 = function isCharacterBox4(group) {
        var baseElem = getBaseElem3(group);
        return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
      };
      var assert3 = function assert4(value) {
        if (!value) {
          throw new Error("Expected non-null, but got " + String(value));
        }
        return value;
      };
      var protocolFromUrl3 = function protocolFromUrl4(url) {
        var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
        return protocol != null ? protocol[1] : "_relative";
      };
      var utils2 = {
        contains: contains3,
        deflt: deflt3,
        escape: utils_escape,
        hyphenate: hyphenate3,
        getBaseElem: getBaseElem3,
        isCharacterBox: isCharacterBox3,
        protocolFromUrl: protocolFromUrl3
      };
      var Settings2 = /* @__PURE__ */ function() {
        function Settings3(options2) {
          this.displayMode = void 0;
          this.output = void 0;
          this.leqno = void 0;
          this.fleqn = void 0;
          this.throwOnError = void 0;
          this.errorColor = void 0;
          this.macros = void 0;
          this.minRuleThickness = void 0;
          this.colorIsTextColor = void 0;
          this.strict = void 0;
          this.trust = void 0;
          this.maxSize = void 0;
          this.maxExpand = void 0;
          this.globalGroup = void 0;
          options2 = options2 || {};
          this.displayMode = utils2.deflt(options2.displayMode, false);
          this.output = utils2.deflt(options2.output, "htmlAndMathml");
          this.leqno = utils2.deflt(options2.leqno, false);
          this.fleqn = utils2.deflt(options2.fleqn, false);
          this.throwOnError = utils2.deflt(options2.throwOnError, true);
          this.errorColor = utils2.deflt(options2.errorColor, "#cc0000");
          this.macros = options2.macros || {};
          this.minRuleThickness = Math.max(0, utils2.deflt(options2.minRuleThickness, 0));
          this.colorIsTextColor = utils2.deflt(options2.colorIsTextColor, false);
          this.strict = utils2.deflt(options2.strict, "warn");
          this.trust = utils2.deflt(options2.trust, false);
          this.maxSize = Math.max(0, utils2.deflt(options2.maxSize, Infinity));
          this.maxExpand = Math.max(0, utils2.deflt(options2.maxExpand, 1e3));
          this.globalGroup = utils2.deflt(options2.globalGroup, false);
        }
        var _proto = Settings3.prototype;
        _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            strict = strict(errorCode, errorMsg, token);
          }
          if (!strict || strict === "ignore") {
            return;
          } else if (strict === true || strict === "error") {
            throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
        };
        _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            try {
              strict = strict(errorCode, errorMsg, token);
            } catch (error2) {
              strict = "error";
            }
          }
          if (!strict || strict === "ignore") {
            return false;
          } else if (strict === true || strict === "error") {
            return true;
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            return false;
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            return false;
          }
        };
        _proto.isTrusted = function isTrusted(context2) {
          if (context2.url && !context2.protocol) {
            context2.protocol = utils2.protocolFromUrl(context2.url);
          }
          var trust = typeof this.trust === "function" ? this.trust(context2) : this.trust;
          return Boolean(trust);
        };
        return Settings3;
      }();
      var Style2 = /* @__PURE__ */ function() {
        function Style3(id, size, cramped) {
          this.id = void 0;
          this.size = void 0;
          this.cramped = void 0;
          this.id = id;
          this.size = size;
          this.cramped = cramped;
        }
        var _proto = Style3.prototype;
        _proto.sup = function sup2() {
          return styles2[_sup[this.id]];
        };
        _proto.sub = function sub2() {
          return styles2[_sub[this.id]];
        };
        _proto.fracNum = function fracNum2() {
          return styles2[_fracNum[this.id]];
        };
        _proto.fracDen = function fracDen2() {
          return styles2[_fracDen[this.id]];
        };
        _proto.cramp = function cramp2() {
          return styles2[_cramp[this.id]];
        };
        _proto.text = function text2() {
          return styles2[_text[this.id]];
        };
        _proto.isTight = function isTight() {
          return this.size >= 2;
        };
        return Style3;
      }();
      var D2 = 0;
      var Dc2 = 1;
      var T2 = 2;
      var Tc2 = 3;
      var S2 = 4;
      var Sc2 = 5;
      var SS2 = 6;
      var SSc2 = 7;
      var styles2 = [new Style2(D2, 0, false), new Style2(Dc2, 0, true), new Style2(T2, 1, false), new Style2(Tc2, 1, true), new Style2(S2, 2, false), new Style2(Sc2, 2, true), new Style2(SS2, 3, false), new Style2(SSc2, 3, true)];
      var _sup = [S2, Sc2, S2, Sc2, SS2, SSc2, SS2, SSc2];
      var _sub = [Sc2, Sc2, Sc2, Sc2, SSc2, SSc2, SSc2, SSc2];
      var _fracNum = [T2, Tc2, S2, Sc2, SS2, SSc2, SS2, SSc2];
      var _fracDen = [Tc2, Tc2, Sc2, Sc2, SSc2, SSc2, SSc2, SSc2];
      var _cramp = [Dc2, Dc2, Tc2, Tc2, Sc2, Sc2, SSc2, SSc2];
      var _text = [D2, Dc2, T2, Tc2, T2, Tc2, T2, Tc2];
      var src_Style = {
        DISPLAY: styles2[D2],
        TEXT: styles2[T2],
        SCRIPT: styles2[S2],
        SCRIPTSCRIPT: styles2[SS2]
      };
      var scriptData2 = [{
        name: "latin",
        blocks: [
          [256, 591],
          [768, 879]
        ]
      }, {
        name: "cyrillic",
        blocks: [[1024, 1279]]
      }, {
        name: "armenian",
        blocks: [[1328, 1423]]
      }, {
        name: "brahmic",
        blocks: [[2304, 4255]]
      }, {
        name: "georgian",
        blocks: [[4256, 4351]]
      }, {
        name: "cjk",
        blocks: [
          [12288, 12543],
          [19968, 40879],
          [65280, 65376]
        ]
      }, {
        name: "hangul",
        blocks: [[44032, 55215]]
      }];
      function scriptFromCodepoint2(codepoint) {
        for (var i3 = 0; i3 < scriptData2.length; i3++) {
          var script = scriptData2[i3];
          for (var _i7 = 0; _i7 < script.blocks.length; _i7++) {
            var block = script.blocks[_i7];
            if (codepoint >= block[0] && codepoint <= block[1]) {
              return script.name;
            }
          }
        }
        return null;
      }
      var allBlocks2 = [];
      scriptData2.forEach(function(s2) {
        return s2.blocks.forEach(function(b2) {
          return allBlocks2.push.apply(allBlocks2, b2);
        });
      });
      function supportedCodepoint2(codepoint) {
        for (var i3 = 0; i3 < allBlocks2.length; i3 += 2) {
          if (codepoint >= allBlocks2[i3] && codepoint <= allBlocks2[i3 + 1]) {
            return true;
          }
        }
        return false;
      }
      var hLinePad2 = 80;
      var sqrtMain3 = function sqrtMain4(extraViniculum, hLinePad3) {
        return "M95," + (622 + extraViniculum + hLinePad3) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad3 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize13 = function sqrtSize14(extraViniculum, hLinePad3) {
        return "M263," + (601 + extraViniculum + hLinePad3) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad3 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize23 = function sqrtSize24(extraViniculum, hLinePad3) {
        return "M983 " + (10 + extraViniculum + hLinePad3) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad3 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize33 = function sqrtSize34(extraViniculum, hLinePad3) {
        return "M424," + (2398 + extraViniculum + hLinePad3) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad3 + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize43 = function sqrtSize44(extraViniculum, hLinePad3) {
        return "M473," + (2713 + extraViniculum + hLinePad3) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad3 + "h400000v" + (40 + extraViniculum) + "H1017.7z";
      };
      var phasePath3 = function phasePath4(y2) {
        var x2 = y2 / 2;
        return "M400000 " + y2 + " H0 L" + x2 + " 0 l65 45 L145 " + (y2 - 80) + " H400000z";
      };
      var sqrtTall3 = function sqrtTall4(extraViniculum, hLinePad3, viewBoxHeight) {
        var vertSegment = viewBoxHeight - 54 - hLinePad3 - extraViniculum;
        return "M702 " + (extraViniculum + hLinePad3) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad3 + "H400000v" + (40 + extraViniculum) + "H742z";
      };
      var sqrtPath3 = function sqrtPath4(size, extraViniculum, viewBoxHeight) {
        extraViniculum = 1e3 * extraViniculum;
        var path3 = "";
        switch (size) {
          case "sqrtMain":
            path3 = sqrtMain3(extraViniculum, hLinePad2);
            break;
          case "sqrtSize1":
            path3 = sqrtSize13(extraViniculum, hLinePad2);
            break;
          case "sqrtSize2":
            path3 = sqrtSize23(extraViniculum, hLinePad2);
            break;
          case "sqrtSize3":
            path3 = sqrtSize33(extraViniculum, hLinePad2);
            break;
          case "sqrtSize4":
            path3 = sqrtSize43(extraViniculum, hLinePad2);
            break;
          case "sqrtTall":
            path3 = sqrtTall3(extraViniculum, hLinePad2, viewBoxHeight);
        }
        return path3;
      };
      var innerPath3 = function innerPath4(name, height) {
        switch (name) {
          case "\u239C":
            return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
          case "\u2223":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
          case "\u2225":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
          case "\u239F":
            return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
          case "\u23A2":
            return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
          case "\u23A5":
            return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
          case "\u23AA":
            return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
          case "\u23D0":
            return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
          case "\u2016":
            return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
          default:
            return "";
        }
      };
      var path2 = {
        doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
        doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
        leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
        leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
        leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
        leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
        leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
        leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
        leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
        leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
        leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
        lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
        leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
        leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
        leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
        longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
        midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
        midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
        oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
        oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
        oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
        oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
        rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
        rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
        rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
        rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
        rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
        rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
        rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
        rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
        rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
        righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
        rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
        rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
        twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
        twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
        tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
        tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
        tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
        tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
        vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
        widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
        widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
        widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
        rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
        baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
        rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
        shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
        shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
      };
      var DocumentFragment2 = /* @__PURE__ */ function() {
        function DocumentFragment3(children) {
          this.children = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.children = children;
          this.classes = [];
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = {};
        }
        var _proto = DocumentFragment3.prototype;
        _proto.hasClass = function hasClass(className) {
          return utils2.contains(this.classes, className);
        };
        _proto.toNode = function toNode3() {
          var frag = document.createDocumentFragment();
          for (var i3 = 0; i3 < this.children.length; i3++) {
            frag.appendChild(this.children[i3].toNode());
          }
          return frag;
        };
        _proto.toMarkup = function toMarkup3() {
          var markup = "";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          return markup;
        };
        _proto.toText = function toText() {
          var toText2 = function toText3(child) {
            return child.toText();
          };
          return this.children.map(toText2).join("");
        };
        return DocumentFragment3;
      }();
      var fontMetricsData2 = {
        "AMS-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68889, 0, 0, 0.72222],
          "66": [0, 0.68889, 0, 0, 0.66667],
          "67": [0, 0.68889, 0, 0, 0.72222],
          "68": [0, 0.68889, 0, 0, 0.72222],
          "69": [0, 0.68889, 0, 0, 0.66667],
          "70": [0, 0.68889, 0, 0, 0.61111],
          "71": [0, 0.68889, 0, 0, 0.77778],
          "72": [0, 0.68889, 0, 0, 0.77778],
          "73": [0, 0.68889, 0, 0, 0.38889],
          "74": [0.16667, 0.68889, 0, 0, 0.5],
          "75": [0, 0.68889, 0, 0, 0.77778],
          "76": [0, 0.68889, 0, 0, 0.66667],
          "77": [0, 0.68889, 0, 0, 0.94445],
          "78": [0, 0.68889, 0, 0, 0.72222],
          "79": [0.16667, 0.68889, 0, 0, 0.77778],
          "80": [0, 0.68889, 0, 0, 0.61111],
          "81": [0.16667, 0.68889, 0, 0, 0.77778],
          "82": [0, 0.68889, 0, 0, 0.72222],
          "83": [0, 0.68889, 0, 0, 0.55556],
          "84": [0, 0.68889, 0, 0, 0.66667],
          "85": [0, 0.68889, 0, 0, 0.72222],
          "86": [0, 0.68889, 0, 0, 0.72222],
          "87": [0, 0.68889, 0, 0, 1],
          "88": [0, 0.68889, 0, 0, 0.72222],
          "89": [0, 0.68889, 0, 0, 0.72222],
          "90": [0, 0.68889, 0, 0, 0.66667],
          "107": [0, 0.68889, 0, 0, 0.55556],
          "160": [0, 0, 0, 0, 0.25],
          "165": [0, 0.675, 0.025, 0, 0.75],
          "174": [0.15559, 0.69224, 0, 0, 0.94666],
          "240": [0, 0.68889, 0, 0, 0.55556],
          "295": [0, 0.68889, 0, 0, 0.54028],
          "710": [0, 0.825, 0, 0, 2.33334],
          "732": [0, 0.9, 0, 0, 2.33334],
          "770": [0, 0.825, 0, 0, 2.33334],
          "771": [0, 0.9, 0, 0, 2.33334],
          "989": [0.08167, 0.58167, 0, 0, 0.77778],
          "1008": [0, 0.43056, 0.04028, 0, 0.66667],
          "8245": [0, 0.54986, 0, 0, 0.275],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8487": [0, 0.68889, 0, 0, 0.72222],
          "8498": [0, 0.68889, 0, 0, 0.55556],
          "8502": [0, 0.68889, 0, 0, 0.66667],
          "8503": [0, 0.68889, 0, 0, 0.44445],
          "8504": [0, 0.68889, 0, 0, 0.66667],
          "8513": [0, 0.68889, 0, 0, 0.63889],
          "8592": [-0.03598, 0.46402, 0, 0, 0.5],
          "8594": [-0.03598, 0.46402, 0, 0, 0.5],
          "8602": [-0.13313, 0.36687, 0, 0, 1],
          "8603": [-0.13313, 0.36687, 0, 0, 1],
          "8606": [0.01354, 0.52239, 0, 0, 1],
          "8608": [0.01354, 0.52239, 0, 0, 1],
          "8610": [0.01354, 0.52239, 0, 0, 1.11111],
          "8611": [0.01354, 0.52239, 0, 0, 1.11111],
          "8619": [0, 0.54986, 0, 0, 1],
          "8620": [0, 0.54986, 0, 0, 1],
          "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
          "8622": [-0.13313, 0.36687, 0, 0, 1],
          "8624": [0, 0.69224, 0, 0, 0.5],
          "8625": [0, 0.69224, 0, 0, 0.5],
          "8630": [0, 0.43056, 0, 0, 1],
          "8631": [0, 0.43056, 0, 0, 1],
          "8634": [0.08198, 0.58198, 0, 0, 0.77778],
          "8635": [0.08198, 0.58198, 0, 0, 0.77778],
          "8638": [0.19444, 0.69224, 0, 0, 0.41667],
          "8639": [0.19444, 0.69224, 0, 0, 0.41667],
          "8642": [0.19444, 0.69224, 0, 0, 0.41667],
          "8643": [0.19444, 0.69224, 0, 0, 0.41667],
          "8644": [0.1808, 0.675, 0, 0, 1],
          "8646": [0.1808, 0.675, 0, 0, 1],
          "8647": [0.1808, 0.675, 0, 0, 1],
          "8648": [0.19444, 0.69224, 0, 0, 0.83334],
          "8649": [0.1808, 0.675, 0, 0, 1],
          "8650": [0.19444, 0.69224, 0, 0, 0.83334],
          "8651": [0.01354, 0.52239, 0, 0, 1],
          "8652": [0.01354, 0.52239, 0, 0, 1],
          "8653": [-0.13313, 0.36687, 0, 0, 1],
          "8654": [-0.13313, 0.36687, 0, 0, 1],
          "8655": [-0.13313, 0.36687, 0, 0, 1],
          "8666": [0.13667, 0.63667, 0, 0, 1],
          "8667": [0.13667, 0.63667, 0, 0, 1],
          "8669": [-0.13313, 0.37788, 0, 0, 1],
          "8672": [-0.064, 0.437, 0, 0, 1.334],
          "8674": [-0.064, 0.437, 0, 0, 1.334],
          "8705": [0, 0.825, 0, 0, 0.5],
          "8708": [0, 0.68889, 0, 0, 0.55556],
          "8709": [0.08167, 0.58167, 0, 0, 0.77778],
          "8717": [0, 0.43056, 0, 0, 0.42917],
          "8722": [-0.03598, 0.46402, 0, 0, 0.5],
          "8724": [0.08198, 0.69224, 0, 0, 0.77778],
          "8726": [0.08167, 0.58167, 0, 0, 0.77778],
          "8733": [0, 0.69224, 0, 0, 0.77778],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8737": [0, 0.69224, 0, 0, 0.72222],
          "8738": [0.03517, 0.52239, 0, 0, 0.72222],
          "8739": [0.08167, 0.58167, 0, 0, 0.22222],
          "8740": [0.25142, 0.74111, 0, 0, 0.27778],
          "8741": [0.08167, 0.58167, 0, 0, 0.38889],
          "8742": [0.25142, 0.74111, 0, 0, 0.5],
          "8756": [0, 0.69224, 0, 0, 0.66667],
          "8757": [0, 0.69224, 0, 0, 0.66667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
          "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8774": [0.30274, 0.79383, 0, 0, 0.77778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8778": [0.08167, 0.58167, 0, 0, 0.77778],
          "8782": [0.06062, 0.54986, 0, 0, 0.77778],
          "8783": [0.06062, 0.54986, 0, 0, 0.77778],
          "8785": [0.08198, 0.58198, 0, 0, 0.77778],
          "8786": [0.08198, 0.58198, 0, 0, 0.77778],
          "8787": [0.08198, 0.58198, 0, 0, 0.77778],
          "8790": [0, 0.69224, 0, 0, 0.77778],
          "8791": [0.22958, 0.72958, 0, 0, 0.77778],
          "8796": [0.08198, 0.91667, 0, 0, 0.77778],
          "8806": [0.25583, 0.75583, 0, 0, 0.77778],
          "8807": [0.25583, 0.75583, 0, 0, 0.77778],
          "8808": [0.25142, 0.75726, 0, 0, 0.77778],
          "8809": [0.25142, 0.75726, 0, 0, 0.77778],
          "8812": [0.25583, 0.75583, 0, 0, 0.5],
          "8814": [0.20576, 0.70576, 0, 0, 0.77778],
          "8815": [0.20576, 0.70576, 0, 0, 0.77778],
          "8816": [0.30274, 0.79383, 0, 0, 0.77778],
          "8817": [0.30274, 0.79383, 0, 0, 0.77778],
          "8818": [0.22958, 0.72958, 0, 0, 0.77778],
          "8819": [0.22958, 0.72958, 0, 0, 0.77778],
          "8822": [0.1808, 0.675, 0, 0, 0.77778],
          "8823": [0.1808, 0.675, 0, 0, 0.77778],
          "8828": [0.13667, 0.63667, 0, 0, 0.77778],
          "8829": [0.13667, 0.63667, 0, 0, 0.77778],
          "8830": [0.22958, 0.72958, 0, 0, 0.77778],
          "8831": [0.22958, 0.72958, 0, 0, 0.77778],
          "8832": [0.20576, 0.70576, 0, 0, 0.77778],
          "8833": [0.20576, 0.70576, 0, 0, 0.77778],
          "8840": [0.30274, 0.79383, 0, 0, 0.77778],
          "8841": [0.30274, 0.79383, 0, 0, 0.77778],
          "8842": [0.13597, 0.63597, 0, 0, 0.77778],
          "8843": [0.13597, 0.63597, 0, 0, 0.77778],
          "8847": [0.03517, 0.54986, 0, 0, 0.77778],
          "8848": [0.03517, 0.54986, 0, 0, 0.77778],
          "8858": [0.08198, 0.58198, 0, 0, 0.77778],
          "8859": [0.08198, 0.58198, 0, 0, 0.77778],
          "8861": [0.08198, 0.58198, 0, 0, 0.77778],
          "8862": [0, 0.675, 0, 0, 0.77778],
          "8863": [0, 0.675, 0, 0, 0.77778],
          "8864": [0, 0.675, 0, 0, 0.77778],
          "8865": [0, 0.675, 0, 0, 0.77778],
          "8872": [0, 0.69224, 0, 0, 0.61111],
          "8873": [0, 0.69224, 0, 0, 0.72222],
          "8874": [0, 0.69224, 0, 0, 0.88889],
          "8876": [0, 0.68889, 0, 0, 0.61111],
          "8877": [0, 0.68889, 0, 0, 0.61111],
          "8878": [0, 0.68889, 0, 0, 0.72222],
          "8879": [0, 0.68889, 0, 0, 0.72222],
          "8882": [0.03517, 0.54986, 0, 0, 0.77778],
          "8883": [0.03517, 0.54986, 0, 0, 0.77778],
          "8884": [0.13667, 0.63667, 0, 0, 0.77778],
          "8885": [0.13667, 0.63667, 0, 0, 0.77778],
          "8888": [0, 0.54986, 0, 0, 1.11111],
          "8890": [0.19444, 0.43056, 0, 0, 0.55556],
          "8891": [0.19444, 0.69224, 0, 0, 0.61111],
          "8892": [0.19444, 0.69224, 0, 0, 0.61111],
          "8901": [0, 0.54986, 0, 0, 0.27778],
          "8903": [0.08167, 0.58167, 0, 0, 0.77778],
          "8905": [0.08167, 0.58167, 0, 0, 0.77778],
          "8906": [0.08167, 0.58167, 0, 0, 0.77778],
          "8907": [0, 0.69224, 0, 0, 0.77778],
          "8908": [0, 0.69224, 0, 0, 0.77778],
          "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
          "8910": [0, 0.54986, 0, 0, 0.76042],
          "8911": [0, 0.54986, 0, 0, 0.76042],
          "8912": [0.03517, 0.54986, 0, 0, 0.77778],
          "8913": [0.03517, 0.54986, 0, 0, 0.77778],
          "8914": [0, 0.54986, 0, 0, 0.66667],
          "8915": [0, 0.54986, 0, 0, 0.66667],
          "8916": [0, 0.69224, 0, 0, 0.66667],
          "8918": [0.0391, 0.5391, 0, 0, 0.77778],
          "8919": [0.0391, 0.5391, 0, 0, 0.77778],
          "8920": [0.03517, 0.54986, 0, 0, 1.33334],
          "8921": [0.03517, 0.54986, 0, 0, 1.33334],
          "8922": [0.38569, 0.88569, 0, 0, 0.77778],
          "8923": [0.38569, 0.88569, 0, 0, 0.77778],
          "8926": [0.13667, 0.63667, 0, 0, 0.77778],
          "8927": [0.13667, 0.63667, 0, 0, 0.77778],
          "8928": [0.30274, 0.79383, 0, 0, 0.77778],
          "8929": [0.30274, 0.79383, 0, 0, 0.77778],
          "8934": [0.23222, 0.74111, 0, 0, 0.77778],
          "8935": [0.23222, 0.74111, 0, 0, 0.77778],
          "8936": [0.23222, 0.74111, 0, 0, 0.77778],
          "8937": [0.23222, 0.74111, 0, 0, 0.77778],
          "8938": [0.20576, 0.70576, 0, 0, 0.77778],
          "8939": [0.20576, 0.70576, 0, 0, 0.77778],
          "8940": [0.30274, 0.79383, 0, 0, 0.77778],
          "8941": [0.30274, 0.79383, 0, 0, 0.77778],
          "8994": [0.19444, 0.69224, 0, 0, 0.77778],
          "8995": [0.19444, 0.69224, 0, 0, 0.77778],
          "9416": [0.15559, 0.69224, 0, 0, 0.90222],
          "9484": [0, 0.69224, 0, 0, 0.5],
          "9488": [0, 0.69224, 0, 0, 0.5],
          "9492": [0, 0.37788, 0, 0, 0.5],
          "9496": [0, 0.37788, 0, 0, 0.5],
          "9585": [0.19444, 0.68889, 0, 0, 0.88889],
          "9586": [0.19444, 0.74111, 0, 0, 0.88889],
          "9632": [0, 0.675, 0, 0, 0.77778],
          "9633": [0, 0.675, 0, 0, 0.77778],
          "9650": [0, 0.54986, 0, 0, 0.72222],
          "9651": [0, 0.54986, 0, 0, 0.72222],
          "9654": [0.03517, 0.54986, 0, 0, 0.77778],
          "9660": [0, 0.54986, 0, 0, 0.72222],
          "9661": [0, 0.54986, 0, 0, 0.72222],
          "9664": [0.03517, 0.54986, 0, 0, 0.77778],
          "9674": [0.11111, 0.69224, 0, 0, 0.66667],
          "9733": [0.19444, 0.69224, 0, 0, 0.94445],
          "10003": [0, 0.69224, 0, 0, 0.83334],
          "10016": [0, 0.69224, 0, 0, 0.83334],
          "10731": [0.11111, 0.69224, 0, 0, 0.66667],
          "10846": [0.19444, 0.75583, 0, 0, 0.61111],
          "10877": [0.13667, 0.63667, 0, 0, 0.77778],
          "10878": [0.13667, 0.63667, 0, 0, 0.77778],
          "10885": [0.25583, 0.75583, 0, 0, 0.77778],
          "10886": [0.25583, 0.75583, 0, 0, 0.77778],
          "10887": [0.13597, 0.63597, 0, 0, 0.77778],
          "10888": [0.13597, 0.63597, 0, 0, 0.77778],
          "10889": [0.26167, 0.75726, 0, 0, 0.77778],
          "10890": [0.26167, 0.75726, 0, 0, 0.77778],
          "10891": [0.48256, 0.98256, 0, 0, 0.77778],
          "10892": [0.48256, 0.98256, 0, 0, 0.77778],
          "10901": [0.13667, 0.63667, 0, 0, 0.77778],
          "10902": [0.13667, 0.63667, 0, 0, 0.77778],
          "10933": [0.25142, 0.75726, 0, 0, 0.77778],
          "10934": [0.25142, 0.75726, 0, 0, 0.77778],
          "10935": [0.26167, 0.75726, 0, 0, 0.77778],
          "10936": [0.26167, 0.75726, 0, 0, 0.77778],
          "10937": [0.26167, 0.75726, 0, 0, 0.77778],
          "10938": [0.26167, 0.75726, 0, 0, 0.77778],
          "10949": [0.25583, 0.75583, 0, 0, 0.77778],
          "10950": [0.25583, 0.75583, 0, 0, 0.77778],
          "10955": [0.28481, 0.79383, 0, 0, 0.77778],
          "10956": [0.28481, 0.79383, 0, 0, 0.77778],
          "57350": [0.08167, 0.58167, 0, 0, 0.22222],
          "57351": [0.08167, 0.58167, 0, 0, 0.38889],
          "57352": [0.08167, 0.58167, 0, 0, 0.77778],
          "57353": [0, 0.43056, 0.04028, 0, 0.66667],
          "57356": [0.25142, 0.75726, 0, 0, 0.77778],
          "57357": [0.25142, 0.75726, 0, 0, 0.77778],
          "57358": [0.41951, 0.91951, 0, 0, 0.77778],
          "57359": [0.30274, 0.79383, 0, 0, 0.77778],
          "57360": [0.30274, 0.79383, 0, 0, 0.77778],
          "57361": [0.41951, 0.91951, 0, 0, 0.77778],
          "57366": [0.25142, 0.75726, 0, 0, 0.77778],
          "57367": [0.25142, 0.75726, 0, 0, 0.77778],
          "57368": [0.25142, 0.75726, 0, 0, 0.77778],
          "57369": [0.25142, 0.75726, 0, 0, 0.77778],
          "57370": [0.13597, 0.63597, 0, 0, 0.77778],
          "57371": [0.13597, 0.63597, 0, 0, 0.77778]
        },
        "Caligraphic-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68333, 0, 0.19445, 0.79847],
          "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
          "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
          "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
          "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
          "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
          "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
          "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
          "73": [0, 0.68333, 0.07382, 0, 0.54452],
          "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
          "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
          "76": [0, 0.68333, 0, 0.13889, 0.68972],
          "77": [0, 0.68333, 0, 0.13889, 1.2009],
          "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
          "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
          "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
          "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
          "82": [0, 0.68333, 0, 0.08334, 0.8475],
          "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
          "84": [0, 0.68333, 0.25417, 0, 0.54464],
          "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
          "86": [0, 0.68333, 0.08222, 0, 0.61278],
          "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
          "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
          "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
          "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Fraktur-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69141, 0, 0, 0.29574],
          "34": [0, 0.69141, 0, 0, 0.21471],
          "38": [0, 0.69141, 0, 0, 0.73786],
          "39": [0, 0.69141, 0, 0, 0.21201],
          "40": [0.24982, 0.74947, 0, 0, 0.38865],
          "41": [0.24982, 0.74947, 0, 0, 0.38865],
          "42": [0, 0.62119, 0, 0, 0.27764],
          "43": [0.08319, 0.58283, 0, 0, 0.75623],
          "44": [0, 0.10803, 0, 0, 0.27764],
          "45": [0.08319, 0.58283, 0, 0, 0.75623],
          "46": [0, 0.10803, 0, 0, 0.27764],
          "47": [0.24982, 0.74947, 0, 0, 0.50181],
          "48": [0, 0.47534, 0, 0, 0.50181],
          "49": [0, 0.47534, 0, 0, 0.50181],
          "50": [0, 0.47534, 0, 0, 0.50181],
          "51": [0.18906, 0.47534, 0, 0, 0.50181],
          "52": [0.18906, 0.47534, 0, 0, 0.50181],
          "53": [0.18906, 0.47534, 0, 0, 0.50181],
          "54": [0, 0.69141, 0, 0, 0.50181],
          "55": [0.18906, 0.47534, 0, 0, 0.50181],
          "56": [0, 0.69141, 0, 0, 0.50181],
          "57": [0.18906, 0.47534, 0, 0, 0.50181],
          "58": [0, 0.47534, 0, 0, 0.21606],
          "59": [0.12604, 0.47534, 0, 0, 0.21606],
          "61": [-0.13099, 0.36866, 0, 0, 0.75623],
          "63": [0, 0.69141, 0, 0, 0.36245],
          "65": [0, 0.69141, 0, 0, 0.7176],
          "66": [0, 0.69141, 0, 0, 0.88397],
          "67": [0, 0.69141, 0, 0, 0.61254],
          "68": [0, 0.69141, 0, 0, 0.83158],
          "69": [0, 0.69141, 0, 0, 0.66278],
          "70": [0.12604, 0.69141, 0, 0, 0.61119],
          "71": [0, 0.69141, 0, 0, 0.78539],
          "72": [0.06302, 0.69141, 0, 0, 0.7203],
          "73": [0, 0.69141, 0, 0, 0.55448],
          "74": [0.12604, 0.69141, 0, 0, 0.55231],
          "75": [0, 0.69141, 0, 0, 0.66845],
          "76": [0, 0.69141, 0, 0, 0.66602],
          "77": [0, 0.69141, 0, 0, 1.04953],
          "78": [0, 0.69141, 0, 0, 0.83212],
          "79": [0, 0.69141, 0, 0, 0.82699],
          "80": [0.18906, 0.69141, 0, 0, 0.82753],
          "81": [0.03781, 0.69141, 0, 0, 0.82699],
          "82": [0, 0.69141, 0, 0, 0.82807],
          "83": [0, 0.69141, 0, 0, 0.82861],
          "84": [0, 0.69141, 0, 0, 0.66899],
          "85": [0, 0.69141, 0, 0, 0.64576],
          "86": [0, 0.69141, 0, 0, 0.83131],
          "87": [0, 0.69141, 0, 0, 1.04602],
          "88": [0, 0.69141, 0, 0, 0.71922],
          "89": [0.18906, 0.69141, 0, 0, 0.83293],
          "90": [0.12604, 0.69141, 0, 0, 0.60201],
          "91": [0.24982, 0.74947, 0, 0, 0.27764],
          "93": [0.24982, 0.74947, 0, 0, 0.27764],
          "94": [0, 0.69141, 0, 0, 0.49965],
          "97": [0, 0.47534, 0, 0, 0.50046],
          "98": [0, 0.69141, 0, 0, 0.51315],
          "99": [0, 0.47534, 0, 0, 0.38946],
          "100": [0, 0.62119, 0, 0, 0.49857],
          "101": [0, 0.47534, 0, 0, 0.40053],
          "102": [0.18906, 0.69141, 0, 0, 0.32626],
          "103": [0.18906, 0.47534, 0, 0, 0.5037],
          "104": [0.18906, 0.69141, 0, 0, 0.52126],
          "105": [0, 0.69141, 0, 0, 0.27899],
          "106": [0, 0.69141, 0, 0, 0.28088],
          "107": [0, 0.69141, 0, 0, 0.38946],
          "108": [0, 0.69141, 0, 0, 0.27953],
          "109": [0, 0.47534, 0, 0, 0.76676],
          "110": [0, 0.47534, 0, 0, 0.52666],
          "111": [0, 0.47534, 0, 0, 0.48885],
          "112": [0.18906, 0.52396, 0, 0, 0.50046],
          "113": [0.18906, 0.47534, 0, 0, 0.48912],
          "114": [0, 0.47534, 0, 0, 0.38919],
          "115": [0, 0.47534, 0, 0, 0.44266],
          "116": [0, 0.62119, 0, 0, 0.33301],
          "117": [0, 0.47534, 0, 0, 0.5172],
          "118": [0, 0.52396, 0, 0, 0.5118],
          "119": [0, 0.52396, 0, 0, 0.77351],
          "120": [0.18906, 0.47534, 0, 0, 0.38865],
          "121": [0.18906, 0.47534, 0, 0, 0.49884],
          "122": [0.18906, 0.47534, 0, 0, 0.39054],
          "160": [0, 0, 0, 0, 0.25],
          "8216": [0, 0.69141, 0, 0, 0.21471],
          "8217": [0, 0.69141, 0, 0, 0.21471],
          "58112": [0, 0.62119, 0, 0, 0.49749],
          "58113": [0, 0.62119, 0, 0, 0.4983],
          "58114": [0.18906, 0.69141, 0, 0, 0.33328],
          "58115": [0.18906, 0.69141, 0, 0, 0.32923],
          "58116": [0.18906, 0.47534, 0, 0, 0.50343],
          "58117": [0, 0.69141, 0, 0, 0.33301],
          "58118": [0, 0.62119, 0, 0, 0.33409],
          "58119": [0, 0.47534, 0, 0, 0.50073]
        },
        "Main-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.35],
          "34": [0, 0.69444, 0, 0, 0.60278],
          "35": [0.19444, 0.69444, 0, 0, 0.95833],
          "36": [0.05556, 0.75, 0, 0, 0.575],
          "37": [0.05556, 0.75, 0, 0, 0.95833],
          "38": [0, 0.69444, 0, 0, 0.89444],
          "39": [0, 0.69444, 0, 0, 0.31944],
          "40": [0.25, 0.75, 0, 0, 0.44722],
          "41": [0.25, 0.75, 0, 0, 0.44722],
          "42": [0, 0.75, 0, 0, 0.575],
          "43": [0.13333, 0.63333, 0, 0, 0.89444],
          "44": [0.19444, 0.15556, 0, 0, 0.31944],
          "45": [0, 0.44444, 0, 0, 0.38333],
          "46": [0, 0.15556, 0, 0, 0.31944],
          "47": [0.25, 0.75, 0, 0, 0.575],
          "48": [0, 0.64444, 0, 0, 0.575],
          "49": [0, 0.64444, 0, 0, 0.575],
          "50": [0, 0.64444, 0, 0, 0.575],
          "51": [0, 0.64444, 0, 0, 0.575],
          "52": [0, 0.64444, 0, 0, 0.575],
          "53": [0, 0.64444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0, 0.64444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0, 0.64444, 0, 0, 0.575],
          "58": [0, 0.44444, 0, 0, 0.31944],
          "59": [0.19444, 0.44444, 0, 0, 0.31944],
          "60": [0.08556, 0.58556, 0, 0, 0.89444],
          "61": [-0.10889, 0.39111, 0, 0, 0.89444],
          "62": [0.08556, 0.58556, 0, 0, 0.89444],
          "63": [0, 0.69444, 0, 0, 0.54305],
          "64": [0, 0.69444, 0, 0, 0.89444],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0, 0, 0.81805],
          "67": [0, 0.68611, 0, 0, 0.83055],
          "68": [0, 0.68611, 0, 0, 0.88194],
          "69": [0, 0.68611, 0, 0, 0.75555],
          "70": [0, 0.68611, 0, 0, 0.72361],
          "71": [0, 0.68611, 0, 0, 0.90416],
          "72": [0, 0.68611, 0, 0, 0.9],
          "73": [0, 0.68611, 0, 0, 0.43611],
          "74": [0, 0.68611, 0, 0, 0.59444],
          "75": [0, 0.68611, 0, 0, 0.90138],
          "76": [0, 0.68611, 0, 0, 0.69166],
          "77": [0, 0.68611, 0, 0, 1.09166],
          "78": [0, 0.68611, 0, 0, 0.9],
          "79": [0, 0.68611, 0, 0, 0.86388],
          "80": [0, 0.68611, 0, 0, 0.78611],
          "81": [0.19444, 0.68611, 0, 0, 0.86388],
          "82": [0, 0.68611, 0, 0, 0.8625],
          "83": [0, 0.68611, 0, 0, 0.63889],
          "84": [0, 0.68611, 0, 0, 0.8],
          "85": [0, 0.68611, 0, 0, 0.88472],
          "86": [0, 0.68611, 0.01597, 0, 0.86944],
          "87": [0, 0.68611, 0.01597, 0, 1.18888],
          "88": [0, 0.68611, 0, 0, 0.86944],
          "89": [0, 0.68611, 0.02875, 0, 0.86944],
          "90": [0, 0.68611, 0, 0, 0.70277],
          "91": [0.25, 0.75, 0, 0, 0.31944],
          "92": [0.25, 0.75, 0, 0, 0.575],
          "93": [0.25, 0.75, 0, 0, 0.31944],
          "94": [0, 0.69444, 0, 0, 0.575],
          "95": [0.31, 0.13444, 0.03194, 0, 0.575],
          "97": [0, 0.44444, 0, 0, 0.55902],
          "98": [0, 0.69444, 0, 0, 0.63889],
          "99": [0, 0.44444, 0, 0, 0.51111],
          "100": [0, 0.69444, 0, 0, 0.63889],
          "101": [0, 0.44444, 0, 0, 0.52708],
          "102": [0, 0.69444, 0.10903, 0, 0.35139],
          "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
          "104": [0, 0.69444, 0, 0, 0.63889],
          "105": [0, 0.69444, 0, 0, 0.31944],
          "106": [0.19444, 0.69444, 0, 0, 0.35139],
          "107": [0, 0.69444, 0, 0, 0.60694],
          "108": [0, 0.69444, 0, 0, 0.31944],
          "109": [0, 0.44444, 0, 0, 0.95833],
          "110": [0, 0.44444, 0, 0, 0.63889],
          "111": [0, 0.44444, 0, 0, 0.575],
          "112": [0.19444, 0.44444, 0, 0, 0.63889],
          "113": [0.19444, 0.44444, 0, 0, 0.60694],
          "114": [0, 0.44444, 0, 0, 0.47361],
          "115": [0, 0.44444, 0, 0, 0.45361],
          "116": [0, 0.63492, 0, 0, 0.44722],
          "117": [0, 0.44444, 0, 0, 0.63889],
          "118": [0, 0.44444, 0.01597, 0, 0.60694],
          "119": [0, 0.44444, 0.01597, 0, 0.83055],
          "120": [0, 0.44444, 0, 0, 0.60694],
          "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
          "122": [0, 0.44444, 0, 0, 0.51111],
          "123": [0.25, 0.75, 0, 0, 0.575],
          "124": [0.25, 0.75, 0, 0, 0.31944],
          "125": [0.25, 0.75, 0, 0, 0.575],
          "126": [0.35, 0.34444, 0, 0, 0.575],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.86853],
          "168": [0, 0.69444, 0, 0, 0.575],
          "172": [0, 0.44444, 0, 0, 0.76666],
          "176": [0, 0.69444, 0, 0, 0.86944],
          "177": [0.13333, 0.63333, 0, 0, 0.89444],
          "184": [0.17014, 0, 0, 0, 0.51111],
          "198": [0, 0.68611, 0, 0, 1.04166],
          "215": [0.13333, 0.63333, 0, 0, 0.89444],
          "216": [0.04861, 0.73472, 0, 0, 0.89444],
          "223": [0, 0.69444, 0, 0, 0.59722],
          "230": [0, 0.44444, 0, 0, 0.83055],
          "247": [0.13333, 0.63333, 0, 0, 0.89444],
          "248": [0.09722, 0.54167, 0, 0, 0.575],
          "305": [0, 0.44444, 0, 0, 0.31944],
          "338": [0, 0.68611, 0, 0, 1.16944],
          "339": [0, 0.44444, 0, 0, 0.89444],
          "567": [0.19444, 0.44444, 0, 0, 0.35139],
          "710": [0, 0.69444, 0, 0, 0.575],
          "711": [0, 0.63194, 0, 0, 0.575],
          "713": [0, 0.59611, 0, 0, 0.575],
          "714": [0, 0.69444, 0, 0, 0.575],
          "715": [0, 0.69444, 0, 0, 0.575],
          "728": [0, 0.69444, 0, 0, 0.575],
          "729": [0, 0.69444, 0, 0, 0.31944],
          "730": [0, 0.69444, 0, 0, 0.86944],
          "732": [0, 0.69444, 0, 0, 0.575],
          "733": [0, 0.69444, 0, 0, 0.575],
          "915": [0, 0.68611, 0, 0, 0.69166],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0, 0, 0.89444],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0, 0, 0.76666],
          "928": [0, 0.68611, 0, 0, 0.9],
          "931": [0, 0.68611, 0, 0, 0.83055],
          "933": [0, 0.68611, 0, 0, 0.89444],
          "934": [0, 0.68611, 0, 0, 0.83055],
          "936": [0, 0.68611, 0, 0, 0.89444],
          "937": [0, 0.68611, 0, 0, 0.83055],
          "8211": [0, 0.44444, 0.03194, 0, 0.575],
          "8212": [0, 0.44444, 0.03194, 0, 1.14999],
          "8216": [0, 0.69444, 0, 0, 0.31944],
          "8217": [0, 0.69444, 0, 0, 0.31944],
          "8220": [0, 0.69444, 0, 0, 0.60278],
          "8221": [0, 0.69444, 0, 0, 0.60278],
          "8224": [0.19444, 0.69444, 0, 0, 0.51111],
          "8225": [0.19444, 0.69444, 0, 0, 0.51111],
          "8242": [0, 0.55556, 0, 0, 0.34444],
          "8407": [0, 0.72444, 0.15486, 0, 0.575],
          "8463": [0, 0.69444, 0, 0, 0.66759],
          "8465": [0, 0.69444, 0, 0, 0.83055],
          "8467": [0, 0.69444, 0, 0, 0.47361],
          "8472": [0.19444, 0.44444, 0, 0, 0.74027],
          "8476": [0, 0.69444, 0, 0, 0.83055],
          "8501": [0, 0.69444, 0, 0, 0.70277],
          "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8593": [0.19444, 0.69444, 0, 0, 0.575],
          "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8595": [0.19444, 0.69444, 0, 0, 0.575],
          "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8597": [0.25, 0.75, 0, 0, 0.575],
          "8598": [0.19444, 0.69444, 0, 0, 1.14999],
          "8599": [0.19444, 0.69444, 0, 0, 1.14999],
          "8600": [0.19444, 0.69444, 0, 0, 1.14999],
          "8601": [0.19444, 0.69444, 0, 0, 1.14999],
          "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8657": [0.19444, 0.69444, 0, 0, 0.70277],
          "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8659": [0.19444, 0.69444, 0, 0, 0.70277],
          "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8661": [0.25, 0.75, 0, 0, 0.70277],
          "8704": [0, 0.69444, 0, 0, 0.63889],
          "8706": [0, 0.69444, 0.06389, 0, 0.62847],
          "8707": [0, 0.69444, 0, 0, 0.63889],
          "8709": [0.05556, 0.75, 0, 0, 0.575],
          "8711": [0, 0.68611, 0, 0, 0.95833],
          "8712": [0.08556, 0.58556, 0, 0, 0.76666],
          "8715": [0.08556, 0.58556, 0, 0, 0.76666],
          "8722": [0.13333, 0.63333, 0, 0, 0.89444],
          "8723": [0.13333, 0.63333, 0, 0, 0.89444],
          "8725": [0.25, 0.75, 0, 0, 0.575],
          "8726": [0.25, 0.75, 0, 0, 0.575],
          "8727": [-0.02778, 0.47222, 0, 0, 0.575],
          "8728": [-0.02639, 0.47361, 0, 0, 0.575],
          "8729": [-0.02639, 0.47361, 0, 0, 0.575],
          "8730": [0.18, 0.82, 0, 0, 0.95833],
          "8733": [0, 0.44444, 0, 0, 0.89444],
          "8734": [0, 0.44444, 0, 0, 1.14999],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.31944],
          "8741": [0.25, 0.75, 0, 0, 0.575],
          "8743": [0, 0.55556, 0, 0, 0.76666],
          "8744": [0, 0.55556, 0, 0, 0.76666],
          "8745": [0, 0.55556, 0, 0, 0.76666],
          "8746": [0, 0.55556, 0, 0, 0.76666],
          "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
          "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
          "8768": [0.19444, 0.69444, 0, 0, 0.31944],
          "8771": [222e-5, 0.50222, 0, 0, 0.89444],
          "8773": [0.027, 0.638, 0, 0, 0.894],
          "8776": [0.02444, 0.52444, 0, 0, 0.89444],
          "8781": [222e-5, 0.50222, 0, 0, 0.89444],
          "8801": [222e-5, 0.50222, 0, 0, 0.89444],
          "8804": [0.19667, 0.69667, 0, 0, 0.89444],
          "8805": [0.19667, 0.69667, 0, 0, 0.89444],
          "8810": [0.08556, 0.58556, 0, 0, 1.14999],
          "8811": [0.08556, 0.58556, 0, 0, 1.14999],
          "8826": [0.08556, 0.58556, 0, 0, 0.89444],
          "8827": [0.08556, 0.58556, 0, 0, 0.89444],
          "8834": [0.08556, 0.58556, 0, 0, 0.89444],
          "8835": [0.08556, 0.58556, 0, 0, 0.89444],
          "8838": [0.19667, 0.69667, 0, 0, 0.89444],
          "8839": [0.19667, 0.69667, 0, 0, 0.89444],
          "8846": [0, 0.55556, 0, 0, 0.76666],
          "8849": [0.19667, 0.69667, 0, 0, 0.89444],
          "8850": [0.19667, 0.69667, 0, 0, 0.89444],
          "8851": [0, 0.55556, 0, 0, 0.76666],
          "8852": [0, 0.55556, 0, 0, 0.76666],
          "8853": [0.13333, 0.63333, 0, 0, 0.89444],
          "8854": [0.13333, 0.63333, 0, 0, 0.89444],
          "8855": [0.13333, 0.63333, 0, 0, 0.89444],
          "8856": [0.13333, 0.63333, 0, 0, 0.89444],
          "8857": [0.13333, 0.63333, 0, 0, 0.89444],
          "8866": [0, 0.69444, 0, 0, 0.70277],
          "8867": [0, 0.69444, 0, 0, 0.70277],
          "8868": [0, 0.69444, 0, 0, 0.89444],
          "8869": [0, 0.69444, 0, 0, 0.89444],
          "8900": [-0.02639, 0.47361, 0, 0, 0.575],
          "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
          "8902": [-0.02778, 0.47222, 0, 0, 0.575],
          "8968": [0.25, 0.75, 0, 0, 0.51111],
          "8969": [0.25, 0.75, 0, 0, 0.51111],
          "8970": [0.25, 0.75, 0, 0, 0.51111],
          "8971": [0.25, 0.75, 0, 0, 0.51111],
          "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
          "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
          "9651": [0.19444, 0.69444, 0, 0, 1.02222],
          "9657": [-0.02778, 0.47222, 0, 0, 0.575],
          "9661": [0.19444, 0.69444, 0, 0, 1.02222],
          "9667": [-0.02778, 0.47222, 0, 0, 0.575],
          "9711": [0.19444, 0.69444, 0, 0, 1.14999],
          "9824": [0.12963, 0.69444, 0, 0, 0.89444],
          "9825": [0.12963, 0.69444, 0, 0, 0.89444],
          "9826": [0.12963, 0.69444, 0, 0, 0.89444],
          "9827": [0.12963, 0.69444, 0, 0, 0.89444],
          "9837": [0, 0.75, 0, 0, 0.44722],
          "9838": [0.19444, 0.69444, 0, 0, 0.44722],
          "9839": [0.19444, 0.69444, 0, 0, 0.44722],
          "10216": [0.25, 0.75, 0, 0, 0.44722],
          "10217": [0.25, 0.75, 0, 0, 0.44722],
          "10815": [0, 0.68611, 0, 0, 0.9],
          "10927": [0.19667, 0.69667, 0, 0, 0.89444],
          "10928": [0.19667, 0.69667, 0, 0, 0.89444],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Main-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.11417, 0, 0.38611],
          "34": [0, 0.69444, 0.07939, 0, 0.62055],
          "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
          "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
          "38": [0, 0.69444, 0.08528, 0, 0.88555],
          "39": [0, 0.69444, 0.12945, 0, 0.35555],
          "40": [0.25, 0.75, 0.15806, 0, 0.47333],
          "41": [0.25, 0.75, 0.03306, 0, 0.47333],
          "42": [0, 0.75, 0.14333, 0, 0.59111],
          "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
          "44": [0.19444, 0.14722, 0, 0, 0.35555],
          "45": [0, 0.44444, 0.02611, 0, 0.41444],
          "46": [0, 0.14722, 0, 0, 0.35555],
          "47": [0.25, 0.75, 0.15806, 0, 0.59111],
          "48": [0, 0.64444, 0.13167, 0, 0.59111],
          "49": [0, 0.64444, 0.13167, 0, 0.59111],
          "50": [0, 0.64444, 0.13167, 0, 0.59111],
          "51": [0, 0.64444, 0.13167, 0, 0.59111],
          "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "53": [0, 0.64444, 0.13167, 0, 0.59111],
          "54": [0, 0.64444, 0.13167, 0, 0.59111],
          "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "56": [0, 0.64444, 0.13167, 0, 0.59111],
          "57": [0, 0.64444, 0.13167, 0, 0.59111],
          "58": [0, 0.44444, 0.06695, 0, 0.35555],
          "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
          "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
          "63": [0, 0.69444, 0.11472, 0, 0.59111],
          "64": [0, 0.69444, 0.09208, 0, 0.88555],
          "65": [0, 0.68611, 0, 0, 0.86555],
          "66": [0, 0.68611, 0.0992, 0, 0.81666],
          "67": [0, 0.68611, 0.14208, 0, 0.82666],
          "68": [0, 0.68611, 0.09062, 0, 0.87555],
          "69": [0, 0.68611, 0.11431, 0, 0.75666],
          "70": [0, 0.68611, 0.12903, 0, 0.72722],
          "71": [0, 0.68611, 0.07347, 0, 0.89527],
          "72": [0, 0.68611, 0.17208, 0, 0.8961],
          "73": [0, 0.68611, 0.15681, 0, 0.47166],
          "74": [0, 0.68611, 0.145, 0, 0.61055],
          "75": [0, 0.68611, 0.14208, 0, 0.89499],
          "76": [0, 0.68611, 0, 0, 0.69777],
          "77": [0, 0.68611, 0.17208, 0, 1.07277],
          "78": [0, 0.68611, 0.17208, 0, 0.8961],
          "79": [0, 0.68611, 0.09062, 0, 0.85499],
          "80": [0, 0.68611, 0.0992, 0, 0.78721],
          "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
          "82": [0, 0.68611, 0.02559, 0, 0.85944],
          "83": [0, 0.68611, 0.11264, 0, 0.64999],
          "84": [0, 0.68611, 0.12903, 0, 0.7961],
          "85": [0, 0.68611, 0.17208, 0, 0.88083],
          "86": [0, 0.68611, 0.18625, 0, 0.86555],
          "87": [0, 0.68611, 0.18625, 0, 1.15999],
          "88": [0, 0.68611, 0.15681, 0, 0.86555],
          "89": [0, 0.68611, 0.19803, 0, 0.86555],
          "90": [0, 0.68611, 0.14208, 0, 0.70888],
          "91": [0.25, 0.75, 0.1875, 0, 0.35611],
          "93": [0.25, 0.75, 0.09972, 0, 0.35611],
          "94": [0, 0.69444, 0.06709, 0, 0.59111],
          "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
          "97": [0, 0.44444, 0.09426, 0, 0.59111],
          "98": [0, 0.69444, 0.07861, 0, 0.53222],
          "99": [0, 0.44444, 0.05222, 0, 0.53222],
          "100": [0, 0.69444, 0.10861, 0, 0.59111],
          "101": [0, 0.44444, 0.085, 0, 0.53222],
          "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
          "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "104": [0, 0.69444, 0.09426, 0, 0.59111],
          "105": [0, 0.69326, 0.11387, 0, 0.35555],
          "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
          "107": [0, 0.69444, 0.11111, 0, 0.53222],
          "108": [0, 0.69444, 0.10861, 0, 0.29666],
          "109": [0, 0.44444, 0.09426, 0, 0.94444],
          "110": [0, 0.44444, 0.09426, 0, 0.64999],
          "111": [0, 0.44444, 0.07861, 0, 0.59111],
          "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
          "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "114": [0, 0.44444, 0.11111, 0, 0.50167],
          "115": [0, 0.44444, 0.08167, 0, 0.48694],
          "116": [0, 0.63492, 0.09639, 0, 0.385],
          "117": [0, 0.44444, 0.09426, 0, 0.62055],
          "118": [0, 0.44444, 0.11111, 0, 0.53222],
          "119": [0, 0.44444, 0.11111, 0, 0.76777],
          "120": [0, 0.44444, 0.12583, 0, 0.56055],
          "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
          "122": [0, 0.44444, 0.13889, 0, 0.49055],
          "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0.11473, 0, 0.59111],
          "176": [0, 0.69444, 0, 0, 0.94888],
          "184": [0.17014, 0, 0, 0, 0.53222],
          "198": [0, 0.68611, 0.11431, 0, 1.02277],
          "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
          "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
          "230": [0, 0.44444, 0.085, 0, 0.82666],
          "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
          "305": [0, 0.44444, 0.09426, 0, 0.35555],
          "338": [0, 0.68611, 0.11431, 0, 1.14054],
          "339": [0, 0.44444, 0.085, 0, 0.82666],
          "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
          "710": [0, 0.69444, 0.06709, 0, 0.59111],
          "711": [0, 0.63194, 0.08271, 0, 0.59111],
          "713": [0, 0.59444, 0.10444, 0, 0.59111],
          "714": [0, 0.69444, 0.08528, 0, 0.59111],
          "715": [0, 0.69444, 0, 0, 0.59111],
          "728": [0, 0.69444, 0.10333, 0, 0.59111],
          "729": [0, 0.69444, 0.12945, 0, 0.35555],
          "730": [0, 0.69444, 0, 0, 0.94888],
          "732": [0, 0.69444, 0.11472, 0, 0.59111],
          "733": [0, 0.69444, 0.11472, 0, 0.59111],
          "915": [0, 0.68611, 0.12903, 0, 0.69777],
          "916": [0, 0.68611, 0, 0, 0.94444],
          "920": [0, 0.68611, 0.09062, 0, 0.88555],
          "923": [0, 0.68611, 0, 0, 0.80666],
          "926": [0, 0.68611, 0.15092, 0, 0.76777],
          "928": [0, 0.68611, 0.17208, 0, 0.8961],
          "931": [0, 0.68611, 0.11431, 0, 0.82666],
          "933": [0, 0.68611, 0.10778, 0, 0.88555],
          "934": [0, 0.68611, 0.05632, 0, 0.82666],
          "936": [0, 0.68611, 0.10778, 0, 0.88555],
          "937": [0, 0.68611, 0.0992, 0, 0.82666],
          "8211": [0, 0.44444, 0.09811, 0, 0.59111],
          "8212": [0, 0.44444, 0.09811, 0, 1.18221],
          "8216": [0, 0.69444, 0.12945, 0, 0.35555],
          "8217": [0, 0.69444, 0.12945, 0, 0.35555],
          "8220": [0, 0.69444, 0.16772, 0, 0.62055],
          "8221": [0, 0.69444, 0.07939, 0, 0.62055]
        },
        "Main-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.12417, 0, 0.30667],
          "34": [0, 0.69444, 0.06961, 0, 0.51444],
          "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
          "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
          "38": [0, 0.69444, 0.09694, 0, 0.76666],
          "39": [0, 0.69444, 0.12417, 0, 0.30667],
          "40": [0.25, 0.75, 0.16194, 0, 0.40889],
          "41": [0.25, 0.75, 0.03694, 0, 0.40889],
          "42": [0, 0.75, 0.14917, 0, 0.51111],
          "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
          "44": [0.19444, 0.10556, 0, 0, 0.30667],
          "45": [0, 0.43056, 0.02826, 0, 0.35778],
          "46": [0, 0.10556, 0, 0, 0.30667],
          "47": [0.25, 0.75, 0.16194, 0, 0.51111],
          "48": [0, 0.64444, 0.13556, 0, 0.51111],
          "49": [0, 0.64444, 0.13556, 0, 0.51111],
          "50": [0, 0.64444, 0.13556, 0, 0.51111],
          "51": [0, 0.64444, 0.13556, 0, 0.51111],
          "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "53": [0, 0.64444, 0.13556, 0, 0.51111],
          "54": [0, 0.64444, 0.13556, 0, 0.51111],
          "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "56": [0, 0.64444, 0.13556, 0, 0.51111],
          "57": [0, 0.64444, 0.13556, 0, 0.51111],
          "58": [0, 0.43056, 0.0582, 0, 0.30667],
          "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
          "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
          "63": [0, 0.69444, 0.1225, 0, 0.51111],
          "64": [0, 0.69444, 0.09597, 0, 0.76666],
          "65": [0, 0.68333, 0, 0, 0.74333],
          "66": [0, 0.68333, 0.10257, 0, 0.70389],
          "67": [0, 0.68333, 0.14528, 0, 0.71555],
          "68": [0, 0.68333, 0.09403, 0, 0.755],
          "69": [0, 0.68333, 0.12028, 0, 0.67833],
          "70": [0, 0.68333, 0.13305, 0, 0.65277],
          "71": [0, 0.68333, 0.08722, 0, 0.77361],
          "72": [0, 0.68333, 0.16389, 0, 0.74333],
          "73": [0, 0.68333, 0.15806, 0, 0.38555],
          "74": [0, 0.68333, 0.14028, 0, 0.525],
          "75": [0, 0.68333, 0.14528, 0, 0.76888],
          "76": [0, 0.68333, 0, 0, 0.62722],
          "77": [0, 0.68333, 0.16389, 0, 0.89666],
          "78": [0, 0.68333, 0.16389, 0, 0.74333],
          "79": [0, 0.68333, 0.09403, 0, 0.76666],
          "80": [0, 0.68333, 0.10257, 0, 0.67833],
          "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
          "82": [0, 0.68333, 0.03868, 0, 0.72944],
          "83": [0, 0.68333, 0.11972, 0, 0.56222],
          "84": [0, 0.68333, 0.13305, 0, 0.71555],
          "85": [0, 0.68333, 0.16389, 0, 0.74333],
          "86": [0, 0.68333, 0.18361, 0, 0.74333],
          "87": [0, 0.68333, 0.18361, 0, 0.99888],
          "88": [0, 0.68333, 0.15806, 0, 0.74333],
          "89": [0, 0.68333, 0.19383, 0, 0.74333],
          "90": [0, 0.68333, 0.14528, 0, 0.61333],
          "91": [0.25, 0.75, 0.1875, 0, 0.30667],
          "93": [0.25, 0.75, 0.10528, 0, 0.30667],
          "94": [0, 0.69444, 0.06646, 0, 0.51111],
          "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
          "97": [0, 0.43056, 0.07671, 0, 0.51111],
          "98": [0, 0.69444, 0.06312, 0, 0.46],
          "99": [0, 0.43056, 0.05653, 0, 0.46],
          "100": [0, 0.69444, 0.10333, 0, 0.51111],
          "101": [0, 0.43056, 0.07514, 0, 0.46],
          "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
          "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "104": [0, 0.69444, 0.07671, 0, 0.51111],
          "105": [0, 0.65536, 0.1019, 0, 0.30667],
          "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
          "107": [0, 0.69444, 0.10764, 0, 0.46],
          "108": [0, 0.69444, 0.10333, 0, 0.25555],
          "109": [0, 0.43056, 0.07671, 0, 0.81777],
          "110": [0, 0.43056, 0.07671, 0, 0.56222],
          "111": [0, 0.43056, 0.06312, 0, 0.51111],
          "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
          "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "114": [0, 0.43056, 0.10764, 0, 0.42166],
          "115": [0, 0.43056, 0.08208, 0, 0.40889],
          "116": [0, 0.61508, 0.09486, 0, 0.33222],
          "117": [0, 0.43056, 0.07671, 0, 0.53666],
          "118": [0, 0.43056, 0.10764, 0, 0.46],
          "119": [0, 0.43056, 0.10764, 0, 0.66444],
          "120": [0, 0.43056, 0.12042, 0, 0.46389],
          "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
          "122": [0, 0.43056, 0.12292, 0, 0.40889],
          "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.66786, 0.10474, 0, 0.51111],
          "176": [0, 0.69444, 0, 0, 0.83129],
          "184": [0.17014, 0, 0, 0, 0.46],
          "198": [0, 0.68333, 0.12028, 0, 0.88277],
          "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
          "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
          "230": [0, 0.43056, 0.07514, 0, 0.71555],
          "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
          "338": [0, 0.68333, 0.12028, 0, 0.98499],
          "339": [0, 0.43056, 0.07514, 0, 0.71555],
          "710": [0, 0.69444, 0.06646, 0, 0.51111],
          "711": [0, 0.62847, 0.08295, 0, 0.51111],
          "713": [0, 0.56167, 0.10333, 0, 0.51111],
          "714": [0, 0.69444, 0.09694, 0, 0.51111],
          "715": [0, 0.69444, 0, 0, 0.51111],
          "728": [0, 0.69444, 0.10806, 0, 0.51111],
          "729": [0, 0.66786, 0.11752, 0, 0.30667],
          "730": [0, 0.69444, 0, 0, 0.83129],
          "732": [0, 0.66786, 0.11585, 0, 0.51111],
          "733": [0, 0.69444, 0.1225, 0, 0.51111],
          "915": [0, 0.68333, 0.13305, 0, 0.62722],
          "916": [0, 0.68333, 0, 0, 0.81777],
          "920": [0, 0.68333, 0.09403, 0, 0.76666],
          "923": [0, 0.68333, 0, 0, 0.69222],
          "926": [0, 0.68333, 0.15294, 0, 0.66444],
          "928": [0, 0.68333, 0.16389, 0, 0.74333],
          "931": [0, 0.68333, 0.12028, 0, 0.71555],
          "933": [0, 0.68333, 0.11111, 0, 0.76666],
          "934": [0, 0.68333, 0.05986, 0, 0.71555],
          "936": [0, 0.68333, 0.11111, 0, 0.76666],
          "937": [0, 0.68333, 0.10257, 0, 0.71555],
          "8211": [0, 0.43056, 0.09208, 0, 0.51111],
          "8212": [0, 0.43056, 0.09208, 0, 1.02222],
          "8216": [0, 0.69444, 0.12417, 0, 0.30667],
          "8217": [0, 0.69444, 0.12417, 0, 0.30667],
          "8220": [0, 0.69444, 0.1685, 0, 0.51444],
          "8221": [0, 0.69444, 0.06961, 0, 0.51444],
          "8463": [0, 0.68889, 0, 0, 0.54028]
        },
        "Main-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.27778],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.77778],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.19444, 0.10556, 0, 0, 0.27778],
          "45": [0, 0.43056, 0, 0, 0.33333],
          "46": [0, 0.10556, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.64444, 0, 0, 0.5],
          "49": [0, 0.64444, 0, 0, 0.5],
          "50": [0, 0.64444, 0, 0, 0.5],
          "51": [0, 0.64444, 0, 0, 0.5],
          "52": [0, 0.64444, 0, 0, 0.5],
          "53": [0, 0.64444, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0, 0.64444, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0, 0.64444, 0, 0, 0.5],
          "58": [0, 0.43056, 0, 0, 0.27778],
          "59": [0.19444, 0.43056, 0, 0, 0.27778],
          "60": [0.0391, 0.5391, 0, 0, 0.77778],
          "61": [-0.13313, 0.36687, 0, 0, 0.77778],
          "62": [0.0391, 0.5391, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.77778],
          "65": [0, 0.68333, 0, 0, 0.75],
          "66": [0, 0.68333, 0, 0, 0.70834],
          "67": [0, 0.68333, 0, 0, 0.72222],
          "68": [0, 0.68333, 0, 0, 0.76389],
          "69": [0, 0.68333, 0, 0, 0.68056],
          "70": [0, 0.68333, 0, 0, 0.65278],
          "71": [0, 0.68333, 0, 0, 0.78472],
          "72": [0, 0.68333, 0, 0, 0.75],
          "73": [0, 0.68333, 0, 0, 0.36111],
          "74": [0, 0.68333, 0, 0, 0.51389],
          "75": [0, 0.68333, 0, 0, 0.77778],
          "76": [0, 0.68333, 0, 0, 0.625],
          "77": [0, 0.68333, 0, 0, 0.91667],
          "78": [0, 0.68333, 0, 0, 0.75],
          "79": [0, 0.68333, 0, 0, 0.77778],
          "80": [0, 0.68333, 0, 0, 0.68056],
          "81": [0.19444, 0.68333, 0, 0, 0.77778],
          "82": [0, 0.68333, 0, 0, 0.73611],
          "83": [0, 0.68333, 0, 0, 0.55556],
          "84": [0, 0.68333, 0, 0, 0.72222],
          "85": [0, 0.68333, 0, 0, 0.75],
          "86": [0, 0.68333, 0.01389, 0, 0.75],
          "87": [0, 0.68333, 0.01389, 0, 1.02778],
          "88": [0, 0.68333, 0, 0, 0.75],
          "89": [0, 0.68333, 0.025, 0, 0.75],
          "90": [0, 0.68333, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.27778],
          "92": [0.25, 0.75, 0, 0, 0.5],
          "93": [0.25, 0.75, 0, 0, 0.27778],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.31, 0.12056, 0.02778, 0, 0.5],
          "97": [0, 0.43056, 0, 0, 0.5],
          "98": [0, 0.69444, 0, 0, 0.55556],
          "99": [0, 0.43056, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.55556],
          "101": [0, 0.43056, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.07778, 0, 0.30556],
          "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.55556],
          "105": [0, 0.66786, 0, 0, 0.27778],
          "106": [0.19444, 0.66786, 0, 0, 0.30556],
          "107": [0, 0.69444, 0, 0, 0.52778],
          "108": [0, 0.69444, 0, 0, 0.27778],
          "109": [0, 0.43056, 0, 0, 0.83334],
          "110": [0, 0.43056, 0, 0, 0.55556],
          "111": [0, 0.43056, 0, 0, 0.5],
          "112": [0.19444, 0.43056, 0, 0, 0.55556],
          "113": [0.19444, 0.43056, 0, 0, 0.52778],
          "114": [0, 0.43056, 0, 0, 0.39167],
          "115": [0, 0.43056, 0, 0, 0.39445],
          "116": [0, 0.61508, 0, 0, 0.38889],
          "117": [0, 0.43056, 0, 0, 0.55556],
          "118": [0, 0.43056, 0.01389, 0, 0.52778],
          "119": [0, 0.43056, 0.01389, 0, 0.72222],
          "120": [0, 0.43056, 0, 0, 0.52778],
          "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
          "122": [0, 0.43056, 0, 0, 0.44445],
          "123": [0.25, 0.75, 0, 0, 0.5],
          "124": [0.25, 0.75, 0, 0, 0.27778],
          "125": [0.25, 0.75, 0, 0, 0.5],
          "126": [0.35, 0.31786, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.76909],
          "167": [0.19444, 0.69444, 0, 0, 0.44445],
          "168": [0, 0.66786, 0, 0, 0.5],
          "172": [0, 0.43056, 0, 0, 0.66667],
          "176": [0, 0.69444, 0, 0, 0.75],
          "177": [0.08333, 0.58333, 0, 0, 0.77778],
          "182": [0.19444, 0.69444, 0, 0, 0.61111],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "198": [0, 0.68333, 0, 0, 0.90278],
          "215": [0.08333, 0.58333, 0, 0, 0.77778],
          "216": [0.04861, 0.73194, 0, 0, 0.77778],
          "223": [0, 0.69444, 0, 0, 0.5],
          "230": [0, 0.43056, 0, 0, 0.72222],
          "247": [0.08333, 0.58333, 0, 0, 0.77778],
          "248": [0.09722, 0.52778, 0, 0, 0.5],
          "305": [0, 0.43056, 0, 0, 0.27778],
          "338": [0, 0.68333, 0, 0, 1.01389],
          "339": [0, 0.43056, 0, 0, 0.77778],
          "567": [0.19444, 0.43056, 0, 0, 0.30556],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.62847, 0, 0, 0.5],
          "713": [0, 0.56778, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.66786, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.75],
          "732": [0, 0.66786, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.68333, 0, 0, 0.625],
          "916": [0, 0.68333, 0, 0, 0.83334],
          "920": [0, 0.68333, 0, 0, 0.77778],
          "923": [0, 0.68333, 0, 0, 0.69445],
          "926": [0, 0.68333, 0, 0, 0.66667],
          "928": [0, 0.68333, 0, 0, 0.75],
          "931": [0, 0.68333, 0, 0, 0.72222],
          "933": [0, 0.68333, 0, 0, 0.77778],
          "934": [0, 0.68333, 0, 0, 0.72222],
          "936": [0, 0.68333, 0, 0, 0.77778],
          "937": [0, 0.68333, 0, 0, 0.72222],
          "8211": [0, 0.43056, 0.02778, 0, 0.5],
          "8212": [0, 0.43056, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5],
          "8224": [0.19444, 0.69444, 0, 0, 0.44445],
          "8225": [0.19444, 0.69444, 0, 0, 0.44445],
          "8230": [0, 0.123, 0, 0, 1.172],
          "8242": [0, 0.55556, 0, 0, 0.275],
          "8407": [0, 0.71444, 0.15382, 0, 0.5],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8465": [0, 0.69444, 0, 0, 0.72222],
          "8467": [0, 0.69444, 0, 0.11111, 0.41667],
          "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
          "8476": [0, 0.69444, 0, 0, 0.72222],
          "8501": [0, 0.69444, 0, 0, 0.61111],
          "8592": [-0.13313, 0.36687, 0, 0, 1],
          "8593": [0.19444, 0.69444, 0, 0, 0.5],
          "8594": [-0.13313, 0.36687, 0, 0, 1],
          "8595": [0.19444, 0.69444, 0, 0, 0.5],
          "8596": [-0.13313, 0.36687, 0, 0, 1],
          "8597": [0.25, 0.75, 0, 0, 0.5],
          "8598": [0.19444, 0.69444, 0, 0, 1],
          "8599": [0.19444, 0.69444, 0, 0, 1],
          "8600": [0.19444, 0.69444, 0, 0, 1],
          "8601": [0.19444, 0.69444, 0, 0, 1],
          "8614": [0.011, 0.511, 0, 0, 1],
          "8617": [0.011, 0.511, 0, 0, 1.126],
          "8618": [0.011, 0.511, 0, 0, 1.126],
          "8636": [-0.13313, 0.36687, 0, 0, 1],
          "8637": [-0.13313, 0.36687, 0, 0, 1],
          "8640": [-0.13313, 0.36687, 0, 0, 1],
          "8641": [-0.13313, 0.36687, 0, 0, 1],
          "8652": [0.011, 0.671, 0, 0, 1],
          "8656": [-0.13313, 0.36687, 0, 0, 1],
          "8657": [0.19444, 0.69444, 0, 0, 0.61111],
          "8658": [-0.13313, 0.36687, 0, 0, 1],
          "8659": [0.19444, 0.69444, 0, 0, 0.61111],
          "8660": [-0.13313, 0.36687, 0, 0, 1],
          "8661": [0.25, 0.75, 0, 0, 0.61111],
          "8704": [0, 0.69444, 0, 0, 0.55556],
          "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
          "8707": [0, 0.69444, 0, 0, 0.55556],
          "8709": [0.05556, 0.75, 0, 0, 0.5],
          "8711": [0, 0.68333, 0, 0, 0.83334],
          "8712": [0.0391, 0.5391, 0, 0, 0.66667],
          "8715": [0.0391, 0.5391, 0, 0, 0.66667],
          "8722": [0.08333, 0.58333, 0, 0, 0.77778],
          "8723": [0.08333, 0.58333, 0, 0, 0.77778],
          "8725": [0.25, 0.75, 0, 0, 0.5],
          "8726": [0.25, 0.75, 0, 0, 0.5],
          "8727": [-0.03472, 0.46528, 0, 0, 0.5],
          "8728": [-0.05555, 0.44445, 0, 0, 0.5],
          "8729": [-0.05555, 0.44445, 0, 0, 0.5],
          "8730": [0.2, 0.8, 0, 0, 0.83334],
          "8733": [0, 0.43056, 0, 0, 0.77778],
          "8734": [0, 0.43056, 0, 0, 1],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.27778],
          "8741": [0.25, 0.75, 0, 0, 0.5],
          "8743": [0, 0.55556, 0, 0, 0.66667],
          "8744": [0, 0.55556, 0, 0, 0.66667],
          "8745": [0, 0.55556, 0, 0, 0.66667],
          "8746": [0, 0.55556, 0, 0, 0.66667],
          "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8768": [0.19444, 0.69444, 0, 0, 0.27778],
          "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8773": [-0.022, 0.589, 0, 0, 0.778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8784": [-0.133, 0.673, 0, 0, 0.778],
          "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8804": [0.13597, 0.63597, 0, 0, 0.77778],
          "8805": [0.13597, 0.63597, 0, 0, 0.77778],
          "8810": [0.0391, 0.5391, 0, 0, 1],
          "8811": [0.0391, 0.5391, 0, 0, 1],
          "8826": [0.0391, 0.5391, 0, 0, 0.77778],
          "8827": [0.0391, 0.5391, 0, 0, 0.77778],
          "8834": [0.0391, 0.5391, 0, 0, 0.77778],
          "8835": [0.0391, 0.5391, 0, 0, 0.77778],
          "8838": [0.13597, 0.63597, 0, 0, 0.77778],
          "8839": [0.13597, 0.63597, 0, 0, 0.77778],
          "8846": [0, 0.55556, 0, 0, 0.66667],
          "8849": [0.13597, 0.63597, 0, 0, 0.77778],
          "8850": [0.13597, 0.63597, 0, 0, 0.77778],
          "8851": [0, 0.55556, 0, 0, 0.66667],
          "8852": [0, 0.55556, 0, 0, 0.66667],
          "8853": [0.08333, 0.58333, 0, 0, 0.77778],
          "8854": [0.08333, 0.58333, 0, 0, 0.77778],
          "8855": [0.08333, 0.58333, 0, 0, 0.77778],
          "8856": [0.08333, 0.58333, 0, 0, 0.77778],
          "8857": [0.08333, 0.58333, 0, 0, 0.77778],
          "8866": [0, 0.69444, 0, 0, 0.61111],
          "8867": [0, 0.69444, 0, 0, 0.61111],
          "8868": [0, 0.69444, 0, 0, 0.77778],
          "8869": [0, 0.69444, 0, 0, 0.77778],
          "8872": [0.249, 0.75, 0, 0, 0.867],
          "8900": [-0.05555, 0.44445, 0, 0, 0.5],
          "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
          "8902": [-0.03472, 0.46528, 0, 0, 0.5],
          "8904": [5e-3, 0.505, 0, 0, 0.9],
          "8942": [0.03, 0.903, 0, 0, 0.278],
          "8943": [-0.19, 0.313, 0, 0, 1.172],
          "8945": [-0.1, 0.823, 0, 0, 1.282],
          "8968": [0.25, 0.75, 0, 0, 0.44445],
          "8969": [0.25, 0.75, 0, 0, 0.44445],
          "8970": [0.25, 0.75, 0, 0, 0.44445],
          "8971": [0.25, 0.75, 0, 0, 0.44445],
          "8994": [-0.14236, 0.35764, 0, 0, 1],
          "8995": [-0.14236, 0.35764, 0, 0, 1],
          "9136": [0.244, 0.744, 0, 0, 0.412],
          "9137": [0.244, 0.745, 0, 0, 0.412],
          "9651": [0.19444, 0.69444, 0, 0, 0.88889],
          "9657": [-0.03472, 0.46528, 0, 0, 0.5],
          "9661": [0.19444, 0.69444, 0, 0, 0.88889],
          "9667": [-0.03472, 0.46528, 0, 0, 0.5],
          "9711": [0.19444, 0.69444, 0, 0, 1],
          "9824": [0.12963, 0.69444, 0, 0, 0.77778],
          "9825": [0.12963, 0.69444, 0, 0, 0.77778],
          "9826": [0.12963, 0.69444, 0, 0, 0.77778],
          "9827": [0.12963, 0.69444, 0, 0, 0.77778],
          "9837": [0, 0.75, 0, 0, 0.38889],
          "9838": [0.19444, 0.69444, 0, 0, 0.38889],
          "9839": [0.19444, 0.69444, 0, 0, 0.38889],
          "10216": [0.25, 0.75, 0, 0, 0.38889],
          "10217": [0.25, 0.75, 0, 0, 0.38889],
          "10222": [0.244, 0.744, 0, 0, 0.412],
          "10223": [0.244, 0.745, 0, 0, 0.412],
          "10229": [0.011, 0.511, 0, 0, 1.609],
          "10230": [0.011, 0.511, 0, 0, 1.638],
          "10231": [0.011, 0.511, 0, 0, 1.859],
          "10232": [0.024, 0.525, 0, 0, 1.609],
          "10233": [0.024, 0.525, 0, 0, 1.638],
          "10234": [0.024, 0.525, 0, 0, 1.858],
          "10236": [0.011, 0.511, 0, 0, 1.638],
          "10815": [0, 0.68333, 0, 0, 0.75],
          "10927": [0.13597, 0.63597, 0, 0, 0.77778],
          "10928": [0.13597, 0.63597, 0, 0, 0.77778],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Math-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.44444, 0, 0, 0.575],
          "49": [0, 0.44444, 0, 0, 0.575],
          "50": [0, 0.44444, 0, 0, 0.575],
          "51": [0.19444, 0.44444, 0, 0, 0.575],
          "52": [0.19444, 0.44444, 0, 0, 0.575],
          "53": [0.19444, 0.44444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0.19444, 0.44444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0.19444, 0.44444, 0, 0, 0.575],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0.04835, 0, 0.8664],
          "67": [0, 0.68611, 0.06979, 0, 0.81694],
          "68": [0, 0.68611, 0.03194, 0, 0.93812],
          "69": [0, 0.68611, 0.05451, 0, 0.81007],
          "70": [0, 0.68611, 0.15972, 0, 0.68889],
          "71": [0, 0.68611, 0, 0, 0.88673],
          "72": [0, 0.68611, 0.08229, 0, 0.98229],
          "73": [0, 0.68611, 0.07778, 0, 0.51111],
          "74": [0, 0.68611, 0.10069, 0, 0.63125],
          "75": [0, 0.68611, 0.06979, 0, 0.97118],
          "76": [0, 0.68611, 0, 0, 0.75555],
          "77": [0, 0.68611, 0.11424, 0, 1.14201],
          "78": [0, 0.68611, 0.11424, 0, 0.95034],
          "79": [0, 0.68611, 0.03194, 0, 0.83666],
          "80": [0, 0.68611, 0.15972, 0, 0.72309],
          "81": [0.19444, 0.68611, 0, 0, 0.86861],
          "82": [0, 0.68611, 421e-5, 0, 0.87235],
          "83": [0, 0.68611, 0.05382, 0, 0.69271],
          "84": [0, 0.68611, 0.15972, 0, 0.63663],
          "85": [0, 0.68611, 0.11424, 0, 0.80027],
          "86": [0, 0.68611, 0.25555, 0, 0.67778],
          "87": [0, 0.68611, 0.15972, 0, 1.09305],
          "88": [0, 0.68611, 0.07778, 0, 0.94722],
          "89": [0, 0.68611, 0.25555, 0, 0.67458],
          "90": [0, 0.68611, 0.06979, 0, 0.77257],
          "97": [0, 0.44444, 0, 0, 0.63287],
          "98": [0, 0.69444, 0, 0, 0.52083],
          "99": [0, 0.44444, 0, 0, 0.51342],
          "100": [0, 0.69444, 0, 0, 0.60972],
          "101": [0, 0.44444, 0, 0, 0.55361],
          "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
          "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
          "104": [0, 0.69444, 0, 0, 0.66759],
          "105": [0, 0.69326, 0, 0, 0.4048],
          "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
          "107": [0, 0.69444, 0.01852, 0, 0.6037],
          "108": [0, 0.69444, 88e-4, 0, 0.34815],
          "109": [0, 0.44444, 0, 0, 1.0324],
          "110": [0, 0.44444, 0, 0, 0.71296],
          "111": [0, 0.44444, 0, 0, 0.58472],
          "112": [0.19444, 0.44444, 0, 0, 0.60092],
          "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
          "114": [0, 0.44444, 0.03194, 0, 0.5287],
          "115": [0, 0.44444, 0, 0, 0.53125],
          "116": [0, 0.63492, 0, 0, 0.41528],
          "117": [0, 0.44444, 0, 0, 0.68102],
          "118": [0, 0.44444, 0.03704, 0, 0.56666],
          "119": [0, 0.44444, 0.02778, 0, 0.83148],
          "120": [0, 0.44444, 0, 0, 0.65903],
          "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
          "122": [0, 0.44444, 0.04213, 0, 0.55509],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68611, 0.15972, 0, 0.65694],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0.03194, 0, 0.86722],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0.07458, 0, 0.84125],
          "928": [0, 0.68611, 0.08229, 0, 0.98229],
          "931": [0, 0.68611, 0.05451, 0, 0.88507],
          "933": [0, 0.68611, 0.15972, 0, 0.67083],
          "934": [0, 0.68611, 0, 0, 0.76666],
          "936": [0, 0.68611, 0.11653, 0, 0.71402],
          "937": [0, 0.68611, 0.04835, 0, 0.8789],
          "945": [0, 0.44444, 0, 0, 0.76064],
          "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
          "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
          "948": [0, 0.69444, 0.03819, 0, 0.52222],
          "949": [0, 0.44444, 0, 0, 0.52882],
          "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
          "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
          "952": [0, 0.69444, 0.03194, 0, 0.5618],
          "953": [0, 0.44444, 0, 0, 0.41204],
          "954": [0, 0.44444, 0, 0, 0.66759],
          "955": [0, 0.69444, 0, 0, 0.67083],
          "956": [0.19444, 0.44444, 0, 0, 0.70787],
          "957": [0, 0.44444, 0.06898, 0, 0.57685],
          "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
          "959": [0, 0.44444, 0, 0, 0.58472],
          "960": [0, 0.44444, 0.03704, 0, 0.68241],
          "961": [0.19444, 0.44444, 0, 0, 0.6118],
          "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
          "963": [0, 0.44444, 0.03704, 0, 0.68588],
          "964": [0, 0.44444, 0.13472, 0, 0.52083],
          "965": [0, 0.44444, 0.03704, 0, 0.63055],
          "966": [0.19444, 0.44444, 0, 0, 0.74722],
          "967": [0.19444, 0.44444, 0, 0, 0.71805],
          "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
          "969": [0, 0.44444, 0.03704, 0, 0.71782],
          "977": [0, 0.69444, 0, 0, 0.69155],
          "981": [0.19444, 0.69444, 0, 0, 0.7125],
          "982": [0, 0.44444, 0.03194, 0, 0.975],
          "1009": [0.19444, 0.44444, 0, 0, 0.6118],
          "1013": [0, 0.44444, 0, 0, 0.48333],
          "57649": [0, 0.44444, 0, 0, 0.39352],
          "57911": [0.19444, 0.44444, 0, 0, 0.43889]
        },
        "Math-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.43056, 0, 0, 0.5],
          "49": [0, 0.43056, 0, 0, 0.5],
          "50": [0, 0.43056, 0, 0, 0.5],
          "51": [0.19444, 0.43056, 0, 0, 0.5],
          "52": [0.19444, 0.43056, 0, 0, 0.5],
          "53": [0.19444, 0.43056, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0.19444, 0.43056, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0.19444, 0.43056, 0, 0, 0.5],
          "65": [0, 0.68333, 0, 0.13889, 0.75],
          "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
          "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
          "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
          "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
          "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
          "71": [0, 0.68333, 0, 0.08334, 0.78625],
          "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
          "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
          "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
          "76": [0, 0.68333, 0, 0.02778, 0.68056],
          "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
          "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
          "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
          "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
          "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
          "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
          "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
          "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
          "86": [0, 0.68333, 0.22222, 0, 0.58333],
          "87": [0, 0.68333, 0.13889, 0, 0.94445],
          "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
          "89": [0, 0.68333, 0.22222, 0, 0.58056],
          "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
          "97": [0, 0.43056, 0, 0, 0.52859],
          "98": [0, 0.69444, 0, 0, 0.42917],
          "99": [0, 0.43056, 0, 0.05556, 0.43276],
          "100": [0, 0.69444, 0, 0.16667, 0.52049],
          "101": [0, 0.43056, 0, 0.05556, 0.46563],
          "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
          "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
          "104": [0, 0.69444, 0, 0, 0.57616],
          "105": [0, 0.65952, 0, 0, 0.34451],
          "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
          "107": [0, 0.69444, 0.03148, 0, 0.5206],
          "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
          "109": [0, 0.43056, 0, 0, 0.87801],
          "110": [0, 0.43056, 0, 0, 0.60023],
          "111": [0, 0.43056, 0, 0.05556, 0.48472],
          "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
          "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
          "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
          "115": [0, 0.43056, 0, 0.05556, 0.46875],
          "116": [0, 0.61508, 0, 0.08334, 0.36111],
          "117": [0, 0.43056, 0, 0.02778, 0.57246],
          "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
          "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
          "120": [0, 0.43056, 0, 0.02778, 0.57153],
          "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
          "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
          "916": [0, 0.68333, 0, 0.16667, 0.83334],
          "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "923": [0, 0.68333, 0, 0.16667, 0.69445],
          "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
          "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
          "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
          "934": [0, 0.68333, 0, 0.08334, 0.66667],
          "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
          "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
          "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
          "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
          "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
          "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
          "949": [0, 0.43056, 0, 0.08334, 0.46632],
          "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
          "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
          "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
          "953": [0, 0.43056, 0, 0.05556, 0.35394],
          "954": [0, 0.43056, 0, 0, 0.57616],
          "955": [0, 0.69444, 0, 0, 0.58334],
          "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
          "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
          "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
          "959": [0, 0.43056, 0, 0.05556, 0.48472],
          "960": [0, 0.43056, 0.03588, 0, 0.57003],
          "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
          "963": [0, 0.43056, 0.03588, 0, 0.57141],
          "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
          "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
          "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
          "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
          "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
          "969": [0, 0.43056, 0.03588, 0, 0.62245],
          "977": [0, 0.69444, 0, 0.08334, 0.59144],
          "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
          "982": [0, 0.43056, 0.02778, 0, 0.82813],
          "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "1013": [0, 0.43056, 0, 0.05556, 0.4059],
          "57649": [0, 0.43056, 0, 0.02778, 0.32246],
          "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
        },
        "SansSerif-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.36667],
          "34": [0, 0.69444, 0, 0, 0.55834],
          "35": [0.19444, 0.69444, 0, 0, 0.91667],
          "36": [0.05556, 0.75, 0, 0, 0.55],
          "37": [0.05556, 0.75, 0, 0, 1.02912],
          "38": [0, 0.69444, 0, 0, 0.83056],
          "39": [0, 0.69444, 0, 0, 0.30556],
          "40": [0.25, 0.75, 0, 0, 0.42778],
          "41": [0.25, 0.75, 0, 0, 0.42778],
          "42": [0, 0.75, 0, 0, 0.55],
          "43": [0.11667, 0.61667, 0, 0, 0.85556],
          "44": [0.10556, 0.13056, 0, 0, 0.30556],
          "45": [0, 0.45833, 0, 0, 0.36667],
          "46": [0, 0.13056, 0, 0, 0.30556],
          "47": [0.25, 0.75, 0, 0, 0.55],
          "48": [0, 0.69444, 0, 0, 0.55],
          "49": [0, 0.69444, 0, 0, 0.55],
          "50": [0, 0.69444, 0, 0, 0.55],
          "51": [0, 0.69444, 0, 0, 0.55],
          "52": [0, 0.69444, 0, 0, 0.55],
          "53": [0, 0.69444, 0, 0, 0.55],
          "54": [0, 0.69444, 0, 0, 0.55],
          "55": [0, 0.69444, 0, 0, 0.55],
          "56": [0, 0.69444, 0, 0, 0.55],
          "57": [0, 0.69444, 0, 0, 0.55],
          "58": [0, 0.45833, 0, 0, 0.30556],
          "59": [0.10556, 0.45833, 0, 0, 0.30556],
          "61": [-0.09375, 0.40625, 0, 0, 0.85556],
          "63": [0, 0.69444, 0, 0, 0.51945],
          "64": [0, 0.69444, 0, 0, 0.73334],
          "65": [0, 0.69444, 0, 0, 0.73334],
          "66": [0, 0.69444, 0, 0, 0.73334],
          "67": [0, 0.69444, 0, 0, 0.70278],
          "68": [0, 0.69444, 0, 0, 0.79445],
          "69": [0, 0.69444, 0, 0, 0.64167],
          "70": [0, 0.69444, 0, 0, 0.61111],
          "71": [0, 0.69444, 0, 0, 0.73334],
          "72": [0, 0.69444, 0, 0, 0.79445],
          "73": [0, 0.69444, 0, 0, 0.33056],
          "74": [0, 0.69444, 0, 0, 0.51945],
          "75": [0, 0.69444, 0, 0, 0.76389],
          "76": [0, 0.69444, 0, 0, 0.58056],
          "77": [0, 0.69444, 0, 0, 0.97778],
          "78": [0, 0.69444, 0, 0, 0.79445],
          "79": [0, 0.69444, 0, 0, 0.79445],
          "80": [0, 0.69444, 0, 0, 0.70278],
          "81": [0.10556, 0.69444, 0, 0, 0.79445],
          "82": [0, 0.69444, 0, 0, 0.70278],
          "83": [0, 0.69444, 0, 0, 0.61111],
          "84": [0, 0.69444, 0, 0, 0.73334],
          "85": [0, 0.69444, 0, 0, 0.76389],
          "86": [0, 0.69444, 0.01528, 0, 0.73334],
          "87": [0, 0.69444, 0.01528, 0, 1.03889],
          "88": [0, 0.69444, 0, 0, 0.73334],
          "89": [0, 0.69444, 0.0275, 0, 0.73334],
          "90": [0, 0.69444, 0, 0, 0.67223],
          "91": [0.25, 0.75, 0, 0, 0.34306],
          "93": [0.25, 0.75, 0, 0, 0.34306],
          "94": [0, 0.69444, 0, 0, 0.55],
          "95": [0.35, 0.10833, 0.03056, 0, 0.55],
          "97": [0, 0.45833, 0, 0, 0.525],
          "98": [0, 0.69444, 0, 0, 0.56111],
          "99": [0, 0.45833, 0, 0, 0.48889],
          "100": [0, 0.69444, 0, 0, 0.56111],
          "101": [0, 0.45833, 0, 0, 0.51111],
          "102": [0, 0.69444, 0.07639, 0, 0.33611],
          "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
          "104": [0, 0.69444, 0, 0, 0.56111],
          "105": [0, 0.69444, 0, 0, 0.25556],
          "106": [0.19444, 0.69444, 0, 0, 0.28611],
          "107": [0, 0.69444, 0, 0, 0.53056],
          "108": [0, 0.69444, 0, 0, 0.25556],
          "109": [0, 0.45833, 0, 0, 0.86667],
          "110": [0, 0.45833, 0, 0, 0.56111],
          "111": [0, 0.45833, 0, 0, 0.55],
          "112": [0.19444, 0.45833, 0, 0, 0.56111],
          "113": [0.19444, 0.45833, 0, 0, 0.56111],
          "114": [0, 0.45833, 0.01528, 0, 0.37222],
          "115": [0, 0.45833, 0, 0, 0.42167],
          "116": [0, 0.58929, 0, 0, 0.40417],
          "117": [0, 0.45833, 0, 0, 0.56111],
          "118": [0, 0.45833, 0.01528, 0, 0.5],
          "119": [0, 0.45833, 0.01528, 0, 0.74445],
          "120": [0, 0.45833, 0, 0, 0.5],
          "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
          "122": [0, 0.45833, 0, 0, 0.47639],
          "126": [0.35, 0.34444, 0, 0, 0.55],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0, 0, 0.55],
          "176": [0, 0.69444, 0, 0, 0.73334],
          "180": [0, 0.69444, 0, 0, 0.55],
          "184": [0.17014, 0, 0, 0, 0.48889],
          "305": [0, 0.45833, 0, 0, 0.25556],
          "567": [0.19444, 0.45833, 0, 0, 0.28611],
          "710": [0, 0.69444, 0, 0, 0.55],
          "711": [0, 0.63542, 0, 0, 0.55],
          "713": [0, 0.63778, 0, 0, 0.55],
          "728": [0, 0.69444, 0, 0, 0.55],
          "729": [0, 0.69444, 0, 0, 0.30556],
          "730": [0, 0.69444, 0, 0, 0.73334],
          "732": [0, 0.69444, 0, 0, 0.55],
          "733": [0, 0.69444, 0, 0, 0.55],
          "915": [0, 0.69444, 0, 0, 0.58056],
          "916": [0, 0.69444, 0, 0, 0.91667],
          "920": [0, 0.69444, 0, 0, 0.85556],
          "923": [0, 0.69444, 0, 0, 0.67223],
          "926": [0, 0.69444, 0, 0, 0.73334],
          "928": [0, 0.69444, 0, 0, 0.79445],
          "931": [0, 0.69444, 0, 0, 0.79445],
          "933": [0, 0.69444, 0, 0, 0.85556],
          "934": [0, 0.69444, 0, 0, 0.79445],
          "936": [0, 0.69444, 0, 0, 0.85556],
          "937": [0, 0.69444, 0, 0, 0.79445],
          "8211": [0, 0.45833, 0.03056, 0, 0.55],
          "8212": [0, 0.45833, 0.03056, 0, 1.10001],
          "8216": [0, 0.69444, 0, 0, 0.30556],
          "8217": [0, 0.69444, 0, 0, 0.30556],
          "8220": [0, 0.69444, 0, 0, 0.55834],
          "8221": [0, 0.69444, 0, 0, 0.55834]
        },
        "SansSerif-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.05733, 0, 0.31945],
          "34": [0, 0.69444, 316e-5, 0, 0.5],
          "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
          "36": [0.05556, 0.75, 0.11156, 0, 0.5],
          "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
          "38": [0, 0.69444, 0.03058, 0, 0.75834],
          "39": [0, 0.69444, 0.07816, 0, 0.27778],
          "40": [0.25, 0.75, 0.13164, 0, 0.38889],
          "41": [0.25, 0.75, 0.02536, 0, 0.38889],
          "42": [0, 0.75, 0.11775, 0, 0.5],
          "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0.01946, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0.13164, 0, 0.5],
          "48": [0, 0.65556, 0.11156, 0, 0.5],
          "49": [0, 0.65556, 0.11156, 0, 0.5],
          "50": [0, 0.65556, 0.11156, 0, 0.5],
          "51": [0, 0.65556, 0.11156, 0, 0.5],
          "52": [0, 0.65556, 0.11156, 0, 0.5],
          "53": [0, 0.65556, 0.11156, 0, 0.5],
          "54": [0, 0.65556, 0.11156, 0, 0.5],
          "55": [0, 0.65556, 0.11156, 0, 0.5],
          "56": [0, 0.65556, 0.11156, 0, 0.5],
          "57": [0, 0.65556, 0.11156, 0, 0.5],
          "58": [0, 0.44444, 0.02502, 0, 0.27778],
          "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
          "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
          "63": [0, 0.69444, 0.11809, 0, 0.47222],
          "64": [0, 0.69444, 0.07555, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0.08293, 0, 0.66667],
          "67": [0, 0.69444, 0.11983, 0, 0.63889],
          "68": [0, 0.69444, 0.07555, 0, 0.72223],
          "69": [0, 0.69444, 0.11983, 0, 0.59722],
          "70": [0, 0.69444, 0.13372, 0, 0.56945],
          "71": [0, 0.69444, 0.11983, 0, 0.66667],
          "72": [0, 0.69444, 0.08094, 0, 0.70834],
          "73": [0, 0.69444, 0.13372, 0, 0.27778],
          "74": [0, 0.69444, 0.08094, 0, 0.47222],
          "75": [0, 0.69444, 0.11983, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0.08094, 0, 0.875],
          "78": [0, 0.69444, 0.08094, 0, 0.70834],
          "79": [0, 0.69444, 0.07555, 0, 0.73611],
          "80": [0, 0.69444, 0.08293, 0, 0.63889],
          "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
          "82": [0, 0.69444, 0.08293, 0, 0.64584],
          "83": [0, 0.69444, 0.09205, 0, 0.55556],
          "84": [0, 0.69444, 0.13372, 0, 0.68056],
          "85": [0, 0.69444, 0.08094, 0, 0.6875],
          "86": [0, 0.69444, 0.1615, 0, 0.66667],
          "87": [0, 0.69444, 0.1615, 0, 0.94445],
          "88": [0, 0.69444, 0.13372, 0, 0.66667],
          "89": [0, 0.69444, 0.17261, 0, 0.66667],
          "90": [0, 0.69444, 0.11983, 0, 0.61111],
          "91": [0.25, 0.75, 0.15942, 0, 0.28889],
          "93": [0.25, 0.75, 0.08719, 0, 0.28889],
          "94": [0, 0.69444, 0.0799, 0, 0.5],
          "95": [0.35, 0.09444, 0.08616, 0, 0.5],
          "97": [0, 0.44444, 981e-5, 0, 0.48056],
          "98": [0, 0.69444, 0.03057, 0, 0.51667],
          "99": [0, 0.44444, 0.08336, 0, 0.44445],
          "100": [0, 0.69444, 0.09483, 0, 0.51667],
          "101": [0, 0.44444, 0.06778, 0, 0.44445],
          "102": [0, 0.69444, 0.21705, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
          "104": [0, 0.69444, 0.01778, 0, 0.51667],
          "105": [0, 0.67937, 0.09718, 0, 0.23889],
          "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
          "107": [0, 0.69444, 0.08336, 0, 0.48889],
          "108": [0, 0.69444, 0.09483, 0, 0.23889],
          "109": [0, 0.44444, 0.01778, 0, 0.79445],
          "110": [0, 0.44444, 0.01778, 0, 0.51667],
          "111": [0, 0.44444, 0.06613, 0, 0.5],
          "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
          "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
          "114": [0, 0.44444, 0.10836, 0, 0.34167],
          "115": [0, 0.44444, 0.0778, 0, 0.38333],
          "116": [0, 0.57143, 0.07225, 0, 0.36111],
          "117": [0, 0.44444, 0.04169, 0, 0.51667],
          "118": [0, 0.44444, 0.10836, 0, 0.46111],
          "119": [0, 0.44444, 0.10836, 0, 0.68334],
          "120": [0, 0.44444, 0.09169, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
          "122": [0, 0.44444, 0.08752, 0, 0.43472],
          "126": [0.35, 0.32659, 0.08826, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0.06385, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.73752],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0.04169, 0, 0.23889],
          "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
          "710": [0, 0.69444, 0.0799, 0, 0.5],
          "711": [0, 0.63194, 0.08432, 0, 0.5],
          "713": [0, 0.60889, 0.08776, 0, 0.5],
          "714": [0, 0.69444, 0.09205, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0.09483, 0, 0.5],
          "729": [0, 0.67937, 0.07774, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.73752],
          "732": [0, 0.67659, 0.08826, 0, 0.5],
          "733": [0, 0.69444, 0.09205, 0, 0.5],
          "915": [0, 0.69444, 0.13372, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0.07555, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0.12816, 0, 0.66667],
          "928": [0, 0.69444, 0.08094, 0, 0.70834],
          "931": [0, 0.69444, 0.11983, 0, 0.72222],
          "933": [0, 0.69444, 0.09031, 0, 0.77778],
          "934": [0, 0.69444, 0.04603, 0, 0.72222],
          "936": [0, 0.69444, 0.09031, 0, 0.77778],
          "937": [0, 0.69444, 0.08293, 0, 0.72222],
          "8211": [0, 0.44444, 0.08616, 0, 0.5],
          "8212": [0, 0.44444, 0.08616, 0, 1],
          "8216": [0, 0.69444, 0.07816, 0, 0.27778],
          "8217": [0, 0.69444, 0.07816, 0, 0.27778],
          "8220": [0, 0.69444, 0.14205, 0, 0.5],
          "8221": [0, 0.69444, 316e-5, 0, 0.5]
        },
        "SansSerif-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.31945],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.75834],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.65556, 0, 0, 0.5],
          "49": [0, 0.65556, 0, 0, 0.5],
          "50": [0, 0.65556, 0, 0, 0.5],
          "51": [0, 0.65556, 0, 0, 0.5],
          "52": [0, 0.65556, 0, 0, 0.5],
          "53": [0, 0.65556, 0, 0, 0.5],
          "54": [0, 0.65556, 0, 0, 0.5],
          "55": [0, 0.65556, 0, 0, 0.5],
          "56": [0, 0.65556, 0, 0, 0.5],
          "57": [0, 0.65556, 0, 0, 0.5],
          "58": [0, 0.44444, 0, 0, 0.27778],
          "59": [0.125, 0.44444, 0, 0, 0.27778],
          "61": [-0.13, 0.37, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0, 0, 0.66667],
          "67": [0, 0.69444, 0, 0, 0.63889],
          "68": [0, 0.69444, 0, 0, 0.72223],
          "69": [0, 0.69444, 0, 0, 0.59722],
          "70": [0, 0.69444, 0, 0, 0.56945],
          "71": [0, 0.69444, 0, 0, 0.66667],
          "72": [0, 0.69444, 0, 0, 0.70834],
          "73": [0, 0.69444, 0, 0, 0.27778],
          "74": [0, 0.69444, 0, 0, 0.47222],
          "75": [0, 0.69444, 0, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0, 0, 0.875],
          "78": [0, 0.69444, 0, 0, 0.70834],
          "79": [0, 0.69444, 0, 0, 0.73611],
          "80": [0, 0.69444, 0, 0, 0.63889],
          "81": [0.125, 0.69444, 0, 0, 0.73611],
          "82": [0, 0.69444, 0, 0, 0.64584],
          "83": [0, 0.69444, 0, 0, 0.55556],
          "84": [0, 0.69444, 0, 0, 0.68056],
          "85": [0, 0.69444, 0, 0, 0.6875],
          "86": [0, 0.69444, 0.01389, 0, 0.66667],
          "87": [0, 0.69444, 0.01389, 0, 0.94445],
          "88": [0, 0.69444, 0, 0, 0.66667],
          "89": [0, 0.69444, 0.025, 0, 0.66667],
          "90": [0, 0.69444, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.28889],
          "93": [0.25, 0.75, 0, 0, 0.28889],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.35, 0.09444, 0.02778, 0, 0.5],
          "97": [0, 0.44444, 0, 0, 0.48056],
          "98": [0, 0.69444, 0, 0, 0.51667],
          "99": [0, 0.44444, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.51667],
          "101": [0, 0.44444, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.06944, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.51667],
          "105": [0, 0.67937, 0, 0, 0.23889],
          "106": [0.19444, 0.67937, 0, 0, 0.26667],
          "107": [0, 0.69444, 0, 0, 0.48889],
          "108": [0, 0.69444, 0, 0, 0.23889],
          "109": [0, 0.44444, 0, 0, 0.79445],
          "110": [0, 0.44444, 0, 0, 0.51667],
          "111": [0, 0.44444, 0, 0, 0.5],
          "112": [0.19444, 0.44444, 0, 0, 0.51667],
          "113": [0.19444, 0.44444, 0, 0, 0.51667],
          "114": [0, 0.44444, 0.01389, 0, 0.34167],
          "115": [0, 0.44444, 0, 0, 0.38333],
          "116": [0, 0.57143, 0, 0, 0.36111],
          "117": [0, 0.44444, 0, 0, 0.51667],
          "118": [0, 0.44444, 0.01389, 0, 0.46111],
          "119": [0, 0.44444, 0.01389, 0, 0.68334],
          "120": [0, 0.44444, 0, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
          "122": [0, 0.44444, 0, 0, 0.43472],
          "126": [0.35, 0.32659, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.66667],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0, 0, 0.23889],
          "567": [0.19444, 0.44444, 0, 0, 0.26667],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.63194, 0, 0, 0.5],
          "713": [0, 0.60889, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.67937, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.66667],
          "732": [0, 0.67659, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.69444, 0, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0, 0, 0.66667],
          "928": [0, 0.69444, 0, 0, 0.70834],
          "931": [0, 0.69444, 0, 0, 0.72222],
          "933": [0, 0.69444, 0, 0, 0.77778],
          "934": [0, 0.69444, 0, 0, 0.72222],
          "936": [0, 0.69444, 0, 0, 0.77778],
          "937": [0, 0.69444, 0, 0, 0.72222],
          "8211": [0, 0.44444, 0.02778, 0, 0.5],
          "8212": [0, 0.44444, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5]
        },
        "Script-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.7, 0.22925, 0, 0.80253],
          "66": [0, 0.7, 0.04087, 0, 0.90757],
          "67": [0, 0.7, 0.1689, 0, 0.66619],
          "68": [0, 0.7, 0.09371, 0, 0.77443],
          "69": [0, 0.7, 0.18583, 0, 0.56162],
          "70": [0, 0.7, 0.13634, 0, 0.89544],
          "71": [0, 0.7, 0.17322, 0, 0.60961],
          "72": [0, 0.7, 0.29694, 0, 0.96919],
          "73": [0, 0.7, 0.19189, 0, 0.80907],
          "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
          "75": [0, 0.7, 0.31259, 0, 0.91364],
          "76": [0, 0.7, 0.19189, 0, 0.87373],
          "77": [0, 0.7, 0.15981, 0, 1.08031],
          "78": [0, 0.7, 0.3525, 0, 0.9015],
          "79": [0, 0.7, 0.08078, 0, 0.73787],
          "80": [0, 0.7, 0.08078, 0, 1.01262],
          "81": [0, 0.7, 0.03305, 0, 0.88282],
          "82": [0, 0.7, 0.06259, 0, 0.85],
          "83": [0, 0.7, 0.19189, 0, 0.86767],
          "84": [0, 0.7, 0.29087, 0, 0.74697],
          "85": [0, 0.7, 0.25815, 0, 0.79996],
          "86": [0, 0.7, 0.27523, 0, 0.62204],
          "87": [0, 0.7, 0.27523, 0, 0.80532],
          "88": [0, 0.7, 0.26006, 0, 0.94445],
          "89": [0, 0.7, 0.2939, 0, 0.70961],
          "90": [0, 0.7, 0.24037, 0, 0.8212],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Size1-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.35001, 0.85, 0, 0, 0.45834],
          "41": [0.35001, 0.85, 0, 0, 0.45834],
          "47": [0.35001, 0.85, 0, 0, 0.57778],
          "91": [0.35001, 0.85, 0, 0, 0.41667],
          "92": [0.35001, 0.85, 0, 0, 0.57778],
          "93": [0.35001, 0.85, 0, 0, 0.41667],
          "123": [0.35001, 0.85, 0, 0, 0.58334],
          "125": [0.35001, 0.85, 0, 0, 0.58334],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.72222, 0, 0, 0.55556],
          "732": [0, 0.72222, 0, 0, 0.55556],
          "770": [0, 0.72222, 0, 0, 0.55556],
          "771": [0, 0.72222, 0, 0, 0.55556],
          "8214": [-99e-5, 0.601, 0, 0, 0.77778],
          "8593": [1e-5, 0.6, 0, 0, 0.66667],
          "8595": [1e-5, 0.6, 0, 0, 0.66667],
          "8657": [1e-5, 0.6, 0, 0, 0.77778],
          "8659": [1e-5, 0.6, 0, 0, 0.77778],
          "8719": [0.25001, 0.75, 0, 0, 0.94445],
          "8720": [0.25001, 0.75, 0, 0, 0.94445],
          "8721": [0.25001, 0.75, 0, 0, 1.05556],
          "8730": [0.35001, 0.85, 0, 0, 1],
          "8739": [-599e-5, 0.606, 0, 0, 0.33333],
          "8741": [-599e-5, 0.606, 0, 0, 0.55556],
          "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8896": [0.25001, 0.75, 0, 0, 0.83334],
          "8897": [0.25001, 0.75, 0, 0, 0.83334],
          "8898": [0.25001, 0.75, 0, 0, 0.83334],
          "8899": [0.25001, 0.75, 0, 0, 0.83334],
          "8968": [0.35001, 0.85, 0, 0, 0.47222],
          "8969": [0.35001, 0.85, 0, 0, 0.47222],
          "8970": [0.35001, 0.85, 0, 0, 0.47222],
          "8971": [0.35001, 0.85, 0, 0, 0.47222],
          "9168": [-99e-5, 0.601, 0, 0, 0.66667],
          "10216": [0.35001, 0.85, 0, 0, 0.47222],
          "10217": [0.35001, 0.85, 0, 0, 0.47222],
          "10752": [0.25001, 0.75, 0, 0, 1.11111],
          "10753": [0.25001, 0.75, 0, 0, 1.11111],
          "10754": [0.25001, 0.75, 0, 0, 1.11111],
          "10756": [0.25001, 0.75, 0, 0, 0.83334],
          "10758": [0.25001, 0.75, 0, 0, 0.83334]
        },
        "Size2-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.65002, 1.15, 0, 0, 0.59722],
          "41": [0.65002, 1.15, 0, 0, 0.59722],
          "47": [0.65002, 1.15, 0, 0, 0.81111],
          "91": [0.65002, 1.15, 0, 0, 0.47222],
          "92": [0.65002, 1.15, 0, 0, 0.81111],
          "93": [0.65002, 1.15, 0, 0, 0.47222],
          "123": [0.65002, 1.15, 0, 0, 0.66667],
          "125": [0.65002, 1.15, 0, 0, 0.66667],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1],
          "732": [0, 0.75, 0, 0, 1],
          "770": [0, 0.75, 0, 0, 1],
          "771": [0, 0.75, 0, 0, 1],
          "8719": [0.55001, 1.05, 0, 0, 1.27778],
          "8720": [0.55001, 1.05, 0, 0, 1.27778],
          "8721": [0.55001, 1.05, 0, 0, 1.44445],
          "8730": [0.65002, 1.15, 0, 0, 1],
          "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8896": [0.55001, 1.05, 0, 0, 1.11111],
          "8897": [0.55001, 1.05, 0, 0, 1.11111],
          "8898": [0.55001, 1.05, 0, 0, 1.11111],
          "8899": [0.55001, 1.05, 0, 0, 1.11111],
          "8968": [0.65002, 1.15, 0, 0, 0.52778],
          "8969": [0.65002, 1.15, 0, 0, 0.52778],
          "8970": [0.65002, 1.15, 0, 0, 0.52778],
          "8971": [0.65002, 1.15, 0, 0, 0.52778],
          "10216": [0.65002, 1.15, 0, 0, 0.61111],
          "10217": [0.65002, 1.15, 0, 0, 0.61111],
          "10752": [0.55001, 1.05, 0, 0, 1.51112],
          "10753": [0.55001, 1.05, 0, 0, 1.51112],
          "10754": [0.55001, 1.05, 0, 0, 1.51112],
          "10756": [0.55001, 1.05, 0, 0, 1.11111],
          "10758": [0.55001, 1.05, 0, 0, 1.11111]
        },
        "Size3-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.95003, 1.45, 0, 0, 0.73611],
          "41": [0.95003, 1.45, 0, 0, 0.73611],
          "47": [0.95003, 1.45, 0, 0, 1.04445],
          "91": [0.95003, 1.45, 0, 0, 0.52778],
          "92": [0.95003, 1.45, 0, 0, 1.04445],
          "93": [0.95003, 1.45, 0, 0, 0.52778],
          "123": [0.95003, 1.45, 0, 0, 0.75],
          "125": [0.95003, 1.45, 0, 0, 0.75],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1.44445],
          "732": [0, 0.75, 0, 0, 1.44445],
          "770": [0, 0.75, 0, 0, 1.44445],
          "771": [0, 0.75, 0, 0, 1.44445],
          "8730": [0.95003, 1.45, 0, 0, 1],
          "8968": [0.95003, 1.45, 0, 0, 0.58334],
          "8969": [0.95003, 1.45, 0, 0, 0.58334],
          "8970": [0.95003, 1.45, 0, 0, 0.58334],
          "8971": [0.95003, 1.45, 0, 0, 0.58334],
          "10216": [0.95003, 1.45, 0, 0, 0.75],
          "10217": [0.95003, 1.45, 0, 0, 0.75]
        },
        "Size4-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [1.25003, 1.75, 0, 0, 0.79167],
          "41": [1.25003, 1.75, 0, 0, 0.79167],
          "47": [1.25003, 1.75, 0, 0, 1.27778],
          "91": [1.25003, 1.75, 0, 0, 0.58334],
          "92": [1.25003, 1.75, 0, 0, 1.27778],
          "93": [1.25003, 1.75, 0, 0, 0.58334],
          "123": [1.25003, 1.75, 0, 0, 0.80556],
          "125": [1.25003, 1.75, 0, 0, 0.80556],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.825, 0, 0, 1.8889],
          "732": [0, 0.825, 0, 0, 1.8889],
          "770": [0, 0.825, 0, 0, 1.8889],
          "771": [0, 0.825, 0, 0, 1.8889],
          "8730": [1.25003, 1.75, 0, 0, 1],
          "8968": [1.25003, 1.75, 0, 0, 0.63889],
          "8969": [1.25003, 1.75, 0, 0, 0.63889],
          "8970": [1.25003, 1.75, 0, 0, 0.63889],
          "8971": [1.25003, 1.75, 0, 0, 0.63889],
          "9115": [0.64502, 1.155, 0, 0, 0.875],
          "9116": [1e-5, 0.6, 0, 0, 0.875],
          "9117": [0.64502, 1.155, 0, 0, 0.875],
          "9118": [0.64502, 1.155, 0, 0, 0.875],
          "9119": [1e-5, 0.6, 0, 0, 0.875],
          "9120": [0.64502, 1.155, 0, 0, 0.875],
          "9121": [0.64502, 1.155, 0, 0, 0.66667],
          "9122": [-99e-5, 0.601, 0, 0, 0.66667],
          "9123": [0.64502, 1.155, 0, 0, 0.66667],
          "9124": [0.64502, 1.155, 0, 0, 0.66667],
          "9125": [-99e-5, 0.601, 0, 0, 0.66667],
          "9126": [0.64502, 1.155, 0, 0, 0.66667],
          "9127": [1e-5, 0.9, 0, 0, 0.88889],
          "9128": [0.65002, 1.15, 0, 0, 0.88889],
          "9129": [0.90001, 0, 0, 0, 0.88889],
          "9130": [0, 0.3, 0, 0, 0.88889],
          "9131": [1e-5, 0.9, 0, 0, 0.88889],
          "9132": [0.65002, 1.15, 0, 0, 0.88889],
          "9133": [0.90001, 0, 0, 0, 0.88889],
          "9143": [0.88502, 0.915, 0, 0, 1.05556],
          "10216": [1.25003, 1.75, 0, 0, 0.80556],
          "10217": [1.25003, 1.75, 0, 0, 0.80556],
          "57344": [-499e-5, 0.605, 0, 0, 1.05556],
          "57345": [-499e-5, 0.605, 0, 0, 1.05556],
          "57680": [0, 0.12, 0, 0, 0.45],
          "57681": [0, 0.12, 0, 0, 0.45],
          "57682": [0, 0.12, 0, 0, 0.45],
          "57683": [0, 0.12, 0, 0, 0.45]
        },
        "Typewriter-Regular": {
          "32": [0, 0, 0, 0, 0.525],
          "33": [0, 0.61111, 0, 0, 0.525],
          "34": [0, 0.61111, 0, 0, 0.525],
          "35": [0, 0.61111, 0, 0, 0.525],
          "36": [0.08333, 0.69444, 0, 0, 0.525],
          "37": [0.08333, 0.69444, 0, 0, 0.525],
          "38": [0, 0.61111, 0, 0, 0.525],
          "39": [0, 0.61111, 0, 0, 0.525],
          "40": [0.08333, 0.69444, 0, 0, 0.525],
          "41": [0.08333, 0.69444, 0, 0, 0.525],
          "42": [0, 0.52083, 0, 0, 0.525],
          "43": [-0.08056, 0.53055, 0, 0, 0.525],
          "44": [0.13889, 0.125, 0, 0, 0.525],
          "45": [-0.08056, 0.53055, 0, 0, 0.525],
          "46": [0, 0.125, 0, 0, 0.525],
          "47": [0.08333, 0.69444, 0, 0, 0.525],
          "48": [0, 0.61111, 0, 0, 0.525],
          "49": [0, 0.61111, 0, 0, 0.525],
          "50": [0, 0.61111, 0, 0, 0.525],
          "51": [0, 0.61111, 0, 0, 0.525],
          "52": [0, 0.61111, 0, 0, 0.525],
          "53": [0, 0.61111, 0, 0, 0.525],
          "54": [0, 0.61111, 0, 0, 0.525],
          "55": [0, 0.61111, 0, 0, 0.525],
          "56": [0, 0.61111, 0, 0, 0.525],
          "57": [0, 0.61111, 0, 0, 0.525],
          "58": [0, 0.43056, 0, 0, 0.525],
          "59": [0.13889, 0.43056, 0, 0, 0.525],
          "60": [-0.05556, 0.55556, 0, 0, 0.525],
          "61": [-0.19549, 0.41562, 0, 0, 0.525],
          "62": [-0.05556, 0.55556, 0, 0, 0.525],
          "63": [0, 0.61111, 0, 0, 0.525],
          "64": [0, 0.61111, 0, 0, 0.525],
          "65": [0, 0.61111, 0, 0, 0.525],
          "66": [0, 0.61111, 0, 0, 0.525],
          "67": [0, 0.61111, 0, 0, 0.525],
          "68": [0, 0.61111, 0, 0, 0.525],
          "69": [0, 0.61111, 0, 0, 0.525],
          "70": [0, 0.61111, 0, 0, 0.525],
          "71": [0, 0.61111, 0, 0, 0.525],
          "72": [0, 0.61111, 0, 0, 0.525],
          "73": [0, 0.61111, 0, 0, 0.525],
          "74": [0, 0.61111, 0, 0, 0.525],
          "75": [0, 0.61111, 0, 0, 0.525],
          "76": [0, 0.61111, 0, 0, 0.525],
          "77": [0, 0.61111, 0, 0, 0.525],
          "78": [0, 0.61111, 0, 0, 0.525],
          "79": [0, 0.61111, 0, 0, 0.525],
          "80": [0, 0.61111, 0, 0, 0.525],
          "81": [0.13889, 0.61111, 0, 0, 0.525],
          "82": [0, 0.61111, 0, 0, 0.525],
          "83": [0, 0.61111, 0, 0, 0.525],
          "84": [0, 0.61111, 0, 0, 0.525],
          "85": [0, 0.61111, 0, 0, 0.525],
          "86": [0, 0.61111, 0, 0, 0.525],
          "87": [0, 0.61111, 0, 0, 0.525],
          "88": [0, 0.61111, 0, 0, 0.525],
          "89": [0, 0.61111, 0, 0, 0.525],
          "90": [0, 0.61111, 0, 0, 0.525],
          "91": [0.08333, 0.69444, 0, 0, 0.525],
          "92": [0.08333, 0.69444, 0, 0, 0.525],
          "93": [0.08333, 0.69444, 0, 0, 0.525],
          "94": [0, 0.61111, 0, 0, 0.525],
          "95": [0.09514, 0, 0, 0, 0.525],
          "96": [0, 0.61111, 0, 0, 0.525],
          "97": [0, 0.43056, 0, 0, 0.525],
          "98": [0, 0.61111, 0, 0, 0.525],
          "99": [0, 0.43056, 0, 0, 0.525],
          "100": [0, 0.61111, 0, 0, 0.525],
          "101": [0, 0.43056, 0, 0, 0.525],
          "102": [0, 0.61111, 0, 0, 0.525],
          "103": [0.22222, 0.43056, 0, 0, 0.525],
          "104": [0, 0.61111, 0, 0, 0.525],
          "105": [0, 0.61111, 0, 0, 0.525],
          "106": [0.22222, 0.61111, 0, 0, 0.525],
          "107": [0, 0.61111, 0, 0, 0.525],
          "108": [0, 0.61111, 0, 0, 0.525],
          "109": [0, 0.43056, 0, 0, 0.525],
          "110": [0, 0.43056, 0, 0, 0.525],
          "111": [0, 0.43056, 0, 0, 0.525],
          "112": [0.22222, 0.43056, 0, 0, 0.525],
          "113": [0.22222, 0.43056, 0, 0, 0.525],
          "114": [0, 0.43056, 0, 0, 0.525],
          "115": [0, 0.43056, 0, 0, 0.525],
          "116": [0, 0.55358, 0, 0, 0.525],
          "117": [0, 0.43056, 0, 0, 0.525],
          "118": [0, 0.43056, 0, 0, 0.525],
          "119": [0, 0.43056, 0, 0, 0.525],
          "120": [0, 0.43056, 0, 0, 0.525],
          "121": [0.22222, 0.43056, 0, 0, 0.525],
          "122": [0, 0.43056, 0, 0, 0.525],
          "123": [0.08333, 0.69444, 0, 0, 0.525],
          "124": [0.08333, 0.69444, 0, 0, 0.525],
          "125": [0.08333, 0.69444, 0, 0, 0.525],
          "126": [0, 0.61111, 0, 0, 0.525],
          "127": [0, 0.61111, 0, 0, 0.525],
          "160": [0, 0, 0, 0, 0.525],
          "176": [0, 0.61111, 0, 0, 0.525],
          "184": [0.19445, 0, 0, 0, 0.525],
          "305": [0, 0.43056, 0, 0, 0.525],
          "567": [0.22222, 0.43056, 0, 0, 0.525],
          "711": [0, 0.56597, 0, 0, 0.525],
          "713": [0, 0.56555, 0, 0, 0.525],
          "714": [0, 0.61111, 0, 0, 0.525],
          "715": [0, 0.61111, 0, 0, 0.525],
          "728": [0, 0.61111, 0, 0, 0.525],
          "730": [0, 0.61111, 0, 0, 0.525],
          "770": [0, 0.61111, 0, 0, 0.525],
          "771": [0, 0.61111, 0, 0, 0.525],
          "776": [0, 0.61111, 0, 0, 0.525],
          "915": [0, 0.61111, 0, 0, 0.525],
          "916": [0, 0.61111, 0, 0, 0.525],
          "920": [0, 0.61111, 0, 0, 0.525],
          "923": [0, 0.61111, 0, 0, 0.525],
          "926": [0, 0.61111, 0, 0, 0.525],
          "928": [0, 0.61111, 0, 0, 0.525],
          "931": [0, 0.61111, 0, 0, 0.525],
          "933": [0, 0.61111, 0, 0, 0.525],
          "934": [0, 0.61111, 0, 0, 0.525],
          "936": [0, 0.61111, 0, 0, 0.525],
          "937": [0, 0.61111, 0, 0, 0.525],
          "8216": [0, 0.61111, 0, 0, 0.525],
          "8217": [0, 0.61111, 0, 0, 0.525],
          "8242": [0, 0.61111, 0, 0, 0.525],
          "9251": [0.11111, 0.21944, 0, 0, 0.525]
        }
      };
      var sigmasAndXis2 = {
        slant: [0.25, 0.25, 0.25],
        space: [0, 0, 0],
        stretch: [0, 0, 0],
        shrink: [0, 0, 0],
        xHeight: [0.431, 0.431, 0.431],
        quad: [1, 1.171, 1.472],
        extraSpace: [0, 0, 0],
        num1: [0.677, 0.732, 0.925],
        num2: [0.394, 0.384, 0.387],
        num3: [0.444, 0.471, 0.504],
        denom1: [0.686, 0.752, 1.025],
        denom2: [0.345, 0.344, 0.532],
        sup1: [0.413, 0.503, 0.504],
        sup2: [0.363, 0.431, 0.404],
        sup3: [0.289, 0.286, 0.294],
        sub1: [0.15, 0.143, 0.2],
        sub2: [0.247, 0.286, 0.4],
        supDrop: [0.386, 0.353, 0.494],
        subDrop: [0.05, 0.071, 0.1],
        delim1: [2.39, 1.7, 1.98],
        delim2: [1.01, 1.157, 1.42],
        axisHeight: [0.25, 0.25, 0.25],
        defaultRuleThickness: [0.04, 0.049, 0.049],
        bigOpSpacing1: [0.111, 0.111, 0.111],
        bigOpSpacing2: [0.166, 0.166, 0.166],
        bigOpSpacing3: [0.2, 0.2, 0.2],
        bigOpSpacing4: [0.6, 0.611, 0.611],
        bigOpSpacing5: [0.1, 0.143, 0.143],
        sqrtRuleThickness: [0.04, 0.04, 0.04],
        ptPerEm: [10, 10, 10],
        doubleRuleSep: [0.2, 0.2, 0.2],
        arrayRuleWidth: [0.04, 0.04, 0.04],
        fboxsep: [0.3, 0.3, 0.3],
        fboxrule: [0.04, 0.04, 0.04]
      };
      var extraCharacterMap2 = {
        "\xC5": "A",
        "\xD0": "D",
        "\xDE": "o",
        "\xE5": "a",
        "\xF0": "d",
        "\xFE": "o",
        "\u0410": "A",
        "\u0411": "B",
        "\u0412": "B",
        "\u0413": "F",
        "\u0414": "A",
        "\u0415": "E",
        "\u0416": "K",
        "\u0417": "3",
        "\u0418": "N",
        "\u0419": "N",
        "\u041A": "K",
        "\u041B": "N",
        "\u041C": "M",
        "\u041D": "H",
        "\u041E": "O",
        "\u041F": "N",
        "\u0420": "P",
        "\u0421": "C",
        "\u0422": "T",
        "\u0423": "y",
        "\u0424": "O",
        "\u0425": "X",
        "\u0426": "U",
        "\u0427": "h",
        "\u0428": "W",
        "\u0429": "W",
        "\u042A": "B",
        "\u042B": "X",
        "\u042C": "B",
        "\u042D": "3",
        "\u042E": "X",
        "\u042F": "R",
        "\u0430": "a",
        "\u0431": "b",
        "\u0432": "a",
        "\u0433": "r",
        "\u0434": "y",
        "\u0435": "e",
        "\u0436": "m",
        "\u0437": "e",
        "\u0438": "n",
        "\u0439": "n",
        "\u043A": "n",
        "\u043B": "n",
        "\u043C": "m",
        "\u043D": "n",
        "\u043E": "o",
        "\u043F": "n",
        "\u0440": "p",
        "\u0441": "c",
        "\u0442": "o",
        "\u0443": "y",
        "\u0444": "b",
        "\u0445": "x",
        "\u0446": "n",
        "\u0447": "n",
        "\u0448": "w",
        "\u0449": "w",
        "\u044A": "a",
        "\u044B": "m",
        "\u044C": "a",
        "\u044D": "e",
        "\u044E": "m",
        "\u044F": "r"
      };
      function setFontMetrics2(fontName, metrics) {
        fontMetricsData2[fontName] = metrics;
      }
      function getCharacterMetrics2(character, font, mode) {
        if (!fontMetricsData2[font]) {
          throw new Error("Font metrics not found for font: " + font + ".");
        }
        var ch3 = character.charCodeAt(0);
        var metrics = fontMetricsData2[font][ch3];
        if (!metrics && character[0] in extraCharacterMap2) {
          ch3 = extraCharacterMap2[character[0]].charCodeAt(0);
          metrics = fontMetricsData2[font][ch3];
        }
        if (!metrics && mode === "text") {
          if (supportedCodepoint2(ch3)) {
            metrics = fontMetricsData2[font][77];
          }
        }
        if (metrics) {
          return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
          };
        }
      }
      var fontMetricsBySizeIndex2 = {};
      function getGlobalMetrics2(size) {
        var sizeIndex;
        if (size >= 5) {
          sizeIndex = 0;
        } else if (size >= 3) {
          sizeIndex = 1;
        } else {
          sizeIndex = 2;
        }
        if (!fontMetricsBySizeIndex2[sizeIndex]) {
          var metrics = fontMetricsBySizeIndex2[sizeIndex] = {
            cssEmPerMu: sigmasAndXis2.quad[sizeIndex] / 18
          };
          for (var key in sigmasAndXis2) {
            if (sigmasAndXis2.hasOwnProperty(key)) {
              metrics[key] = sigmasAndXis2[key][sizeIndex];
            }
          }
        }
        return fontMetricsBySizeIndex2[sizeIndex];
      }
      var sizeStyleMap2 = [
        [1, 1, 1],
        [2, 1, 1],
        [3, 1, 1],
        [4, 2, 1],
        [5, 2, 1],
        [6, 3, 1],
        [7, 4, 2],
        [8, 6, 3],
        [9, 7, 6],
        [10, 8, 7],
        [11, 10, 9]
      ];
      var sizeMultipliers2 = [
        0.5,
        0.6,
        0.7,
        0.8,
        0.9,
        1,
        1.2,
        1.44,
        1.728,
        2.074,
        2.488
      ];
      var sizeAtStyle3 = function sizeAtStyle4(size, style) {
        return style.size < 2 ? size : sizeStyleMap2[size - 1][style.size - 1];
      };
      var Options2 = /* @__PURE__ */ function() {
        function Options3(data2) {
          this.style = void 0;
          this.color = void 0;
          this.size = void 0;
          this.textSize = void 0;
          this.phantom = void 0;
          this.font = void 0;
          this.fontFamily = void 0;
          this.fontWeight = void 0;
          this.fontShape = void 0;
          this.sizeMultiplier = void 0;
          this.maxSize = void 0;
          this.minRuleThickness = void 0;
          this._fontMetrics = void 0;
          this.style = data2.style;
          this.color = data2.color;
          this.size = data2.size || Options3.BASESIZE;
          this.textSize = data2.textSize || this.size;
          this.phantom = !!data2.phantom;
          this.font = data2.font || "";
          this.fontFamily = data2.fontFamily || "";
          this.fontWeight = data2.fontWeight || "";
          this.fontShape = data2.fontShape || "";
          this.sizeMultiplier = sizeMultipliers2[this.size - 1];
          this.maxSize = data2.maxSize;
          this.minRuleThickness = data2.minRuleThickness;
          this._fontMetrics = void 0;
        }
        var _proto = Options3.prototype;
        _proto.extend = function extend(extension) {
          var data2 = {
            style: this.style,
            size: this.size,
            textSize: this.textSize,
            color: this.color,
            phantom: this.phantom,
            font: this.font,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            fontShape: this.fontShape,
            maxSize: this.maxSize,
            minRuleThickness: this.minRuleThickness
          };
          for (var key in extension) {
            if (extension.hasOwnProperty(key)) {
              data2[key] = extension[key];
            }
          }
          return new Options3(data2);
        };
        _proto.havingStyle = function havingStyle(style) {
          if (this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: sizeAtStyle3(this.textSize, style)
            });
          }
        };
        _proto.havingCrampedStyle = function havingCrampedStyle() {
          return this.havingStyle(this.style.cramp());
        };
        _proto.havingSize = function havingSize(size) {
          if (this.size === size && this.textSize === size) {
            return this;
          } else {
            return this.extend({
              style: this.style.text(),
              size,
              textSize: size,
              sizeMultiplier: sizeMultipliers2[size - 1]
            });
          }
        };
        _proto.havingBaseStyle = function havingBaseStyle(style) {
          style = style || this.style.text();
          var wantSize = sizeAtStyle3(Options3.BASESIZE, style);
          if (this.size === wantSize && this.textSize === Options3.BASESIZE && this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: wantSize
            });
          }
        };
        _proto.havingBaseSizing = function havingBaseSizing() {
          var size;
          switch (this.style.id) {
            case 4:
            case 5:
              size = 3;
              break;
            case 6:
            case 7:
              size = 1;
              break;
            default:
              size = 6;
          }
          return this.extend({
            style: this.style.text(),
            size
          });
        };
        _proto.withColor = function withColor(color) {
          return this.extend({
            color
          });
        };
        _proto.withPhantom = function withPhantom() {
          return this.extend({
            phantom: true
          });
        };
        _proto.withFont = function withFont(font) {
          return this.extend({
            font
          });
        };
        _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {
          return this.extend({
            fontFamily,
            font: ""
          });
        };
        _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {
          return this.extend({
            fontWeight,
            font: ""
          });
        };
        _proto.withTextFontShape = function withTextFontShape(fontShape) {
          return this.extend({
            fontShape,
            font: ""
          });
        };
        _proto.sizingClasses = function sizingClasses(oldOptions) {
          if (oldOptions.size !== this.size) {
            return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
          } else {
            return [];
          }
        };
        _proto.baseSizingClasses = function baseSizingClasses() {
          if (this.size !== Options3.BASESIZE) {
            return ["sizing", "reset-size" + this.size, "size" + Options3.BASESIZE];
          } else {
            return [];
          }
        };
        _proto.fontMetrics = function fontMetrics() {
          if (!this._fontMetrics) {
            this._fontMetrics = getGlobalMetrics2(this.size);
          }
          return this._fontMetrics;
        };
        _proto.getColor = function getColor() {
          if (this.phantom) {
            return "transparent";
          } else {
            return this.color;
          }
        };
        return Options3;
      }();
      Options2.BASESIZE = 6;
      var src_Options = Options2;
      var ptPerUnit2 = {
        "pt": 1,
        "mm": 7227 / 2540,
        "cm": 7227 / 254,
        "in": 72.27,
        "bp": 803 / 800,
        "pc": 12,
        "dd": 1238 / 1157,
        "cc": 14856 / 1157,
        "nd": 685 / 642,
        "nc": 1370 / 107,
        "sp": 1 / 65536,
        "px": 803 / 800
      };
      var relativeUnit2 = {
        "ex": true,
        "em": true,
        "mu": true
      };
      var validUnit3 = function validUnit4(unit) {
        if (typeof unit !== "string") {
          unit = unit.unit;
        }
        return unit in ptPerUnit2 || unit in relativeUnit2 || unit === "ex";
      };
      var calculateSize3 = function calculateSize4(sizeValue, options2) {
        var scale;
        if (sizeValue.unit in ptPerUnit2) {
          scale = ptPerUnit2[sizeValue.unit] / options2.fontMetrics().ptPerEm / options2.sizeMultiplier;
        } else if (sizeValue.unit === "mu") {
          scale = options2.fontMetrics().cssEmPerMu;
        } else {
          var unitOptions;
          if (options2.style.isTight()) {
            unitOptions = options2.havingStyle(options2.style.text());
          } else {
            unitOptions = options2;
          }
          if (sizeValue.unit === "ex") {
            scale = unitOptions.fontMetrics().xHeight;
          } else if (sizeValue.unit === "em") {
            scale = unitOptions.fontMetrics().quad;
          } else {
            throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
          }
          if (unitOptions !== options2) {
            scale *= unitOptions.sizeMultiplier / options2.sizeMultiplier;
          }
        }
        return Math.min(sizeValue.number * scale, options2.maxSize);
      };
      var makeEm3 = function makeEm4(n2) {
        return +n2.toFixed(4) + "em";
      };
      var createClass3 = function createClass4(classes) {
        return classes.filter(function(cls) {
          return cls;
        }).join(" ");
      };
      var initNode3 = function initNode4(classes, options2, style) {
        this.classes = classes || [];
        this.attributes = {};
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = style || {};
        if (options2) {
          if (options2.style.isTight()) {
            this.classes.push("mtight");
          }
          var color = options2.getColor();
          if (color) {
            this.style.color = color;
          }
        }
      };
      var _toNode = function toNode3(tagName) {
        var node = document.createElement(tagName);
        node.className = createClass3(this.classes);
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            node.style[style] = this.style[style];
          }
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }
        for (var i3 = 0; i3 < this.children.length; i3++) {
          node.appendChild(this.children[i3].toNode());
        }
        return node;
      };
      var _toMarkup = function toMarkup3(tagName) {
        var markup = "<" + tagName;
        if (this.classes.length) {
          markup += ' class="' + utils2.escape(createClass3(this.classes)) + '"';
        }
        var styles3 = "";
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }
        if (styles3) {
          markup += ' style="' + utils2.escape(styles3) + '"';
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            markup += " " + attr + '="' + utils2.escape(this.attributes[attr]) + '"';
          }
        }
        markup += ">";
        for (var i3 = 0; i3 < this.children.length; i3++) {
          markup += this.children[i3].toMarkup();
        }
        markup += "</" + tagName + ">";
        return markup;
      };
      var Span2 = /* @__PURE__ */ function() {
        function Span3(classes, children, options2, style) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode3.call(this, classes, options2, style);
          this.children = children || [];
        }
        var _proto = Span3.prototype;
        _proto.setAttribute = function setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        };
        _proto.hasClass = function hasClass(className) {
          return utils2.contains(this.classes, className);
        };
        _proto.toNode = function toNode3() {
          return _toNode.call(this, "span");
        };
        _proto.toMarkup = function toMarkup3() {
          return _toMarkup.call(this, "span");
        };
        return Span3;
      }();
      var Anchor2 = /* @__PURE__ */ function() {
        function Anchor3(href, classes, children, options2) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode3.call(this, classes, options2);
          this.children = children || [];
          this.setAttribute("href", href);
        }
        var _proto2 = Anchor3.prototype;
        _proto2.setAttribute = function setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        };
        _proto2.hasClass = function hasClass(className) {
          return utils2.contains(this.classes, className);
        };
        _proto2.toNode = function toNode3() {
          return _toNode.call(this, "a");
        };
        _proto2.toMarkup = function toMarkup3() {
          return _toMarkup.call(this, "a");
        };
        return Anchor3;
      }();
      var Img2 = /* @__PURE__ */ function() {
        function Img3(src, alt, style) {
          this.src = void 0;
          this.alt = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.alt = alt;
          this.src = src;
          this.classes = ["mord"];
          this.style = style;
        }
        var _proto3 = Img3.prototype;
        _proto3.hasClass = function hasClass(className) {
          return utils2.contains(this.classes, className);
        };
        _proto3.toNode = function toNode3() {
          var node = document.createElement("img");
          node.src = this.src;
          node.alt = this.alt;
          node.className = "mord";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              node.style[style] = this.style[style];
            }
          }
          return node;
        };
        _proto3.toMarkup = function toMarkup3() {
          var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
          var styles3 = "";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles3) {
            markup += ' style="' + utils2.escape(styles3) + '"';
          }
          markup += "'/>";
          return markup;
        };
        return Img3;
      }();
      var iCombinations2 = {
        "\xEE": "\u0131\u0302",
        "\xEF": "\u0131\u0308",
        "\xED": "\u0131\u0301",
        "\xEC": "\u0131\u0300"
      };
      var SymbolNode2 = /* @__PURE__ */ function() {
        function SymbolNode3(text2, height, depth, italic, skew, width, classes, style) {
          this.text = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.italic = void 0;
          this.skew = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.classes = void 0;
          this.style = void 0;
          this.text = text2;
          this.height = height || 0;
          this.depth = depth || 0;
          this.italic = italic || 0;
          this.skew = skew || 0;
          this.width = width || 0;
          this.classes = classes || [];
          this.style = style || {};
          this.maxFontSize = 0;
          var script = scriptFromCodepoint2(this.text.charCodeAt(0));
          if (script) {
            this.classes.push(script + "_fallback");
          }
          if (/[]/.test(this.text)) {
            this.text = iCombinations2[this.text];
          }
        }
        var _proto4 = SymbolNode3.prototype;
        _proto4.hasClass = function hasClass(className) {
          return utils2.contains(this.classes, className);
        };
        _proto4.toNode = function toNode3() {
          var node = document.createTextNode(this.text);
          var span = null;
          if (this.italic > 0) {
            span = document.createElement("span");
            span.style.marginRight = makeEm3(this.italic);
          }
          if (this.classes.length > 0) {
            span = span || document.createElement("span");
            span.className = createClass3(this.classes);
          }
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              span = span || document.createElement("span");
              span.style[style] = this.style[style];
            }
          }
          if (span) {
            span.appendChild(node);
            return span;
          } else {
            return node;
          }
        };
        _proto4.toMarkup = function toMarkup3() {
          var needsSpan = false;
          var markup = "<span";
          if (this.classes.length) {
            needsSpan = true;
            markup += ' class="';
            markup += utils2.escape(createClass3(this.classes));
            markup += '"';
          }
          var styles3 = "";
          if (this.italic > 0) {
            styles3 += "margin-right:" + this.italic + "em;";
          }
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles3) {
            needsSpan = true;
            markup += ' style="' + utils2.escape(styles3) + '"';
          }
          var escaped = utils2.escape(this.text);
          if (needsSpan) {
            markup += ">";
            markup += escaped;
            markup += "</span>";
            return markup;
          } else {
            return escaped;
          }
        };
        return SymbolNode3;
      }();
      var SvgNode2 = /* @__PURE__ */ function() {
        function SvgNode3(children, attributes) {
          this.children = void 0;
          this.attributes = void 0;
          this.children = children || [];
          this.attributes = attributes || {};
        }
        var _proto5 = SvgNode3.prototype;
        _proto5.toNode = function toNode3() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "svg");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (var i3 = 0; i3 < this.children.length; i3++) {
            node.appendChild(this.children[i3].toNode());
          }
          return node;
        };
        _proto5.toMarkup = function toMarkup3() {
          var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + "='" + this.attributes[attr] + "'";
            }
          }
          markup += ">";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          markup += "</svg>";
          return markup;
        };
        return SvgNode3;
      }();
      var PathNode2 = /* @__PURE__ */ function() {
        function PathNode3(pathName, alternate) {
          this.pathName = void 0;
          this.alternate = void 0;
          this.pathName = pathName;
          this.alternate = alternate;
        }
        var _proto6 = PathNode3.prototype;
        _proto6.toNode = function toNode3() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "path");
          if (this.alternate) {
            node.setAttribute("d", this.alternate);
          } else {
            node.setAttribute("d", path2[this.pathName]);
          }
          return node;
        };
        _proto6.toMarkup = function toMarkup3() {
          if (this.alternate) {
            return "<path d='" + this.alternate + "'/>";
          } else {
            return "<path d='" + path2[this.pathName] + "'/>";
          }
        };
        return PathNode3;
      }();
      var LineNode2 = /* @__PURE__ */ function() {
        function LineNode3(attributes) {
          this.attributes = void 0;
          this.attributes = attributes || {};
        }
        var _proto7 = LineNode3.prototype;
        _proto7.toNode = function toNode3() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "line");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          return node;
        };
        _proto7.toMarkup = function toMarkup3() {
          var markup = "<line";
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + "='" + this.attributes[attr] + "'";
            }
          }
          markup += "/>";
          return markup;
        };
        return LineNode3;
      }();
      function assertSymbolDomNode2(group) {
        if (group instanceof SymbolNode2) {
          return group;
        } else {
          throw new Error("Expected symbolNode but got " + String(group) + ".");
        }
      }
      function assertSpan2(group) {
        if (group instanceof Span2) {
          return group;
        } else {
          throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
        }
      }
      var ATOMS2 = {
        "bin": 1,
        "close": 1,
        "inner": 1,
        "open": 1,
        "punct": 1,
        "rel": 1
      };
      var NON_ATOMS2 = {
        "accent-token": 1,
        "mathord": 1,
        "op-token": 1,
        "spacing": 1,
        "textord": 1
      };
      var symbols2 = {
        "math": {},
        "text": {}
      };
      var src_symbols = symbols2;
      function defineSymbol2(mode, font, group, replace, name, acceptUnicodeChar) {
        symbols2[mode][name] = {
          font,
          group,
          replace
        };
        if (acceptUnicodeChar && replace) {
          symbols2[mode][replace] = symbols2[mode][name];
        }
      }
      var math2 = "math";
      var symbols_text = "text";
      var main2 = "main";
      var ams2 = "ams";
      var accent2 = "accent-token";
      var bin2 = "bin";
      var symbols_close = "close";
      var inner2 = "inner";
      var mathord2 = "mathord";
      var op2 = "op-token";
      var symbols_open = "open";
      var punct2 = "punct";
      var rel2 = "rel";
      var spacing2 = "spacing";
      var textord2 = "textord";
      defineSymbol2(math2, main2, rel2, "\u2261", "\\equiv", true);
      defineSymbol2(math2, main2, rel2, "\u227A", "\\prec", true);
      defineSymbol2(math2, main2, rel2, "\u227B", "\\succ", true);
      defineSymbol2(math2, main2, rel2, "\u223C", "\\sim", true);
      defineSymbol2(math2, main2, rel2, "\u22A5", "\\perp");
      defineSymbol2(math2, main2, rel2, "\u2AAF", "\\preceq", true);
      defineSymbol2(math2, main2, rel2, "\u2AB0", "\\succeq", true);
      defineSymbol2(math2, main2, rel2, "\u2243", "\\simeq", true);
      defineSymbol2(math2, main2, rel2, "\u2223", "\\mid", true);
      defineSymbol2(math2, main2, rel2, "\u226A", "\\ll", true);
      defineSymbol2(math2, main2, rel2, "\u226B", "\\gg", true);
      defineSymbol2(math2, main2, rel2, "\u224D", "\\asymp", true);
      defineSymbol2(math2, main2, rel2, "\u2225", "\\parallel");
      defineSymbol2(math2, main2, rel2, "\u22C8", "\\bowtie", true);
      defineSymbol2(math2, main2, rel2, "\u2323", "\\smile", true);
      defineSymbol2(math2, main2, rel2, "\u2291", "\\sqsubseteq", true);
      defineSymbol2(math2, main2, rel2, "\u2292", "\\sqsupseteq", true);
      defineSymbol2(math2, main2, rel2, "\u2250", "\\doteq", true);
      defineSymbol2(math2, main2, rel2, "\u2322", "\\frown", true);
      defineSymbol2(math2, main2, rel2, "\u220B", "\\ni", true);
      defineSymbol2(math2, main2, rel2, "\u221D", "\\propto", true);
      defineSymbol2(math2, main2, rel2, "\u22A2", "\\vdash", true);
      defineSymbol2(math2, main2, rel2, "\u22A3", "\\dashv", true);
      defineSymbol2(math2, main2, rel2, "\u220B", "\\owns");
      defineSymbol2(math2, main2, punct2, ".", "\\ldotp");
      defineSymbol2(math2, main2, punct2, "\u22C5", "\\cdotp");
      defineSymbol2(math2, main2, textord2, "#", "\\#");
      defineSymbol2(symbols_text, main2, textord2, "#", "\\#");
      defineSymbol2(math2, main2, textord2, "&", "\\&");
      defineSymbol2(symbols_text, main2, textord2, "&", "\\&");
      defineSymbol2(math2, main2, textord2, "\u2135", "\\aleph", true);
      defineSymbol2(math2, main2, textord2, "\u2200", "\\forall", true);
      defineSymbol2(math2, main2, textord2, "\u210F", "\\hbar", true);
      defineSymbol2(math2, main2, textord2, "\u2203", "\\exists", true);
      defineSymbol2(math2, main2, textord2, "\u2207", "\\nabla", true);
      defineSymbol2(math2, main2, textord2, "\u266D", "\\flat", true);
      defineSymbol2(math2, main2, textord2, "\u2113", "\\ell", true);
      defineSymbol2(math2, main2, textord2, "\u266E", "\\natural", true);
      defineSymbol2(math2, main2, textord2, "\u2663", "\\clubsuit", true);
      defineSymbol2(math2, main2, textord2, "\u2118", "\\wp", true);
      defineSymbol2(math2, main2, textord2, "\u266F", "\\sharp", true);
      defineSymbol2(math2, main2, textord2, "\u2662", "\\diamondsuit", true);
      defineSymbol2(math2, main2, textord2, "\u211C", "\\Re", true);
      defineSymbol2(math2, main2, textord2, "\u2661", "\\heartsuit", true);
      defineSymbol2(math2, main2, textord2, "\u2111", "\\Im", true);
      defineSymbol2(math2, main2, textord2, "\u2660", "\\spadesuit", true);
      defineSymbol2(math2, main2, textord2, "\xA7", "\\S", true);
      defineSymbol2(symbols_text, main2, textord2, "\xA7", "\\S");
      defineSymbol2(math2, main2, textord2, "\xB6", "\\P", true);
      defineSymbol2(symbols_text, main2, textord2, "\xB6", "\\P");
      defineSymbol2(math2, main2, textord2, "\u2020", "\\dag");
      defineSymbol2(symbols_text, main2, textord2, "\u2020", "\\dag");
      defineSymbol2(symbols_text, main2, textord2, "\u2020", "\\textdagger");
      defineSymbol2(math2, main2, textord2, "\u2021", "\\ddag");
      defineSymbol2(symbols_text, main2, textord2, "\u2021", "\\ddag");
      defineSymbol2(symbols_text, main2, textord2, "\u2021", "\\textdaggerdbl");
      defineSymbol2(math2, main2, symbols_close, "\u23B1", "\\rmoustache", true);
      defineSymbol2(math2, main2, symbols_open, "\u23B0", "\\lmoustache", true);
      defineSymbol2(math2, main2, symbols_close, "\u27EF", "\\rgroup", true);
      defineSymbol2(math2, main2, symbols_open, "\u27EE", "\\lgroup", true);
      defineSymbol2(math2, main2, bin2, "\u2213", "\\mp", true);
      defineSymbol2(math2, main2, bin2, "\u2296", "\\ominus", true);
      defineSymbol2(math2, main2, bin2, "\u228E", "\\uplus", true);
      defineSymbol2(math2, main2, bin2, "\u2293", "\\sqcap", true);
      defineSymbol2(math2, main2, bin2, "\u2217", "\\ast");
      defineSymbol2(math2, main2, bin2, "\u2294", "\\sqcup", true);
      defineSymbol2(math2, main2, bin2, "\u25EF", "\\bigcirc", true);
      defineSymbol2(math2, main2, bin2, "\u2219", "\\bullet");
      defineSymbol2(math2, main2, bin2, "\u2021", "\\ddagger");
      defineSymbol2(math2, main2, bin2, "\u2240", "\\wr", true);
      defineSymbol2(math2, main2, bin2, "\u2A3F", "\\amalg");
      defineSymbol2(math2, main2, bin2, "&", "\\And");
      defineSymbol2(math2, main2, rel2, "\u27F5", "\\longleftarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21D0", "\\Leftarrow", true);
      defineSymbol2(math2, main2, rel2, "\u27F8", "\\Longleftarrow", true);
      defineSymbol2(math2, main2, rel2, "\u27F6", "\\longrightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21D2", "\\Rightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u27F9", "\\Longrightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u2194", "\\leftrightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u27F7", "\\longleftrightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21D4", "\\Leftrightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u27FA", "\\Longleftrightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21A6", "\\mapsto", true);
      defineSymbol2(math2, main2, rel2, "\u27FC", "\\longmapsto", true);
      defineSymbol2(math2, main2, rel2, "\u2197", "\\nearrow", true);
      defineSymbol2(math2, main2, rel2, "\u21A9", "\\hookleftarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21AA", "\\hookrightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u2198", "\\searrow", true);
      defineSymbol2(math2, main2, rel2, "\u21BC", "\\leftharpoonup", true);
      defineSymbol2(math2, main2, rel2, "\u21C0", "\\rightharpoonup", true);
      defineSymbol2(math2, main2, rel2, "\u2199", "\\swarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21BD", "\\leftharpoondown", true);
      defineSymbol2(math2, main2, rel2, "\u21C1", "\\rightharpoondown", true);
      defineSymbol2(math2, main2, rel2, "\u2196", "\\nwarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21CC", "\\rightleftharpoons", true);
      defineSymbol2(math2, ams2, rel2, "\u226E", "\\nless", true);
      defineSymbol2(math2, ams2, rel2, "\uE010", "\\@nleqslant");
      defineSymbol2(math2, ams2, rel2, "\uE011", "\\@nleqq");
      defineSymbol2(math2, ams2, rel2, "\u2A87", "\\lneq", true);
      defineSymbol2(math2, ams2, rel2, "\u2268", "\\lneqq", true);
      defineSymbol2(math2, ams2, rel2, "\uE00C", "\\@lvertneqq");
      defineSymbol2(math2, ams2, rel2, "\u22E6", "\\lnsim", true);
      defineSymbol2(math2, ams2, rel2, "\u2A89", "\\lnapprox", true);
      defineSymbol2(math2, ams2, rel2, "\u2280", "\\nprec", true);
      defineSymbol2(math2, ams2, rel2, "\u22E0", "\\npreceq", true);
      defineSymbol2(math2, ams2, rel2, "\u22E8", "\\precnsim", true);
      defineSymbol2(math2, ams2, rel2, "\u2AB9", "\\precnapprox", true);
      defineSymbol2(math2, ams2, rel2, "\u2241", "\\nsim", true);
      defineSymbol2(math2, ams2, rel2, "\uE006", "\\@nshortmid");
      defineSymbol2(math2, ams2, rel2, "\u2224", "\\nmid", true);
      defineSymbol2(math2, ams2, rel2, "\u22AC", "\\nvdash", true);
      defineSymbol2(math2, ams2, rel2, "\u22AD", "\\nvDash", true);
      defineSymbol2(math2, ams2, rel2, "\u22EA", "\\ntriangleleft");
      defineSymbol2(math2, ams2, rel2, "\u22EC", "\\ntrianglelefteq", true);
      defineSymbol2(math2, ams2, rel2, "\u228A", "\\subsetneq", true);
      defineSymbol2(math2, ams2, rel2, "\uE01A", "\\@varsubsetneq");
      defineSymbol2(math2, ams2, rel2, "\u2ACB", "\\subsetneqq", true);
      defineSymbol2(math2, ams2, rel2, "\uE017", "\\@varsubsetneqq");
      defineSymbol2(math2, ams2, rel2, "\u226F", "\\ngtr", true);
      defineSymbol2(math2, ams2, rel2, "\uE00F", "\\@ngeqslant");
      defineSymbol2(math2, ams2, rel2, "\uE00E", "\\@ngeqq");
      defineSymbol2(math2, ams2, rel2, "\u2A88", "\\gneq", true);
      defineSymbol2(math2, ams2, rel2, "\u2269", "\\gneqq", true);
      defineSymbol2(math2, ams2, rel2, "\uE00D", "\\@gvertneqq");
      defineSymbol2(math2, ams2, rel2, "\u22E7", "\\gnsim", true);
      defineSymbol2(math2, ams2, rel2, "\u2A8A", "\\gnapprox", true);
      defineSymbol2(math2, ams2, rel2, "\u2281", "\\nsucc", true);
      defineSymbol2(math2, ams2, rel2, "\u22E1", "\\nsucceq", true);
      defineSymbol2(math2, ams2, rel2, "\u22E9", "\\succnsim", true);
      defineSymbol2(math2, ams2, rel2, "\u2ABA", "\\succnapprox", true);
      defineSymbol2(math2, ams2, rel2, "\u2246", "\\ncong", true);
      defineSymbol2(math2, ams2, rel2, "\uE007", "\\@nshortparallel");
      defineSymbol2(math2, ams2, rel2, "\u2226", "\\nparallel", true);
      defineSymbol2(math2, ams2, rel2, "\u22AF", "\\nVDash", true);
      defineSymbol2(math2, ams2, rel2, "\u22EB", "\\ntriangleright");
      defineSymbol2(math2, ams2, rel2, "\u22ED", "\\ntrianglerighteq", true);
      defineSymbol2(math2, ams2, rel2, "\uE018", "\\@nsupseteqq");
      defineSymbol2(math2, ams2, rel2, "\u228B", "\\supsetneq", true);
      defineSymbol2(math2, ams2, rel2, "\uE01B", "\\@varsupsetneq");
      defineSymbol2(math2, ams2, rel2, "\u2ACC", "\\supsetneqq", true);
      defineSymbol2(math2, ams2, rel2, "\uE019", "\\@varsupsetneqq");
      defineSymbol2(math2, ams2, rel2, "\u22AE", "\\nVdash", true);
      defineSymbol2(math2, ams2, rel2, "\u2AB5", "\\precneqq", true);
      defineSymbol2(math2, ams2, rel2, "\u2AB6", "\\succneqq", true);
      defineSymbol2(math2, ams2, rel2, "\uE016", "\\@nsubseteqq");
      defineSymbol2(math2, ams2, bin2, "\u22B4", "\\unlhd");
      defineSymbol2(math2, ams2, bin2, "\u22B5", "\\unrhd");
      defineSymbol2(math2, ams2, rel2, "\u219A", "\\nleftarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u219B", "\\nrightarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21CD", "\\nLeftarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21CF", "\\nRightarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21AE", "\\nleftrightarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21CE", "\\nLeftrightarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u25B3", "\\vartriangle");
      defineSymbol2(math2, ams2, textord2, "\u210F", "\\hslash");
      defineSymbol2(math2, ams2, textord2, "\u25BD", "\\triangledown");
      defineSymbol2(math2, ams2, textord2, "\u25CA", "\\lozenge");
      defineSymbol2(math2, ams2, textord2, "\u24C8", "\\circledS");
      defineSymbol2(math2, ams2, textord2, "\xAE", "\\circledR");
      defineSymbol2(symbols_text, ams2, textord2, "\xAE", "\\circledR");
      defineSymbol2(math2, ams2, textord2, "\u2221", "\\measuredangle", true);
      defineSymbol2(math2, ams2, textord2, "\u2204", "\\nexists");
      defineSymbol2(math2, ams2, textord2, "\u2127", "\\mho");
      defineSymbol2(math2, ams2, textord2, "\u2132", "\\Finv", true);
      defineSymbol2(math2, ams2, textord2, "\u2141", "\\Game", true);
      defineSymbol2(math2, ams2, textord2, "\u2035", "\\backprime");
      defineSymbol2(math2, ams2, textord2, "\u25B2", "\\blacktriangle");
      defineSymbol2(math2, ams2, textord2, "\u25BC", "\\blacktriangledown");
      defineSymbol2(math2, ams2, textord2, "\u25A0", "\\blacksquare");
      defineSymbol2(math2, ams2, textord2, "\u29EB", "\\blacklozenge");
      defineSymbol2(math2, ams2, textord2, "\u2605", "\\bigstar");
      defineSymbol2(math2, ams2, textord2, "\u2222", "\\sphericalangle", true);
      defineSymbol2(math2, ams2, textord2, "\u2201", "\\complement", true);
      defineSymbol2(math2, ams2, textord2, "\xF0", "\\eth", true);
      defineSymbol2(symbols_text, main2, textord2, "\xF0", "\xF0");
      defineSymbol2(math2, ams2, textord2, "\u2571", "\\diagup");
      defineSymbol2(math2, ams2, textord2, "\u2572", "\\diagdown");
      defineSymbol2(math2, ams2, textord2, "\u25A1", "\\square");
      defineSymbol2(math2, ams2, textord2, "\u25A1", "\\Box");
      defineSymbol2(math2, ams2, textord2, "\u25CA", "\\Diamond");
      defineSymbol2(math2, ams2, textord2, "\xA5", "\\yen", true);
      defineSymbol2(symbols_text, ams2, textord2, "\xA5", "\\yen", true);
      defineSymbol2(math2, ams2, textord2, "\u2713", "\\checkmark", true);
      defineSymbol2(symbols_text, ams2, textord2, "\u2713", "\\checkmark");
      defineSymbol2(math2, ams2, textord2, "\u2136", "\\beth", true);
      defineSymbol2(math2, ams2, textord2, "\u2138", "\\daleth", true);
      defineSymbol2(math2, ams2, textord2, "\u2137", "\\gimel", true);
      defineSymbol2(math2, ams2, textord2, "\u03DD", "\\digamma", true);
      defineSymbol2(math2, ams2, textord2, "\u03F0", "\\varkappa");
      defineSymbol2(math2, ams2, symbols_open, "\u250C", "\\@ulcorner", true);
      defineSymbol2(math2, ams2, symbols_close, "\u2510", "\\@urcorner", true);
      defineSymbol2(math2, ams2, symbols_open, "\u2514", "\\@llcorner", true);
      defineSymbol2(math2, ams2, symbols_close, "\u2518", "\\@lrcorner", true);
      defineSymbol2(math2, ams2, rel2, "\u2266", "\\leqq", true);
      defineSymbol2(math2, ams2, rel2, "\u2A7D", "\\leqslant", true);
      defineSymbol2(math2, ams2, rel2, "\u2A95", "\\eqslantless", true);
      defineSymbol2(math2, ams2, rel2, "\u2272", "\\lesssim", true);
      defineSymbol2(math2, ams2, rel2, "\u2A85", "\\lessapprox", true);
      defineSymbol2(math2, ams2, rel2, "\u224A", "\\approxeq", true);
      defineSymbol2(math2, ams2, bin2, "\u22D6", "\\lessdot");
      defineSymbol2(math2, ams2, rel2, "\u22D8", "\\lll", true);
      defineSymbol2(math2, ams2, rel2, "\u2276", "\\lessgtr", true);
      defineSymbol2(math2, ams2, rel2, "\u22DA", "\\lesseqgtr", true);
      defineSymbol2(math2, ams2, rel2, "\u2A8B", "\\lesseqqgtr", true);
      defineSymbol2(math2, ams2, rel2, "\u2251", "\\doteqdot");
      defineSymbol2(math2, ams2, rel2, "\u2253", "\\risingdotseq", true);
      defineSymbol2(math2, ams2, rel2, "\u2252", "\\fallingdotseq", true);
      defineSymbol2(math2, ams2, rel2, "\u223D", "\\backsim", true);
      defineSymbol2(math2, ams2, rel2, "\u22CD", "\\backsimeq", true);
      defineSymbol2(math2, ams2, rel2, "\u2AC5", "\\subseteqq", true);
      defineSymbol2(math2, ams2, rel2, "\u22D0", "\\Subset", true);
      defineSymbol2(math2, ams2, rel2, "\u228F", "\\sqsubset", true);
      defineSymbol2(math2, ams2, rel2, "\u227C", "\\preccurlyeq", true);
      defineSymbol2(math2, ams2, rel2, "\u22DE", "\\curlyeqprec", true);
      defineSymbol2(math2, ams2, rel2, "\u227E", "\\precsim", true);
      defineSymbol2(math2, ams2, rel2, "\u2AB7", "\\precapprox", true);
      defineSymbol2(math2, ams2, rel2, "\u22B2", "\\vartriangleleft");
      defineSymbol2(math2, ams2, rel2, "\u22B4", "\\trianglelefteq");
      defineSymbol2(math2, ams2, rel2, "\u22A8", "\\vDash", true);
      defineSymbol2(math2, ams2, rel2, "\u22AA", "\\Vvdash", true);
      defineSymbol2(math2, ams2, rel2, "\u2323", "\\smallsmile");
      defineSymbol2(math2, ams2, rel2, "\u2322", "\\smallfrown");
      defineSymbol2(math2, ams2, rel2, "\u224F", "\\bumpeq", true);
      defineSymbol2(math2, ams2, rel2, "\u224E", "\\Bumpeq", true);
      defineSymbol2(math2, ams2, rel2, "\u2267", "\\geqq", true);
      defineSymbol2(math2, ams2, rel2, "\u2A7E", "\\geqslant", true);
      defineSymbol2(math2, ams2, rel2, "\u2A96", "\\eqslantgtr", true);
      defineSymbol2(math2, ams2, rel2, "\u2273", "\\gtrsim", true);
      defineSymbol2(math2, ams2, rel2, "\u2A86", "\\gtrapprox", true);
      defineSymbol2(math2, ams2, bin2, "\u22D7", "\\gtrdot");
      defineSymbol2(math2, ams2, rel2, "\u22D9", "\\ggg", true);
      defineSymbol2(math2, ams2, rel2, "\u2277", "\\gtrless", true);
      defineSymbol2(math2, ams2, rel2, "\u22DB", "\\gtreqless", true);
      defineSymbol2(math2, ams2, rel2, "\u2A8C", "\\gtreqqless", true);
      defineSymbol2(math2, ams2, rel2, "\u2256", "\\eqcirc", true);
      defineSymbol2(math2, ams2, rel2, "\u2257", "\\circeq", true);
      defineSymbol2(math2, ams2, rel2, "\u225C", "\\triangleq", true);
      defineSymbol2(math2, ams2, rel2, "\u223C", "\\thicksim");
      defineSymbol2(math2, ams2, rel2, "\u2248", "\\thickapprox");
      defineSymbol2(math2, ams2, rel2, "\u2AC6", "\\supseteqq", true);
      defineSymbol2(math2, ams2, rel2, "\u22D1", "\\Supset", true);
      defineSymbol2(math2, ams2, rel2, "\u2290", "\\sqsupset", true);
      defineSymbol2(math2, ams2, rel2, "\u227D", "\\succcurlyeq", true);
      defineSymbol2(math2, ams2, rel2, "\u22DF", "\\curlyeqsucc", true);
      defineSymbol2(math2, ams2, rel2, "\u227F", "\\succsim", true);
      defineSymbol2(math2, ams2, rel2, "\u2AB8", "\\succapprox", true);
      defineSymbol2(math2, ams2, rel2, "\u22B3", "\\vartriangleright");
      defineSymbol2(math2, ams2, rel2, "\u22B5", "\\trianglerighteq");
      defineSymbol2(math2, ams2, rel2, "\u22A9", "\\Vdash", true);
      defineSymbol2(math2, ams2, rel2, "\u2223", "\\shortmid");
      defineSymbol2(math2, ams2, rel2, "\u2225", "\\shortparallel");
      defineSymbol2(math2, ams2, rel2, "\u226C", "\\between", true);
      defineSymbol2(math2, ams2, rel2, "\u22D4", "\\pitchfork", true);
      defineSymbol2(math2, ams2, rel2, "\u221D", "\\varpropto");
      defineSymbol2(math2, ams2, rel2, "\u25C0", "\\blacktriangleleft");
      defineSymbol2(math2, ams2, rel2, "\u2234", "\\therefore", true);
      defineSymbol2(math2, ams2, rel2, "\u220D", "\\backepsilon");
      defineSymbol2(math2, ams2, rel2, "\u25B6", "\\blacktriangleright");
      defineSymbol2(math2, ams2, rel2, "\u2235", "\\because", true);
      defineSymbol2(math2, ams2, rel2, "\u22D8", "\\llless");
      defineSymbol2(math2, ams2, rel2, "\u22D9", "\\gggtr");
      defineSymbol2(math2, ams2, bin2, "\u22B2", "\\lhd");
      defineSymbol2(math2, ams2, bin2, "\u22B3", "\\rhd");
      defineSymbol2(math2, ams2, rel2, "\u2242", "\\eqsim", true);
      defineSymbol2(math2, main2, rel2, "\u22C8", "\\Join");
      defineSymbol2(math2, ams2, rel2, "\u2251", "\\Doteq", true);
      defineSymbol2(math2, ams2, bin2, "\u2214", "\\dotplus", true);
      defineSymbol2(math2, ams2, bin2, "\u2216", "\\smallsetminus");
      defineSymbol2(math2, ams2, bin2, "\u22D2", "\\Cap", true);
      defineSymbol2(math2, ams2, bin2, "\u22D3", "\\Cup", true);
      defineSymbol2(math2, ams2, bin2, "\u2A5E", "\\doublebarwedge", true);
      defineSymbol2(math2, ams2, bin2, "\u229F", "\\boxminus", true);
      defineSymbol2(math2, ams2, bin2, "\u229E", "\\boxplus", true);
      defineSymbol2(math2, ams2, bin2, "\u22C7", "\\divideontimes", true);
      defineSymbol2(math2, ams2, bin2, "\u22C9", "\\ltimes", true);
      defineSymbol2(math2, ams2, bin2, "\u22CA", "\\rtimes", true);
      defineSymbol2(math2, ams2, bin2, "\u22CB", "\\leftthreetimes", true);
      defineSymbol2(math2, ams2, bin2, "\u22CC", "\\rightthreetimes", true);
      defineSymbol2(math2, ams2, bin2, "\u22CF", "\\curlywedge", true);
      defineSymbol2(math2, ams2, bin2, "\u22CE", "\\curlyvee", true);
      defineSymbol2(math2, ams2, bin2, "\u229D", "\\circleddash", true);
      defineSymbol2(math2, ams2, bin2, "\u229B", "\\circledast", true);
      defineSymbol2(math2, ams2, bin2, "\u22C5", "\\centerdot");
      defineSymbol2(math2, ams2, bin2, "\u22BA", "\\intercal", true);
      defineSymbol2(math2, ams2, bin2, "\u22D2", "\\doublecap");
      defineSymbol2(math2, ams2, bin2, "\u22D3", "\\doublecup");
      defineSymbol2(math2, ams2, bin2, "\u22A0", "\\boxtimes", true);
      defineSymbol2(math2, ams2, rel2, "\u21E2", "\\dashrightarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21E0", "\\dashleftarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21C7", "\\leftleftarrows", true);
      defineSymbol2(math2, ams2, rel2, "\u21C6", "\\leftrightarrows", true);
      defineSymbol2(math2, ams2, rel2, "\u21DA", "\\Lleftarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u219E", "\\twoheadleftarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21A2", "\\leftarrowtail", true);
      defineSymbol2(math2, ams2, rel2, "\u21AB", "\\looparrowleft", true);
      defineSymbol2(math2, ams2, rel2, "\u21CB", "\\leftrightharpoons", true);
      defineSymbol2(math2, ams2, rel2, "\u21B6", "\\curvearrowleft", true);
      defineSymbol2(math2, ams2, rel2, "\u21BA", "\\circlearrowleft", true);
      defineSymbol2(math2, ams2, rel2, "\u21B0", "\\Lsh", true);
      defineSymbol2(math2, ams2, rel2, "\u21C8", "\\upuparrows", true);
      defineSymbol2(math2, ams2, rel2, "\u21BF", "\\upharpoonleft", true);
      defineSymbol2(math2, ams2, rel2, "\u21C3", "\\downharpoonleft", true);
      defineSymbol2(math2, main2, rel2, "\u22B6", "\\origof", true);
      defineSymbol2(math2, main2, rel2, "\u22B7", "\\imageof", true);
      defineSymbol2(math2, ams2, rel2, "\u22B8", "\\multimap", true);
      defineSymbol2(math2, ams2, rel2, "\u21AD", "\\leftrightsquigarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21C9", "\\rightrightarrows", true);
      defineSymbol2(math2, ams2, rel2, "\u21C4", "\\rightleftarrows", true);
      defineSymbol2(math2, ams2, rel2, "\u21A0", "\\twoheadrightarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21A3", "\\rightarrowtail", true);
      defineSymbol2(math2, ams2, rel2, "\u21AC", "\\looparrowright", true);
      defineSymbol2(math2, ams2, rel2, "\u21B7", "\\curvearrowright", true);
      defineSymbol2(math2, ams2, rel2, "\u21BB", "\\circlearrowright", true);
      defineSymbol2(math2, ams2, rel2, "\u21B1", "\\Rsh", true);
      defineSymbol2(math2, ams2, rel2, "\u21CA", "\\downdownarrows", true);
      defineSymbol2(math2, ams2, rel2, "\u21BE", "\\upharpoonright", true);
      defineSymbol2(math2, ams2, rel2, "\u21C2", "\\downharpoonright", true);
      defineSymbol2(math2, ams2, rel2, "\u21DD", "\\rightsquigarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21DD", "\\leadsto");
      defineSymbol2(math2, ams2, rel2, "\u21DB", "\\Rrightarrow", true);
      defineSymbol2(math2, ams2, rel2, "\u21BE", "\\restriction");
      defineSymbol2(math2, main2, textord2, "\u2018", "`");
      defineSymbol2(math2, main2, textord2, "$", "\\$");
      defineSymbol2(symbols_text, main2, textord2, "$", "\\$");
      defineSymbol2(symbols_text, main2, textord2, "$", "\\textdollar");
      defineSymbol2(math2, main2, textord2, "%", "\\%");
      defineSymbol2(symbols_text, main2, textord2, "%", "\\%");
      defineSymbol2(math2, main2, textord2, "_", "\\_");
      defineSymbol2(symbols_text, main2, textord2, "_", "\\_");
      defineSymbol2(symbols_text, main2, textord2, "_", "\\textunderscore");
      defineSymbol2(math2, main2, textord2, "\u2220", "\\angle", true);
      defineSymbol2(math2, main2, textord2, "\u221E", "\\infty", true);
      defineSymbol2(math2, main2, textord2, "\u2032", "\\prime");
      defineSymbol2(math2, main2, textord2, "\u25B3", "\\triangle");
      defineSymbol2(math2, main2, textord2, "\u0393", "\\Gamma", true);
      defineSymbol2(math2, main2, textord2, "\u0394", "\\Delta", true);
      defineSymbol2(math2, main2, textord2, "\u0398", "\\Theta", true);
      defineSymbol2(math2, main2, textord2, "\u039B", "\\Lambda", true);
      defineSymbol2(math2, main2, textord2, "\u039E", "\\Xi", true);
      defineSymbol2(math2, main2, textord2, "\u03A0", "\\Pi", true);
      defineSymbol2(math2, main2, textord2, "\u03A3", "\\Sigma", true);
      defineSymbol2(math2, main2, textord2, "\u03A5", "\\Upsilon", true);
      defineSymbol2(math2, main2, textord2, "\u03A6", "\\Phi", true);
      defineSymbol2(math2, main2, textord2, "\u03A8", "\\Psi", true);
      defineSymbol2(math2, main2, textord2, "\u03A9", "\\Omega", true);
      defineSymbol2(math2, main2, textord2, "A", "\u0391");
      defineSymbol2(math2, main2, textord2, "B", "\u0392");
      defineSymbol2(math2, main2, textord2, "E", "\u0395");
      defineSymbol2(math2, main2, textord2, "Z", "\u0396");
      defineSymbol2(math2, main2, textord2, "H", "\u0397");
      defineSymbol2(math2, main2, textord2, "I", "\u0399");
      defineSymbol2(math2, main2, textord2, "K", "\u039A");
      defineSymbol2(math2, main2, textord2, "M", "\u039C");
      defineSymbol2(math2, main2, textord2, "N", "\u039D");
      defineSymbol2(math2, main2, textord2, "O", "\u039F");
      defineSymbol2(math2, main2, textord2, "P", "\u03A1");
      defineSymbol2(math2, main2, textord2, "T", "\u03A4");
      defineSymbol2(math2, main2, textord2, "X", "\u03A7");
      defineSymbol2(math2, main2, textord2, "\xAC", "\\neg", true);
      defineSymbol2(math2, main2, textord2, "\xAC", "\\lnot");
      defineSymbol2(math2, main2, textord2, "\u22A4", "\\top");
      defineSymbol2(math2, main2, textord2, "\u22A5", "\\bot");
      defineSymbol2(math2, main2, textord2, "\u2205", "\\emptyset");
      defineSymbol2(math2, ams2, textord2, "\u2205", "\\varnothing");
      defineSymbol2(math2, main2, mathord2, "\u03B1", "\\alpha", true);
      defineSymbol2(math2, main2, mathord2, "\u03B2", "\\beta", true);
      defineSymbol2(math2, main2, mathord2, "\u03B3", "\\gamma", true);
      defineSymbol2(math2, main2, mathord2, "\u03B4", "\\delta", true);
      defineSymbol2(math2, main2, mathord2, "\u03F5", "\\epsilon", true);
      defineSymbol2(math2, main2, mathord2, "\u03B6", "\\zeta", true);
      defineSymbol2(math2, main2, mathord2, "\u03B7", "\\eta", true);
      defineSymbol2(math2, main2, mathord2, "\u03B8", "\\theta", true);
      defineSymbol2(math2, main2, mathord2, "\u03B9", "\\iota", true);
      defineSymbol2(math2, main2, mathord2, "\u03BA", "\\kappa", true);
      defineSymbol2(math2, main2, mathord2, "\u03BB", "\\lambda", true);
      defineSymbol2(math2, main2, mathord2, "\u03BC", "\\mu", true);
      defineSymbol2(math2, main2, mathord2, "\u03BD", "\\nu", true);
      defineSymbol2(math2, main2, mathord2, "\u03BE", "\\xi", true);
      defineSymbol2(math2, main2, mathord2, "\u03BF", "\\omicron", true);
      defineSymbol2(math2, main2, mathord2, "\u03C0", "\\pi", true);
      defineSymbol2(math2, main2, mathord2, "\u03C1", "\\rho", true);
      defineSymbol2(math2, main2, mathord2, "\u03C3", "\\sigma", true);
      defineSymbol2(math2, main2, mathord2, "\u03C4", "\\tau", true);
      defineSymbol2(math2, main2, mathord2, "\u03C5", "\\upsilon", true);
      defineSymbol2(math2, main2, mathord2, "\u03D5", "\\phi", true);
      defineSymbol2(math2, main2, mathord2, "\u03C7", "\\chi", true);
      defineSymbol2(math2, main2, mathord2, "\u03C8", "\\psi", true);
      defineSymbol2(math2, main2, mathord2, "\u03C9", "\\omega", true);
      defineSymbol2(math2, main2, mathord2, "\u03B5", "\\varepsilon", true);
      defineSymbol2(math2, main2, mathord2, "\u03D1", "\\vartheta", true);
      defineSymbol2(math2, main2, mathord2, "\u03D6", "\\varpi", true);
      defineSymbol2(math2, main2, mathord2, "\u03F1", "\\varrho", true);
      defineSymbol2(math2, main2, mathord2, "\u03C2", "\\varsigma", true);
      defineSymbol2(math2, main2, mathord2, "\u03C6", "\\varphi", true);
      defineSymbol2(math2, main2, bin2, "\u2217", "*", true);
      defineSymbol2(math2, main2, bin2, "+", "+");
      defineSymbol2(math2, main2, bin2, "\u2212", "-", true);
      defineSymbol2(math2, main2, bin2, "\u22C5", "\\cdot", true);
      defineSymbol2(math2, main2, bin2, "\u2218", "\\circ");
      defineSymbol2(math2, main2, bin2, "\xF7", "\\div", true);
      defineSymbol2(math2, main2, bin2, "\xB1", "\\pm", true);
      defineSymbol2(math2, main2, bin2, "\xD7", "\\times", true);
      defineSymbol2(math2, main2, bin2, "\u2229", "\\cap", true);
      defineSymbol2(math2, main2, bin2, "\u222A", "\\cup", true);
      defineSymbol2(math2, main2, bin2, "\u2216", "\\setminus");
      defineSymbol2(math2, main2, bin2, "\u2227", "\\land");
      defineSymbol2(math2, main2, bin2, "\u2228", "\\lor");
      defineSymbol2(math2, main2, bin2, "\u2227", "\\wedge", true);
      defineSymbol2(math2, main2, bin2, "\u2228", "\\vee", true);
      defineSymbol2(math2, main2, textord2, "\u221A", "\\surd");
      defineSymbol2(math2, main2, symbols_open, "\u27E8", "\\langle", true);
      defineSymbol2(math2, main2, symbols_open, "\u2223", "\\lvert");
      defineSymbol2(math2, main2, symbols_open, "\u2225", "\\lVert");
      defineSymbol2(math2, main2, symbols_close, "?", "?");
      defineSymbol2(math2, main2, symbols_close, "!", "!");
      defineSymbol2(math2, main2, symbols_close, "\u27E9", "\\rangle", true);
      defineSymbol2(math2, main2, symbols_close, "\u2223", "\\rvert");
      defineSymbol2(math2, main2, symbols_close, "\u2225", "\\rVert");
      defineSymbol2(math2, main2, rel2, "=", "=");
      defineSymbol2(math2, main2, rel2, ":", ":");
      defineSymbol2(math2, main2, rel2, "\u2248", "\\approx", true);
      defineSymbol2(math2, main2, rel2, "\u2245", "\\cong", true);
      defineSymbol2(math2, main2, rel2, "\u2265", "\\ge");
      defineSymbol2(math2, main2, rel2, "\u2265", "\\geq", true);
      defineSymbol2(math2, main2, rel2, "\u2190", "\\gets");
      defineSymbol2(math2, main2, rel2, ">", "\\gt", true);
      defineSymbol2(math2, main2, rel2, "\u2208", "\\in", true);
      defineSymbol2(math2, main2, rel2, "\uE020", "\\@not");
      defineSymbol2(math2, main2, rel2, "\u2282", "\\subset", true);
      defineSymbol2(math2, main2, rel2, "\u2283", "\\supset", true);
      defineSymbol2(math2, main2, rel2, "\u2286", "\\subseteq", true);
      defineSymbol2(math2, main2, rel2, "\u2287", "\\supseteq", true);
      defineSymbol2(math2, ams2, rel2, "\u2288", "\\nsubseteq", true);
      defineSymbol2(math2, ams2, rel2, "\u2289", "\\nsupseteq", true);
      defineSymbol2(math2, main2, rel2, "\u22A8", "\\models");
      defineSymbol2(math2, main2, rel2, "\u2190", "\\leftarrow", true);
      defineSymbol2(math2, main2, rel2, "\u2264", "\\le");
      defineSymbol2(math2, main2, rel2, "\u2264", "\\leq", true);
      defineSymbol2(math2, main2, rel2, "<", "\\lt", true);
      defineSymbol2(math2, main2, rel2, "\u2192", "\\rightarrow", true);
      defineSymbol2(math2, main2, rel2, "\u2192", "\\to");
      defineSymbol2(math2, ams2, rel2, "\u2271", "\\ngeq", true);
      defineSymbol2(math2, ams2, rel2, "\u2270", "\\nleq", true);
      defineSymbol2(math2, main2, spacing2, "\xA0", "\\ ");
      defineSymbol2(math2, main2, spacing2, "\xA0", "\\space");
      defineSymbol2(math2, main2, spacing2, "\xA0", "\\nobreakspace");
      defineSymbol2(symbols_text, main2, spacing2, "\xA0", "\\ ");
      defineSymbol2(symbols_text, main2, spacing2, "\xA0", " ");
      defineSymbol2(symbols_text, main2, spacing2, "\xA0", "\\space");
      defineSymbol2(symbols_text, main2, spacing2, "\xA0", "\\nobreakspace");
      defineSymbol2(math2, main2, spacing2, null, "\\nobreak");
      defineSymbol2(math2, main2, spacing2, null, "\\allowbreak");
      defineSymbol2(math2, main2, punct2, ",", ",");
      defineSymbol2(math2, main2, punct2, ";", ";");
      defineSymbol2(math2, ams2, bin2, "\u22BC", "\\barwedge", true);
      defineSymbol2(math2, ams2, bin2, "\u22BB", "\\veebar", true);
      defineSymbol2(math2, main2, bin2, "\u2299", "\\odot", true);
      defineSymbol2(math2, main2, bin2, "\u2295", "\\oplus", true);
      defineSymbol2(math2, main2, bin2, "\u2297", "\\otimes", true);
      defineSymbol2(math2, main2, textord2, "\u2202", "\\partial", true);
      defineSymbol2(math2, main2, bin2, "\u2298", "\\oslash", true);
      defineSymbol2(math2, ams2, bin2, "\u229A", "\\circledcirc", true);
      defineSymbol2(math2, ams2, bin2, "\u22A1", "\\boxdot", true);
      defineSymbol2(math2, main2, bin2, "\u25B3", "\\bigtriangleup");
      defineSymbol2(math2, main2, bin2, "\u25BD", "\\bigtriangledown");
      defineSymbol2(math2, main2, bin2, "\u2020", "\\dagger");
      defineSymbol2(math2, main2, bin2, "\u22C4", "\\diamond");
      defineSymbol2(math2, main2, bin2, "\u22C6", "\\star");
      defineSymbol2(math2, main2, bin2, "\u25C3", "\\triangleleft");
      defineSymbol2(math2, main2, bin2, "\u25B9", "\\triangleright");
      defineSymbol2(math2, main2, symbols_open, "{", "\\{");
      defineSymbol2(symbols_text, main2, textord2, "{", "\\{");
      defineSymbol2(symbols_text, main2, textord2, "{", "\\textbraceleft");
      defineSymbol2(math2, main2, symbols_close, "}", "\\}");
      defineSymbol2(symbols_text, main2, textord2, "}", "\\}");
      defineSymbol2(symbols_text, main2, textord2, "}", "\\textbraceright");
      defineSymbol2(math2, main2, symbols_open, "{", "\\lbrace");
      defineSymbol2(math2, main2, symbols_close, "}", "\\rbrace");
      defineSymbol2(math2, main2, symbols_open, "[", "\\lbrack", true);
      defineSymbol2(symbols_text, main2, textord2, "[", "\\lbrack", true);
      defineSymbol2(math2, main2, symbols_close, "]", "\\rbrack", true);
      defineSymbol2(symbols_text, main2, textord2, "]", "\\rbrack", true);
      defineSymbol2(math2, main2, symbols_open, "(", "\\lparen", true);
      defineSymbol2(math2, main2, symbols_close, ")", "\\rparen", true);
      defineSymbol2(symbols_text, main2, textord2, "<", "\\textless", true);
      defineSymbol2(symbols_text, main2, textord2, ">", "\\textgreater", true);
      defineSymbol2(math2, main2, symbols_open, "\u230A", "\\lfloor", true);
      defineSymbol2(math2, main2, symbols_close, "\u230B", "\\rfloor", true);
      defineSymbol2(math2, main2, symbols_open, "\u2308", "\\lceil", true);
      defineSymbol2(math2, main2, symbols_close, "\u2309", "\\rceil", true);
      defineSymbol2(math2, main2, textord2, "\\", "\\backslash");
      defineSymbol2(math2, main2, textord2, "\u2223", "|");
      defineSymbol2(math2, main2, textord2, "\u2223", "\\vert");
      defineSymbol2(symbols_text, main2, textord2, "|", "\\textbar", true);
      defineSymbol2(math2, main2, textord2, "\u2225", "\\|");
      defineSymbol2(math2, main2, textord2, "\u2225", "\\Vert");
      defineSymbol2(symbols_text, main2, textord2, "\u2225", "\\textbardbl");
      defineSymbol2(symbols_text, main2, textord2, "~", "\\textasciitilde");
      defineSymbol2(symbols_text, main2, textord2, "\\", "\\textbackslash");
      defineSymbol2(symbols_text, main2, textord2, "^", "\\textasciicircum");
      defineSymbol2(math2, main2, rel2, "\u2191", "\\uparrow", true);
      defineSymbol2(math2, main2, rel2, "\u21D1", "\\Uparrow", true);
      defineSymbol2(math2, main2, rel2, "\u2193", "\\downarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21D3", "\\Downarrow", true);
      defineSymbol2(math2, main2, rel2, "\u2195", "\\updownarrow", true);
      defineSymbol2(math2, main2, rel2, "\u21D5", "\\Updownarrow", true);
      defineSymbol2(math2, main2, op2, "\u2210", "\\coprod");
      defineSymbol2(math2, main2, op2, "\u22C1", "\\bigvee");
      defineSymbol2(math2, main2, op2, "\u22C0", "\\bigwedge");
      defineSymbol2(math2, main2, op2, "\u2A04", "\\biguplus");
      defineSymbol2(math2, main2, op2, "\u22C2", "\\bigcap");
      defineSymbol2(math2, main2, op2, "\u22C3", "\\bigcup");
      defineSymbol2(math2, main2, op2, "\u222B", "\\int");
      defineSymbol2(math2, main2, op2, "\u222B", "\\intop");
      defineSymbol2(math2, main2, op2, "\u222C", "\\iint");
      defineSymbol2(math2, main2, op2, "\u222D", "\\iiint");
      defineSymbol2(math2, main2, op2, "\u220F", "\\prod");
      defineSymbol2(math2, main2, op2, "\u2211", "\\sum");
      defineSymbol2(math2, main2, op2, "\u2A02", "\\bigotimes");
      defineSymbol2(math2, main2, op2, "\u2A01", "\\bigoplus");
      defineSymbol2(math2, main2, op2, "\u2A00", "\\bigodot");
      defineSymbol2(math2, main2, op2, "\u222E", "\\oint");
      defineSymbol2(math2, main2, op2, "\u222F", "\\oiint");
      defineSymbol2(math2, main2, op2, "\u2230", "\\oiiint");
      defineSymbol2(math2, main2, op2, "\u2A06", "\\bigsqcup");
      defineSymbol2(math2, main2, op2, "\u222B", "\\smallint");
      defineSymbol2(symbols_text, main2, inner2, "\u2026", "\\textellipsis");
      defineSymbol2(math2, main2, inner2, "\u2026", "\\mathellipsis");
      defineSymbol2(symbols_text, main2, inner2, "\u2026", "\\ldots", true);
      defineSymbol2(math2, main2, inner2, "\u2026", "\\ldots", true);
      defineSymbol2(math2, main2, inner2, "\u22EF", "\\@cdots", true);
      defineSymbol2(math2, main2, inner2, "\u22F1", "\\ddots", true);
      defineSymbol2(math2, main2, textord2, "\u22EE", "\\varvdots");
      defineSymbol2(math2, main2, accent2, "\u02CA", "\\acute");
      defineSymbol2(math2, main2, accent2, "\u02CB", "\\grave");
      defineSymbol2(math2, main2, accent2, "\xA8", "\\ddot");
      defineSymbol2(math2, main2, accent2, "~", "\\tilde");
      defineSymbol2(math2, main2, accent2, "\u02C9", "\\bar");
      defineSymbol2(math2, main2, accent2, "\u02D8", "\\breve");
      defineSymbol2(math2, main2, accent2, "\u02C7", "\\check");
      defineSymbol2(math2, main2, accent2, "^", "\\hat");
      defineSymbol2(math2, main2, accent2, "\u20D7", "\\vec");
      defineSymbol2(math2, main2, accent2, "\u02D9", "\\dot");
      defineSymbol2(math2, main2, accent2, "\u02DA", "\\mathring");
      defineSymbol2(math2, main2, mathord2, "\uE131", "\\@imath");
      defineSymbol2(math2, main2, mathord2, "\uE237", "\\@jmath");
      defineSymbol2(math2, main2, textord2, "\u0131", "\u0131");
      defineSymbol2(math2, main2, textord2, "\u0237", "\u0237");
      defineSymbol2(symbols_text, main2, textord2, "\u0131", "\\i", true);
      defineSymbol2(symbols_text, main2, textord2, "\u0237", "\\j", true);
      defineSymbol2(symbols_text, main2, textord2, "\xDF", "\\ss", true);
      defineSymbol2(symbols_text, main2, textord2, "\xE6", "\\ae", true);
      defineSymbol2(symbols_text, main2, textord2, "\u0153", "\\oe", true);
      defineSymbol2(symbols_text, main2, textord2, "\xF8", "\\o", true);
      defineSymbol2(symbols_text, main2, textord2, "\xC6", "\\AE", true);
      defineSymbol2(symbols_text, main2, textord2, "\u0152", "\\OE", true);
      defineSymbol2(symbols_text, main2, textord2, "\xD8", "\\O", true);
      defineSymbol2(symbols_text, main2, accent2, "\u02CA", "\\'");
      defineSymbol2(symbols_text, main2, accent2, "\u02CB", "\\`");
      defineSymbol2(symbols_text, main2, accent2, "\u02C6", "\\^");
      defineSymbol2(symbols_text, main2, accent2, "\u02DC", "\\~");
      defineSymbol2(symbols_text, main2, accent2, "\u02C9", "\\=");
      defineSymbol2(symbols_text, main2, accent2, "\u02D8", "\\u");
      defineSymbol2(symbols_text, main2, accent2, "\u02D9", "\\.");
      defineSymbol2(symbols_text, main2, accent2, "\xB8", "\\c");
      defineSymbol2(symbols_text, main2, accent2, "\u02DA", "\\r");
      defineSymbol2(symbols_text, main2, accent2, "\u02C7", "\\v");
      defineSymbol2(symbols_text, main2, accent2, "\xA8", '\\"');
      defineSymbol2(symbols_text, main2, accent2, "\u02DD", "\\H");
      defineSymbol2(symbols_text, main2, accent2, "\u25EF", "\\textcircled");
      var ligatures2 = {
        "--": true,
        "---": true,
        "``": true,
        "''": true
      };
      defineSymbol2(symbols_text, main2, textord2, "\u2013", "--", true);
      defineSymbol2(symbols_text, main2, textord2, "\u2013", "\\textendash");
      defineSymbol2(symbols_text, main2, textord2, "\u2014", "---", true);
      defineSymbol2(symbols_text, main2, textord2, "\u2014", "\\textemdash");
      defineSymbol2(symbols_text, main2, textord2, "\u2018", "`", true);
      defineSymbol2(symbols_text, main2, textord2, "\u2018", "\\textquoteleft");
      defineSymbol2(symbols_text, main2, textord2, "\u2019", "'", true);
      defineSymbol2(symbols_text, main2, textord2, "\u2019", "\\textquoteright");
      defineSymbol2(symbols_text, main2, textord2, "\u201C", "``", true);
      defineSymbol2(symbols_text, main2, textord2, "\u201C", "\\textquotedblleft");
      defineSymbol2(symbols_text, main2, textord2, "\u201D", "''", true);
      defineSymbol2(symbols_text, main2, textord2, "\u201D", "\\textquotedblright");
      defineSymbol2(math2, main2, textord2, "\xB0", "\\degree", true);
      defineSymbol2(symbols_text, main2, textord2, "\xB0", "\\degree");
      defineSymbol2(symbols_text, main2, textord2, "\xB0", "\\textdegree", true);
      defineSymbol2(math2, main2, textord2, "\xA3", "\\pounds");
      defineSymbol2(math2, main2, textord2, "\xA3", "\\mathsterling", true);
      defineSymbol2(symbols_text, main2, textord2, "\xA3", "\\pounds");
      defineSymbol2(symbols_text, main2, textord2, "\xA3", "\\textsterling", true);
      defineSymbol2(math2, ams2, textord2, "\u2720", "\\maltese");
      defineSymbol2(symbols_text, ams2, textord2, "\u2720", "\\maltese");
      var mathTextSymbols2 = '0123456789/@."';
      for (var i2 = 0; i2 < mathTextSymbols2.length; i2++) {
        var ch2 = mathTextSymbols2.charAt(i2);
        defineSymbol2(math2, main2, textord2, ch2, ch2);
      }
      var textSymbols2 = '0123456789!@*()-=+";:?/.,';
      for (var _i6 = 0; _i6 < textSymbols2.length; _i6++) {
        var _ch6 = textSymbols2.charAt(_i6);
        defineSymbol2(symbols_text, main2, textord2, _ch6, _ch6);
      }
      var letters2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      for (var _i22 = 0; _i22 < letters2.length; _i22++) {
        var _ch22 = letters2.charAt(_i22);
        defineSymbol2(math2, main2, mathord2, _ch22, _ch22);
        defineSymbol2(symbols_text, main2, textord2, _ch22, _ch22);
      }
      defineSymbol2(math2, ams2, textord2, "C", "\u2102");
      defineSymbol2(symbols_text, ams2, textord2, "C", "\u2102");
      defineSymbol2(math2, ams2, textord2, "H", "\u210D");
      defineSymbol2(symbols_text, ams2, textord2, "H", "\u210D");
      defineSymbol2(math2, ams2, textord2, "N", "\u2115");
      defineSymbol2(symbols_text, ams2, textord2, "N", "\u2115");
      defineSymbol2(math2, ams2, textord2, "P", "\u2119");
      defineSymbol2(symbols_text, ams2, textord2, "P", "\u2119");
      defineSymbol2(math2, ams2, textord2, "Q", "\u211A");
      defineSymbol2(symbols_text, ams2, textord2, "Q", "\u211A");
      defineSymbol2(math2, ams2, textord2, "R", "\u211D");
      defineSymbol2(symbols_text, ams2, textord2, "R", "\u211D");
      defineSymbol2(math2, ams2, textord2, "Z", "\u2124");
      defineSymbol2(symbols_text, ams2, textord2, "Z", "\u2124");
      defineSymbol2(math2, main2, mathord2, "h", "\u210E");
      defineSymbol2(symbols_text, main2, mathord2, "h", "\u210E");
      var wideChar2 = "";
      for (var _i32 = 0; _i32 < letters2.length; _i32++) {
        var _ch32 = letters2.charAt(_i32);
        wideChar2 = String.fromCharCode(55349, 56320 + _i32);
        defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        wideChar2 = String.fromCharCode(55349, 56372 + _i32);
        defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        wideChar2 = String.fromCharCode(55349, 56424 + _i32);
        defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        wideChar2 = String.fromCharCode(55349, 56580 + _i32);
        defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        wideChar2 = String.fromCharCode(55349, 56736 + _i32);
        defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        wideChar2 = String.fromCharCode(55349, 56788 + _i32);
        defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        wideChar2 = String.fromCharCode(55349, 56840 + _i32);
        defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        wideChar2 = String.fromCharCode(55349, 56944 + _i32);
        defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        if (_i32 < 26) {
          wideChar2 = String.fromCharCode(55349, 56632 + _i32);
          defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
          defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
          wideChar2 = String.fromCharCode(55349, 56476 + _i32);
          defineSymbol2(math2, main2, mathord2, _ch32, wideChar2);
          defineSymbol2(symbols_text, main2, textord2, _ch32, wideChar2);
        }
      }
      wideChar2 = String.fromCharCode(55349, 56668);
      defineSymbol2(math2, main2, mathord2, "k", wideChar2);
      defineSymbol2(symbols_text, main2, textord2, "k", wideChar2);
      for (var _i42 = 0; _i42 < 10; _i42++) {
        var _ch42 = _i42.toString();
        wideChar2 = String.fromCharCode(55349, 57294 + _i42);
        defineSymbol2(math2, main2, mathord2, _ch42, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch42, wideChar2);
        wideChar2 = String.fromCharCode(55349, 57314 + _i42);
        defineSymbol2(math2, main2, mathord2, _ch42, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch42, wideChar2);
        wideChar2 = String.fromCharCode(55349, 57324 + _i42);
        defineSymbol2(math2, main2, mathord2, _ch42, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch42, wideChar2);
        wideChar2 = String.fromCharCode(55349, 57334 + _i42);
        defineSymbol2(math2, main2, mathord2, _ch42, wideChar2);
        defineSymbol2(symbols_text, main2, textord2, _ch42, wideChar2);
      }
      var extraLatin2 = "\xD0\xDE\xFE";
      for (var _i52 = 0; _i52 < extraLatin2.length; _i52++) {
        var _ch52 = extraLatin2.charAt(_i52);
        defineSymbol2(math2, main2, mathord2, _ch52, _ch52);
        defineSymbol2(symbols_text, main2, textord2, _ch52, _ch52);
      }
      var wideLatinLetterData2 = [
        ["mathbf", "textbf", "Main-Bold"],
        ["mathbf", "textbf", "Main-Bold"],
        ["mathnormal", "textit", "Math-Italic"],
        ["mathnormal", "textit", "Math-Italic"],
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        ["mathscr", "textscr", "Script-Regular"],
        ["", "", ""],
        ["", "", ""],
        ["", "", ""],
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        ["mathbb", "textbb", "AMS-Regular"],
        ["mathbb", "textbb", "AMS-Regular"],
        ["", "", ""],
        ["", "", ""],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        ["", "", ""],
        ["", "", ""],
        ["mathtt", "texttt", "Typewriter-Regular"],
        ["mathtt", "texttt", "Typewriter-Regular"]
      ];
      var wideNumeralData2 = [
        ["mathbf", "textbf", "Main-Bold"],
        ["", "", ""],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathtt", "texttt", "Typewriter-Regular"]
      ];
      var wideCharacterFont3 = function wideCharacterFont4(wideChar3, mode) {
        var H2 = wideChar3.charCodeAt(0);
        var L2 = wideChar3.charCodeAt(1);
        var codePoint = (H2 - 55296) * 1024 + (L2 - 56320) + 65536;
        var j2 = mode === "math" ? 0 : 1;
        if (119808 <= codePoint && codePoint < 120484) {
          var i3 = Math.floor((codePoint - 119808) / 26);
          return [wideLatinLetterData2[i3][2], wideLatinLetterData2[i3][j2]];
        } else if (120782 <= codePoint && codePoint <= 120831) {
          var _i7 = Math.floor((codePoint - 120782) / 10);
          return [wideNumeralData2[_i7][2], wideNumeralData2[_i7][j2]];
        } else if (codePoint === 120485 || codePoint === 120486) {
          return [wideLatinLetterData2[0][2], wideLatinLetterData2[0][j2]];
        } else if (120486 < codePoint && codePoint < 120782) {
          return ["", ""];
        } else {
          throw new src_ParseError("Unsupported character: " + wideChar3);
        }
      };
      var lookupSymbol3 = function lookupSymbol4(value, fontName, mode) {
        if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
          value = src_symbols[mode][value].replace;
        }
        return {
          value,
          metrics: getCharacterMetrics2(value, fontName, mode)
        };
      };
      var makeSymbol3 = function makeSymbol4(value, fontName, mode, options2, classes) {
        var lookup = lookupSymbol3(value, fontName, mode);
        var metrics = lookup.metrics;
        value = lookup.value;
        var symbolNode;
        if (metrics) {
          var italic = metrics.italic;
          if (mode === "text" || options2 && options2.font === "mathit") {
            italic = 0;
          }
          symbolNode = new SymbolNode2(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
        } else {
          typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
          symbolNode = new SymbolNode2(value, 0, 0, 0, 0, 0, classes);
        }
        if (options2) {
          symbolNode.maxFontSize = options2.sizeMultiplier;
          if (options2.style.isTight()) {
            symbolNode.classes.push("mtight");
          }
          var color = options2.getColor();
          if (color) {
            symbolNode.style.color = color;
          }
        }
        return symbolNode;
      };
      var mathsym3 = function mathsym4(value, mode, options2, classes) {
        if (classes === void 0) {
          classes = [];
        }
        if (options2.font === "boldsymbol" && lookupSymbol3(value, "Main-Bold", mode).metrics) {
          return makeSymbol3(value, "Main-Bold", mode, options2, classes.concat(["mathbf"]));
        } else if (value === "\\" || src_symbols[mode][value].font === "main") {
          return makeSymbol3(value, "Main-Regular", mode, options2, classes);
        } else {
          return makeSymbol3(value, "AMS-Regular", mode, options2, classes.concat(["amsrm"]));
        }
      };
      var boldsymbol3 = function boldsymbol4(value, mode, options2, classes, type) {
        if (type !== "textord" && lookupSymbol3(value, "Math-BoldItalic", mode).metrics) {
          return {
            fontName: "Math-BoldItalic",
            fontClass: "boldsymbol"
          };
        } else {
          return {
            fontName: "Main-Bold",
            fontClass: "mathbf"
          };
        }
      };
      var makeOrd3 = function makeOrd4(group, options2, type) {
        var mode = group.mode;
        var text2 = group.text;
        var classes = ["mord"];
        var isFont = mode === "math" || mode === "text" && options2.font;
        var fontOrFamily = isFont ? options2.font : options2.fontFamily;
        if (text2.charCodeAt(0) === 55349) {
          var _wideCharacterFont = wideCharacterFont3(text2, mode), wideFontName = _wideCharacterFont[0], wideFontClass = _wideCharacterFont[1];
          return makeSymbol3(text2, wideFontName, mode, options2, classes.concat(wideFontClass));
        } else if (fontOrFamily) {
          var fontName;
          var fontClasses;
          if (fontOrFamily === "boldsymbol") {
            var fontData = boldsymbol3(text2, mode, options2, classes, type);
            fontName = fontData.fontName;
            fontClasses = [fontData.fontClass];
          } else if (isFont) {
            fontName = fontMap2[fontOrFamily].fontName;
            fontClasses = [fontOrFamily];
          } else {
            fontName = retrieveTextFontName3(fontOrFamily, options2.fontWeight, options2.fontShape);
            fontClasses = [fontOrFamily, options2.fontWeight, options2.fontShape];
          }
          if (lookupSymbol3(text2, fontName, mode).metrics) {
            return makeSymbol3(text2, fontName, mode, options2, classes.concat(fontClasses));
          } else if (ligatures2.hasOwnProperty(text2) && fontName.substr(0, 10) === "Typewriter") {
            var parts = [];
            for (var i3 = 0; i3 < text2.length; i3++) {
              parts.push(makeSymbol3(text2[i3], fontName, mode, options2, classes.concat(fontClasses)));
            }
            return makeFragment3(parts);
          }
        }
        if (type === "mathord") {
          return makeSymbol3(text2, "Math-Italic", mode, options2, classes.concat(["mathnormal"]));
        } else if (type === "textord") {
          var font = src_symbols[mode][text2] && src_symbols[mode][text2].font;
          if (font === "ams") {
            var _fontName = retrieveTextFontName3("amsrm", options2.fontWeight, options2.fontShape);
            return makeSymbol3(text2, _fontName, mode, options2, classes.concat("amsrm", options2.fontWeight, options2.fontShape));
          } else if (font === "main" || !font) {
            var _fontName2 = retrieveTextFontName3("textrm", options2.fontWeight, options2.fontShape);
            return makeSymbol3(text2, _fontName2, mode, options2, classes.concat(options2.fontWeight, options2.fontShape));
          } else {
            var _fontName3 = retrieveTextFontName3(font, options2.fontWeight, options2.fontShape);
            return makeSymbol3(text2, _fontName3, mode, options2, classes.concat(_fontName3, options2.fontWeight, options2.fontShape));
          }
        } else {
          throw new Error("unexpected type: " + type + " in makeOrd");
        }
      };
      var canCombine2 = function canCombine3(prev, next) {
        if (createClass3(prev.classes) !== createClass3(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
          return false;
        }
        if (prev.classes.length === 1) {
          var cls = prev.classes[0];
          if (cls === "mbin" || cls === "mord") {
            return false;
          }
        }
        for (var style in prev.style) {
          if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
            return false;
          }
        }
        for (var _style in next.style) {
          if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
            return false;
          }
        }
        return true;
      };
      var tryCombineChars2 = function tryCombineChars3(chars) {
        for (var i3 = 0; i3 < chars.length - 1; i3++) {
          var prev = chars[i3];
          var next = chars[i3 + 1];
          if (prev instanceof SymbolNode2 && next instanceof SymbolNode2 && canCombine2(prev, next)) {
            prev.text += next.text;
            prev.height = Math.max(prev.height, next.height);
            prev.depth = Math.max(prev.depth, next.depth);
            prev.italic = next.italic;
            chars.splice(i3 + 1, 1);
            i3--;
          }
        }
        return chars;
      };
      var sizeElementFromChildren3 = function sizeElementFromChildren4(elem) {
        var height = 0;
        var depth = 0;
        var maxFontSize = 0;
        for (var i3 = 0; i3 < elem.children.length; i3++) {
          var child = elem.children[i3];
          if (child.height > height) {
            height = child.height;
          }
          if (child.depth > depth) {
            depth = child.depth;
          }
          if (child.maxFontSize > maxFontSize) {
            maxFontSize = child.maxFontSize;
          }
        }
        elem.height = height;
        elem.depth = depth;
        elem.maxFontSize = maxFontSize;
      };
      var makeSpan3 = function makeSpan4(classes, children, options2, style) {
        var span = new Span2(classes, children, options2, style);
        sizeElementFromChildren3(span);
        return span;
      };
      var makeSvgSpan2 = function makeSvgSpan3(classes, children, options2, style) {
        return new Span2(classes, children, options2, style);
      };
      var makeLineSpan3 = function makeLineSpan4(className, options2, thickness) {
        var line = makeSpan3([className], [], options2);
        line.height = Math.max(thickness || options2.fontMetrics().defaultRuleThickness, options2.minRuleThickness);
        line.style.borderBottomWidth = makeEm3(line.height);
        line.maxFontSize = 1;
        return line;
      };
      var makeAnchor3 = function makeAnchor4(href, classes, children, options2) {
        var anchor = new Anchor2(href, classes, children, options2);
        sizeElementFromChildren3(anchor);
        return anchor;
      };
      var makeFragment3 = function makeFragment4(children) {
        var fragment = new DocumentFragment2(children);
        sizeElementFromChildren3(fragment);
        return fragment;
      };
      var wrapFragment3 = function wrapFragment4(group, options2) {
        if (group instanceof DocumentFragment2) {
          return makeSpan3([], [group], options2);
        }
        return group;
      };
      var getVListChildrenAndDepth3 = function getVListChildrenAndDepth4(params) {
        if (params.positionType === "individualShift") {
          var oldChildren = params.children;
          var children = [oldChildren[0]];
          var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
          var currPos = _depth;
          for (var i3 = 1; i3 < oldChildren.length; i3++) {
            var diff = -oldChildren[i3].shift - currPos - oldChildren[i3].elem.depth;
            var size = diff - (oldChildren[i3 - 1].elem.height + oldChildren[i3 - 1].elem.depth);
            currPos = currPos + diff;
            children.push({
              type: "kern",
              size
            });
            children.push(oldChildren[i3]);
          }
          return {
            children,
            depth: _depth
          };
        }
        var depth;
        if (params.positionType === "top") {
          var bottom = params.positionData;
          for (var _i7 = 0; _i7 < params.children.length; _i7++) {
            var child = params.children[_i7];
            bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
          }
          depth = bottom;
        } else if (params.positionType === "bottom") {
          depth = -params.positionData;
        } else {
          var firstChild = params.children[0];
          if (firstChild.type !== "elem") {
            throw new Error('First child must have type "elem".');
          }
          if (params.positionType === "shift") {
            depth = -firstChild.elem.depth - params.positionData;
          } else if (params.positionType === "firstBaseline") {
            depth = -firstChild.elem.depth;
          } else {
            throw new Error("Invalid positionType " + params.positionType + ".");
          }
        }
        return {
          children: params.children,
          depth
        };
      };
      var makeVList3 = function makeVList4(params, options2) {
        var _getVListChildrenAndD = getVListChildrenAndDepth3(params), children = _getVListChildrenAndD.children, depth = _getVListChildrenAndD.depth;
        var pstrutSize = 0;
        for (var i3 = 0; i3 < children.length; i3++) {
          var child = children[i3];
          if (child.type === "elem") {
            var elem = child.elem;
            pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
          }
        }
        pstrutSize += 2;
        var pstrut = makeSpan3(["pstrut"], []);
        pstrut.style.height = makeEm3(pstrutSize);
        var realChildren = [];
        var minPos = depth;
        var maxPos = depth;
        var currPos = depth;
        for (var _i23 = 0; _i23 < children.length; _i23++) {
          var _child = children[_i23];
          if (_child.type === "kern") {
            currPos += _child.size;
          } else {
            var _elem = _child.elem;
            var classes = _child.wrapperClasses || [];
            var style = _child.wrapperStyle || {};
            var childWrap = makeSpan3(classes, [pstrut, _elem], void 0, style);
            childWrap.style.top = makeEm3(-pstrutSize - currPos - _elem.depth);
            if (_child.marginLeft) {
              childWrap.style.marginLeft = _child.marginLeft;
            }
            if (_child.marginRight) {
              childWrap.style.marginRight = _child.marginRight;
            }
            realChildren.push(childWrap);
            currPos += _elem.height + _elem.depth;
          }
          minPos = Math.min(minPos, currPos);
          maxPos = Math.max(maxPos, currPos);
        }
        var vlist = makeSpan3(["vlist"], realChildren);
        vlist.style.height = makeEm3(maxPos);
        var rows;
        if (minPos < 0) {
          var emptySpan = makeSpan3([], []);
          var depthStrut = makeSpan3(["vlist"], [emptySpan]);
          depthStrut.style.height = makeEm3(-minPos);
          var topStrut = makeSpan3(["vlist-s"], [new SymbolNode2("\u200B")]);
          rows = [makeSpan3(["vlist-r"], [vlist, topStrut]), makeSpan3(["vlist-r"], [depthStrut])];
        } else {
          rows = [makeSpan3(["vlist-r"], [vlist])];
        }
        var vtable = makeSpan3(["vlist-t"], rows);
        if (rows.length === 2) {
          vtable.classes.push("vlist-t2");
        }
        vtable.height = maxPos;
        vtable.depth = -minPos;
        return vtable;
      };
      var makeGlue2 = function makeGlue3(measurement, options2) {
        var rule = makeSpan3(["mspace"], [], options2);
        var size = calculateSize3(measurement, options2);
        rule.style.marginRight = makeEm3(size);
        return rule;
      };
      var retrieveTextFontName3 = function retrieveTextFontName4(fontFamily, fontWeight, fontShape) {
        var baseFontName = "";
        switch (fontFamily) {
          case "amsrm":
            baseFontName = "AMS";
            break;
          case "textrm":
            baseFontName = "Main";
            break;
          case "textsf":
            baseFontName = "SansSerif";
            break;
          case "texttt":
            baseFontName = "Typewriter";
            break;
          default:
            baseFontName = fontFamily;
        }
        var fontStylesName;
        if (fontWeight === "textbf" && fontShape === "textit") {
          fontStylesName = "BoldItalic";
        } else if (fontWeight === "textbf") {
          fontStylesName = "Bold";
        } else if (fontWeight === "textit") {
          fontStylesName = "Italic";
        } else {
          fontStylesName = "Regular";
        }
        return baseFontName + "-" + fontStylesName;
      };
      var fontMap2 = {
        "mathbf": {
          variant: "bold",
          fontName: "Main-Bold"
        },
        "mathrm": {
          variant: "normal",
          fontName: "Main-Regular"
        },
        "textit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathnormal": {
          variant: "italic",
          fontName: "Math-Italic"
        },
        "mathbb": {
          variant: "double-struck",
          fontName: "AMS-Regular"
        },
        "mathcal": {
          variant: "script",
          fontName: "Caligraphic-Regular"
        },
        "mathfrak": {
          variant: "fraktur",
          fontName: "Fraktur-Regular"
        },
        "mathscr": {
          variant: "script",
          fontName: "Script-Regular"
        },
        "mathsf": {
          variant: "sans-serif",
          fontName: "SansSerif-Regular"
        },
        "mathtt": {
          variant: "monospace",
          fontName: "Typewriter-Regular"
        }
      };
      var svgData2 = {
        vec: ["vec", 0.471, 0.714],
        oiintSize1: ["oiintSize1", 0.957, 0.499],
        oiintSize2: ["oiintSize2", 1.472, 0.659],
        oiiintSize1: ["oiiintSize1", 1.304, 0.499],
        oiiintSize2: ["oiiintSize2", 1.98, 0.659]
      };
      var staticSvg3 = function staticSvg4(value, options2) {
        var _svgData$value = svgData2[value], pathName = _svgData$value[0], width = _svgData$value[1], height = _svgData$value[2];
        var path3 = new PathNode2(pathName);
        var svgNode = new SvgNode2([path3], {
          "width": makeEm3(width),
          "height": makeEm3(height),
          "style": "width:" + makeEm3(width),
          "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
          "preserveAspectRatio": "xMinYMin"
        });
        var span = makeSvgSpan2(["overlay"], [svgNode], options2);
        span.height = height;
        span.style.height = makeEm3(height);
        span.style.width = makeEm3(width);
        return span;
      };
      var buildCommon2 = {
        fontMap: fontMap2,
        makeSymbol: makeSymbol3,
        mathsym: mathsym3,
        makeSpan: makeSpan3,
        makeSvgSpan: makeSvgSpan2,
        makeLineSpan: makeLineSpan3,
        makeAnchor: makeAnchor3,
        makeFragment: makeFragment3,
        wrapFragment: wrapFragment3,
        makeVList: makeVList3,
        makeOrd: makeOrd3,
        makeGlue: makeGlue2,
        staticSvg: staticSvg3,
        svgData: svgData2,
        tryCombineChars: tryCombineChars2
      };
      var thinspace2 = {
        number: 3,
        unit: "mu"
      };
      var mediumspace2 = {
        number: 4,
        unit: "mu"
      };
      var thickspace2 = {
        number: 5,
        unit: "mu"
      };
      var spacings2 = {
        mord: {
          mop: thinspace2,
          mbin: mediumspace2,
          mrel: thickspace2,
          minner: thinspace2
        },
        mop: {
          mord: thinspace2,
          mop: thinspace2,
          mrel: thickspace2,
          minner: thinspace2
        },
        mbin: {
          mord: mediumspace2,
          mop: mediumspace2,
          mopen: mediumspace2,
          minner: mediumspace2
        },
        mrel: {
          mord: thickspace2,
          mop: thickspace2,
          mopen: thickspace2,
          minner: thickspace2
        },
        mopen: {},
        mclose: {
          mop: thinspace2,
          mbin: mediumspace2,
          mrel: thickspace2,
          minner: thinspace2
        },
        mpunct: {
          mord: thinspace2,
          mop: thinspace2,
          mrel: thickspace2,
          mopen: thinspace2,
          mclose: thinspace2,
          mpunct: thinspace2,
          minner: thinspace2
        },
        minner: {
          mord: thinspace2,
          mop: thinspace2,
          mbin: mediumspace2,
          mrel: thickspace2,
          mopen: thinspace2,
          mpunct: thinspace2,
          minner: thinspace2
        }
      };
      var tightSpacings2 = {
        mord: {
          mop: thinspace2
        },
        mop: {
          mord: thinspace2,
          mop: thinspace2
        },
        mbin: {},
        mrel: {},
        mopen: {},
        mclose: {
          mop: thinspace2
        },
        mpunct: {},
        minner: {
          mop: thinspace2
        }
      };
      var _functions2 = {};
      var _htmlGroupBuilders2 = {};
      var _mathmlGroupBuilders2 = {};
      function defineFunction2(_ref) {
        var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder4 = _ref.htmlBuilder, mathmlBuilder4 = _ref.mathmlBuilder;
        var data2 = {
          type,
          numArgs: props.numArgs,
          argTypes: props.argTypes,
          allowedInArgument: !!props.allowedInArgument,
          allowedInText: !!props.allowedInText,
          allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
          numOptionalArgs: props.numOptionalArgs || 0,
          infix: !!props.infix,
          primitive: !!props.primitive,
          handler
        };
        for (var i3 = 0; i3 < names.length; ++i3) {
          _functions2[names[i3]] = data2;
        }
        if (type) {
          if (htmlBuilder4) {
            _htmlGroupBuilders2[type] = htmlBuilder4;
          }
          if (mathmlBuilder4) {
            _mathmlGroupBuilders2[type] = mathmlBuilder4;
          }
        }
      }
      function defineFunctionBuilders2(_ref2) {
        var type = _ref2.type, htmlBuilder4 = _ref2.htmlBuilder, mathmlBuilder4 = _ref2.mathmlBuilder;
        defineFunction2({
          type,
          names: [],
          props: {
            numArgs: 0
          },
          handler: function handler() {
            throw new Error("Should never be called.");
          },
          htmlBuilder: htmlBuilder4,
          mathmlBuilder: mathmlBuilder4
        });
      }
      var normalizeArgument3 = function normalizeArgument4(arg) {
        return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
      };
      var ordargument3 = function ordargument4(arg) {
        return arg.type === "ordgroup" ? arg.body : [arg];
      };
      var buildHTML_makeSpan = buildCommon2.makeSpan;
      var binLeftCanceller2 = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
      var binRightCanceller2 = ["rightmost", "mrel", "mclose", "mpunct"];
      var styleMap2 = {
        "display": src_Style.DISPLAY,
        "text": src_Style.TEXT,
        "script": src_Style.SCRIPT,
        "scriptscript": src_Style.SCRIPTSCRIPT
      };
      var DomEnum2 = {
        mord: "mord",
        mop: "mop",
        mbin: "mbin",
        mrel: "mrel",
        mopen: "mopen",
        mclose: "mclose",
        mpunct: "mpunct",
        minner: "minner"
      };
      var buildExpression4 = function buildExpression5(expression, options2, isRealGroup, surrounding) {
        if (surrounding === void 0) {
          surrounding = [null, null];
        }
        var groups = [];
        for (var i3 = 0; i3 < expression.length; i3++) {
          var output = buildGroup4(expression[i3], options2);
          if (output instanceof DocumentFragment2) {
            var children = output.children;
            groups.push.apply(groups, children);
          } else {
            groups.push(output);
          }
        }
        buildCommon2.tryCombineChars(groups);
        if (!isRealGroup) {
          return groups;
        }
        var glueOptions = options2;
        if (expression.length === 1) {
          var node = expression[0];
          if (node.type === "sizing") {
            glueOptions = options2.havingSize(node.size);
          } else if (node.type === "styling") {
            glueOptions = options2.havingStyle(styleMap2[node.style]);
          }
        }
        var dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options2);
        var dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options2);
        var isRoot = isRealGroup === "root";
        traverseNonSpaceNodes3(groups, function(node2, prev) {
          var prevType = prev.classes[0];
          var type = node2.classes[0];
          if (prevType === "mbin" && utils2.contains(binRightCanceller2, type)) {
            prev.classes[0] = "mord";
          } else if (type === "mbin" && utils2.contains(binLeftCanceller2, prevType)) {
            node2.classes[0] = "mord";
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        traverseNonSpaceNodes3(groups, function(node2, prev) {
          var prevType = getTypeOfDomTree3(prev);
          var type = getTypeOfDomTree3(node2);
          var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings2[prevType][type] : spacings2[prevType][type] : null;
          if (space) {
            return buildCommon2.makeGlue(space, glueOptions);
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        return groups;
      };
      var traverseNonSpaceNodes3 = function traverseNonSpaceNodes4(nodes, callback, prev, next, isRoot) {
        if (next) {
          nodes.push(next);
        }
        var i3 = 0;
        for (; i3 < nodes.length; i3++) {
          var node = nodes[i3];
          var partialGroup = checkPartialGroup3(node);
          if (partialGroup) {
            traverseNonSpaceNodes4(partialGroup.children, callback, prev, null, isRoot);
            continue;
          }
          var nonspace = !node.hasClass("mspace");
          if (nonspace) {
            var result2 = callback(node, prev.node);
            if (result2) {
              if (prev.insertAfter) {
                prev.insertAfter(result2);
              } else {
                nodes.unshift(result2);
                i3++;
              }
            }
          }
          if (nonspace) {
            prev.node = node;
          } else if (isRoot && node.hasClass("newline")) {
            prev.node = buildHTML_makeSpan(["leftmost"]);
          }
          prev.insertAfter = function(index) {
            return function(n2) {
              nodes.splice(index + 1, 0, n2);
              i3++;
            };
          }(i3);
        }
        if (next) {
          nodes.pop();
        }
      };
      var checkPartialGroup3 = function checkPartialGroup4(node) {
        if (node instanceof DocumentFragment2 || node instanceof Anchor2 || node instanceof Span2 && node.hasClass("enclosing")) {
          return node;
        }
        return null;
      };
      var getOutermostNode3 = function getOutermostNode4(node, side2) {
        var partialGroup = checkPartialGroup3(node);
        if (partialGroup) {
          var children = partialGroup.children;
          if (children.length) {
            if (side2 === "right") {
              return getOutermostNode4(children[children.length - 1], "right");
            } else if (side2 === "left") {
              return getOutermostNode4(children[0], "left");
            }
          }
        }
        return node;
      };
      var getTypeOfDomTree3 = function getTypeOfDomTree4(node, side2) {
        if (!node) {
          return null;
        }
        if (side2) {
          node = getOutermostNode3(node, side2);
        }
        return DomEnum2[node.classes[0]] || null;
      };
      var makeNullDelimiter3 = function makeNullDelimiter4(options2, classes) {
        var moreClasses = ["nulldelimiter"].concat(options2.baseSizingClasses());
        return buildHTML_makeSpan(classes.concat(moreClasses));
      };
      var buildGroup4 = function buildGroup5(group, options2, baseOptions) {
        if (!group) {
          return buildHTML_makeSpan();
        }
        if (_htmlGroupBuilders2[group.type]) {
          var groupNode = _htmlGroupBuilders2[group.type](group, options2);
          if (baseOptions && options2.size !== baseOptions.size) {
            groupNode = buildHTML_makeSpan(options2.sizingClasses(baseOptions), [groupNode], options2);
            var multiplier = options2.sizeMultiplier / baseOptions.sizeMultiplier;
            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
          }
          return groupNode;
        } else {
          throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      function buildHTMLUnbreakable2(children, options2) {
        var body = buildHTML_makeSpan(["base"], children, options2);
        var strut = buildHTML_makeSpan(["strut"]);
        strut.style.height = makeEm3(body.height + body.depth);
        if (body.depth) {
          strut.style.verticalAlign = makeEm3(-body.depth);
        }
        body.children.unshift(strut);
        return body;
      }
      function buildHTML2(tree, options2) {
        var tag2 = null;
        if (tree.length === 1 && tree[0].type === "tag") {
          tag2 = tree[0].tag;
          tree = tree[0].body;
        }
        var expression = buildExpression4(tree, options2, "root");
        var eqnNum;
        if (expression.length === 2 && expression[1].hasClass("tag")) {
          eqnNum = expression.pop();
        }
        var children = [];
        var parts = [];
        for (var i3 = 0; i3 < expression.length; i3++) {
          parts.push(expression[i3]);
          if (expression[i3].hasClass("mbin") || expression[i3].hasClass("mrel") || expression[i3].hasClass("allowbreak")) {
            var nobreak = false;
            while (i3 < expression.length - 1 && expression[i3 + 1].hasClass("mspace") && !expression[i3 + 1].hasClass("newline")) {
              i3++;
              parts.push(expression[i3]);
              if (expression[i3].hasClass("nobreak")) {
                nobreak = true;
              }
            }
            if (!nobreak) {
              children.push(buildHTMLUnbreakable2(parts, options2));
              parts = [];
            }
          } else if (expression[i3].hasClass("newline")) {
            parts.pop();
            if (parts.length > 0) {
              children.push(buildHTMLUnbreakable2(parts, options2));
              parts = [];
            }
            children.push(expression[i3]);
          }
        }
        if (parts.length > 0) {
          children.push(buildHTMLUnbreakable2(parts, options2));
        }
        var tagChild;
        if (tag2) {
          tagChild = buildHTMLUnbreakable2(buildExpression4(tag2, options2, true));
          tagChild.classes = ["tag"];
          children.push(tagChild);
        } else if (eqnNum) {
          children.push(eqnNum);
        }
        var htmlNode = buildHTML_makeSpan(["katex-html"], children);
        htmlNode.setAttribute("aria-hidden", "true");
        if (tagChild) {
          var strut = tagChild.children[0];
          strut.style.height = makeEm3(htmlNode.height + htmlNode.depth);
          if (htmlNode.depth) {
            strut.style.verticalAlign = makeEm3(-htmlNode.depth);
          }
        }
        return htmlNode;
      }
      function newDocumentFragment2(children) {
        return new DocumentFragment2(children);
      }
      var MathNode2 = /* @__PURE__ */ function() {
        function MathNode3(type, children, classes) {
          this.type = void 0;
          this.attributes = void 0;
          this.children = void 0;
          this.classes = void 0;
          this.type = type;
          this.attributes = {};
          this.children = children || [];
          this.classes = classes || [];
        }
        var _proto = MathNode3.prototype;
        _proto.setAttribute = function setAttribute(name, value) {
          this.attributes[name] = value;
        };
        _proto.getAttribute = function getAttribute(name) {
          return this.attributes[name];
        };
        _proto.toNode = function toNode3() {
          var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          if (this.classes.length > 0) {
            node.className = createClass3(this.classes);
          }
          for (var i3 = 0; i3 < this.children.length; i3++) {
            node.appendChild(this.children[i3].toNode());
          }
          return node;
        };
        _proto.toMarkup = function toMarkup3() {
          var markup = "<" + this.type;
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="';
              markup += utils2.escape(this.attributes[attr]);
              markup += '"';
            }
          }
          if (this.classes.length > 0) {
            markup += ' class ="' + utils2.escape(createClass3(this.classes)) + '"';
          }
          markup += ">";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          markup += "</" + this.type + ">";
          return markup;
        };
        _proto.toText = function toText() {
          return this.children.map(function(child) {
            return child.toText();
          }).join("");
        };
        return MathNode3;
      }();
      var TextNode2 = /* @__PURE__ */ function() {
        function TextNode3(text2) {
          this.text = void 0;
          this.text = text2;
        }
        var _proto2 = TextNode3.prototype;
        _proto2.toNode = function toNode3() {
          return document.createTextNode(this.text);
        };
        _proto2.toMarkup = function toMarkup3() {
          return utils2.escape(this.toText());
        };
        _proto2.toText = function toText() {
          return this.text;
        };
        return TextNode3;
      }();
      var SpaceNode2 = /* @__PURE__ */ function() {
        function SpaceNode3(width) {
          this.width = void 0;
          this.character = void 0;
          this.width = width;
          if (width >= 0.05555 && width <= 0.05556) {
            this.character = "\u200A";
          } else if (width >= 0.1666 && width <= 0.1667) {
            this.character = "\u2009";
          } else if (width >= 0.2222 && width <= 0.2223) {
            this.character = "\u2005";
          } else if (width >= 0.2777 && width <= 0.2778) {
            this.character = "\u2005\u200A";
          } else if (width >= -0.05556 && width <= -0.05555) {
            this.character = "\u200A\u2063";
          } else if (width >= -0.1667 && width <= -0.1666) {
            this.character = "\u2009\u2063";
          } else if (width >= -0.2223 && width <= -0.2222) {
            this.character = "\u205F\u2063";
          } else if (width >= -0.2778 && width <= -0.2777) {
            this.character = "\u2005\u2063";
          } else {
            this.character = null;
          }
        }
        var _proto3 = SpaceNode3.prototype;
        _proto3.toNode = function toNode3() {
          if (this.character) {
            return document.createTextNode(this.character);
          } else {
            var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
            node.setAttribute("width", makeEm3(this.width));
            return node;
          }
        };
        _proto3.toMarkup = function toMarkup3() {
          if (this.character) {
            return "<mtext>" + this.character + "</mtext>";
          } else {
            return '<mspace width="' + makeEm3(this.width) + '"/>';
          }
        };
        _proto3.toText = function toText() {
          if (this.character) {
            return this.character;
          } else {
            return " ";
          }
        };
        return SpaceNode3;
      }();
      var mathMLTree2 = {
        MathNode: MathNode2,
        TextNode: TextNode2,
        SpaceNode: SpaceNode2,
        newDocumentFragment: newDocumentFragment2
      };
      var makeText3 = function makeText4(text2, mode, options2) {
        if (src_symbols[mode][text2] && src_symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures2.hasOwnProperty(text2) && options2 && (options2.fontFamily && options2.fontFamily.substr(4, 2) === "tt" || options2.font && options2.font.substr(4, 2) === "tt"))) {
          text2 = src_symbols[mode][text2].replace;
        }
        return new mathMLTree2.TextNode(text2);
      };
      var makeRow3 = function makeRow4(body) {
        if (body.length === 1) {
          return body[0];
        } else {
          return new mathMLTree2.MathNode("mrow", body);
        }
      };
      var getVariant3 = function getVariant4(group, options2) {
        if (options2.fontFamily === "texttt") {
          return "monospace";
        } else if (options2.fontFamily === "textsf") {
          if (options2.fontShape === "textit" && options2.fontWeight === "textbf") {
            return "sans-serif-bold-italic";
          } else if (options2.fontShape === "textit") {
            return "sans-serif-italic";
          } else if (options2.fontWeight === "textbf") {
            return "bold-sans-serif";
          } else {
            return "sans-serif";
          }
        } else if (options2.fontShape === "textit" && options2.fontWeight === "textbf") {
          return "bold-italic";
        } else if (options2.fontShape === "textit") {
          return "italic";
        } else if (options2.fontWeight === "textbf") {
          return "bold";
        }
        var font = options2.font;
        if (!font || font === "mathnormal") {
          return null;
        }
        var mode = group.mode;
        if (font === "mathit") {
          return "italic";
        } else if (font === "boldsymbol") {
          return group.type === "textord" ? "bold" : "bold-italic";
        } else if (font === "mathbf") {
          return "bold";
        } else if (font === "mathbb") {
          return "double-struck";
        } else if (font === "mathfrak") {
          return "fraktur";
        } else if (font === "mathscr" || font === "mathcal") {
          return "script";
        } else if (font === "mathsf") {
          return "sans-serif";
        } else if (font === "mathtt") {
          return "monospace";
        }
        var text2 = group.text;
        if (utils2.contains(["\\imath", "\\jmath"], text2)) {
          return null;
        }
        if (src_symbols[mode][text2] && src_symbols[mode][text2].replace) {
          text2 = src_symbols[mode][text2].replace;
        }
        var fontName = buildCommon2.fontMap[font].fontName;
        if (getCharacterMetrics2(text2, fontName, mode)) {
          return buildCommon2.fontMap[font].variant;
        }
        return null;
      };
      var buildMathML_buildExpression = function buildExpression5(expression, options2, isOrdgroup) {
        if (expression.length === 1) {
          var group = buildMathML_buildGroup(expression[0], options2);
          if (isOrdgroup && group instanceof MathNode2 && group.type === "mo") {
            group.setAttribute("lspace", "0em");
            group.setAttribute("rspace", "0em");
          }
          return [group];
        }
        var groups = [];
        var lastGroup;
        for (var i3 = 0; i3 < expression.length; i3++) {
          var _group = buildMathML_buildGroup(expression[i3], options2);
          if (_group instanceof MathNode2 && lastGroup instanceof MathNode2) {
            if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
              var _lastGroup$children;
              (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, _group.children);
              continue;
            } else if (_group.type === "mn" && lastGroup.type === "mn") {
              var _lastGroup$children2;
              (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, _group.children);
              continue;
            } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
              var child = _group.children[0];
              if (child instanceof TextNode2 && child.text === ".") {
                var _lastGroup$children3;
                (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, _group.children);
                continue;
              }
            } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
              var lastChild = lastGroup.children[0];
              if (lastChild instanceof TextNode2 && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                var _child = _group.children[0];
                if (_child instanceof TextNode2 && _child.text.length > 0) {
                  _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
                  groups.pop();
                }
              }
            }
          }
          groups.push(_group);
          lastGroup = _group;
        }
        return groups;
      };
      var buildExpressionRow3 = function buildExpressionRow4(expression, options2, isOrdgroup) {
        return makeRow3(buildMathML_buildExpression(expression, options2, isOrdgroup));
      };
      var buildMathML_buildGroup = function buildGroup5(group, options2) {
        if (!group) {
          return new mathMLTree2.MathNode("mrow");
        }
        if (_mathmlGroupBuilders2[group.type]) {
          var result2 = _mathmlGroupBuilders2[group.type](group, options2);
          return result2;
        } else {
          throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      function buildMathML2(tree, texExpression, options2, isDisplayMode, forMathmlOnly) {
        var expression = buildMathML_buildExpression(tree, options2);
        var wrapper;
        if (expression.length === 1 && expression[0] instanceof MathNode2 && utils2.contains(["mrow", "mtable"], expression[0].type)) {
          wrapper = expression[0];
        } else {
          wrapper = new mathMLTree2.MathNode("mrow", expression);
        }
        var annotation = new mathMLTree2.MathNode("annotation", [new mathMLTree2.TextNode(texExpression)]);
        annotation.setAttribute("encoding", "application/x-tex");
        var semantics = new mathMLTree2.MathNode("semantics", [wrapper, annotation]);
        var math3 = new mathMLTree2.MathNode("math", [semantics]);
        math3.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
        if (isDisplayMode) {
          math3.setAttribute("display", "block");
        }
        var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
        return buildCommon2.makeSpan([wrapperClass], [math3]);
      }
      var optionsFromSettings3 = function optionsFromSettings4(settings) {
        return new src_Options({
          style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
          maxSize: settings.maxSize,
          minRuleThickness: settings.minRuleThickness
        });
      };
      var displayWrap3 = function displayWrap4(node, settings) {
        if (settings.displayMode) {
          var classes = ["katex-display"];
          if (settings.leqno) {
            classes.push("leqno");
          }
          if (settings.fleqn) {
            classes.push("fleqn");
          }
          node = buildCommon2.makeSpan(classes, [node]);
        }
        return node;
      };
      var buildTree3 = function buildTree4(tree, expression, settings) {
        var options2 = optionsFromSettings3(settings);
        var katexNode;
        if (settings.output === "mathml") {
          return buildMathML2(tree, expression, options2, settings.displayMode, true);
        } else if (settings.output === "html") {
          var htmlNode = buildHTML2(tree, options2);
          katexNode = buildCommon2.makeSpan(["katex"], [htmlNode]);
        } else {
          var mathMLNode = buildMathML2(tree, expression, options2, settings.displayMode, false);
          var _htmlNode = buildHTML2(tree, options2);
          katexNode = buildCommon2.makeSpan(["katex"], [mathMLNode, _htmlNode]);
        }
        return displayWrap3(katexNode, settings);
      };
      var buildHTMLTree3 = function buildHTMLTree4(tree, expression, settings) {
        var options2 = optionsFromSettings3(settings);
        var htmlNode = buildHTML2(tree, options2);
        var katexNode = buildCommon2.makeSpan(["katex"], [htmlNode]);
        return displayWrap3(katexNode, settings);
      };
      var stretchyCodePoint2 = {
        widehat: "^",
        widecheck: "\u02C7",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "\u2190",
        underleftarrow: "\u2190",
        xleftarrow: "\u2190",
        overrightarrow: "\u2192",
        underrightarrow: "\u2192",
        xrightarrow: "\u2192",
        underbrace: "\u23DF",
        overbrace: "\u23DE",
        overgroup: "\u23E0",
        undergroup: "\u23E1",
        overleftrightarrow: "\u2194",
        underleftrightarrow: "\u2194",
        xleftrightarrow: "\u2194",
        Overrightarrow: "\u21D2",
        xRightarrow: "\u21D2",
        overleftharpoon: "\u21BC",
        xleftharpoonup: "\u21BC",
        overrightharpoon: "\u21C0",
        xrightharpoonup: "\u21C0",
        xLeftarrow: "\u21D0",
        xLeftrightarrow: "\u21D4",
        xhookleftarrow: "\u21A9",
        xhookrightarrow: "\u21AA",
        xmapsto: "\u21A6",
        xrightharpoondown: "\u21C1",
        xleftharpoondown: "\u21BD",
        xrightleftharpoons: "\u21CC",
        xleftrightharpoons: "\u21CB",
        xtwoheadleftarrow: "\u219E",
        xtwoheadrightarrow: "\u21A0",
        xlongequal: "=",
        xtofrom: "\u21C4",
        xrightleftarrows: "\u21C4",
        xrightequilibrium: "\u21CC",
        xleftequilibrium: "\u21CB",
        "\\cdrightarrow": "\u2192",
        "\\cdleftarrow": "\u2190",
        "\\cdlongequal": "="
      };
      var mathMLnode3 = function mathMLnode4(label) {
        var node = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode(stretchyCodePoint2[label.replace(/^\\/, "")])]);
        node.setAttribute("stretchy", "true");
        return node;
      };
      var katexImagesData2 = {
        overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
        "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
        xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
        "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
        Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
        xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
        xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
        overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
        overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
        xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
        "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
        xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
        xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
        overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
        underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
        underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
        xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
        xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
        xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
        xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
        xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
        overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
        undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
        xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
        xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
        xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
        xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
        xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
      };
      var groupLength3 = function groupLength4(arg) {
        if (arg.type === "ordgroup") {
          return arg.body.length;
        } else {
          return 1;
        }
      };
      var svgSpan3 = function svgSpan4(group, options2) {
        function buildSvgSpan_() {
          var viewBoxWidth = 4e5;
          var label = group.label.substr(1);
          if (utils2.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
            var grp = group;
            var numChars = groupLength3(grp.base);
            var viewBoxHeight;
            var pathName;
            var _height;
            if (numChars > 5) {
              if (label === "widehat" || label === "widecheck") {
                viewBoxHeight = 420;
                viewBoxWidth = 2364;
                _height = 0.42;
                pathName = label + "4";
              } else {
                viewBoxHeight = 312;
                viewBoxWidth = 2340;
                _height = 0.34;
                pathName = "tilde4";
              }
            } else {
              var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
              if (label === "widehat" || label === "widecheck") {
                viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                pathName = label + imgIndex;
              } else {
                viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                pathName = "tilde" + imgIndex;
              }
            }
            var path3 = new PathNode2(pathName);
            var svgNode = new SvgNode2([path3], {
              "width": "100%",
              "height": makeEm3(_height),
              "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
              "preserveAspectRatio": "none"
            });
            return {
              span: buildCommon2.makeSvgSpan([], [svgNode], options2),
              minWidth: 0,
              height: _height
            };
          } else {
            var spans = [];
            var data2 = katexImagesData2[label];
            var paths = data2[0], _minWidth = data2[1], _viewBoxHeight = data2[2];
            var _height2 = _viewBoxHeight / 1e3;
            var numSvgChildren = paths.length;
            var widthClasses;
            var aligns;
            if (numSvgChildren === 1) {
              var align1 = data2[3];
              widthClasses = ["hide-tail"];
              aligns = [align1];
            } else if (numSvgChildren === 2) {
              widthClasses = ["halfarrow-left", "halfarrow-right"];
              aligns = ["xMinYMin", "xMaxYMin"];
            } else if (numSvgChildren === 3) {
              widthClasses = ["brace-left", "brace-center", "brace-right"];
              aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
            } else {
              throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
            }
            for (var i3 = 0; i3 < numSvgChildren; i3++) {
              var _path = new PathNode2(paths[i3]);
              var _svgNode = new SvgNode2([_path], {
                "width": "400em",
                "height": makeEm3(_height2),
                "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                "preserveAspectRatio": aligns[i3] + " slice"
              });
              var _span = buildCommon2.makeSvgSpan([widthClasses[i3]], [_svgNode], options2);
              if (numSvgChildren === 1) {
                return {
                  span: _span,
                  minWidth: _minWidth,
                  height: _height2
                };
              } else {
                _span.style.height = makeEm3(_height2);
                spans.push(_span);
              }
            }
            return {
              span: buildCommon2.makeSpan(["stretchy"], spans, options2),
              minWidth: _minWidth,
              height: _height2
            };
          }
        }
        var _buildSvgSpan_ = buildSvgSpan_(), span = _buildSvgSpan_.span, minWidth = _buildSvgSpan_.minWidth, height = _buildSvgSpan_.height;
        span.height = height;
        span.style.height = makeEm3(height);
        if (minWidth > 0) {
          span.style.minWidth = makeEm3(minWidth);
        }
        return span;
      };
      var encloseSpan3 = function encloseSpan4(inner3, label, topPad, bottomPad, options2) {
        var img;
        var totalHeight = inner3.height + inner3.depth + topPad + bottomPad;
        if (/fbox|color|angl/.test(label)) {
          img = buildCommon2.makeSpan(["stretchy", label], [], options2);
          if (label === "fbox") {
            var color = options2.color && options2.getColor();
            if (color) {
              img.style.borderColor = color;
            }
          }
        } else {
          var lines = [];
          if (/^[bx]cancel$/.test(label)) {
            lines.push(new LineNode2({
              "x1": "0",
              "y1": "0",
              "x2": "100%",
              "y2": "100%",
              "stroke-width": "0.046em"
            }));
          }
          if (/^x?cancel$/.test(label)) {
            lines.push(new LineNode2({
              "x1": "0",
              "y1": "100%",
              "x2": "100%",
              "y2": "0",
              "stroke-width": "0.046em"
            }));
          }
          var svgNode = new SvgNode2(lines, {
            "width": "100%",
            "height": makeEm3(totalHeight)
          });
          img = buildCommon2.makeSvgSpan([], [svgNode], options2);
        }
        img.height = totalHeight;
        img.style.height = makeEm3(totalHeight);
        return img;
      };
      var stretchy2 = {
        encloseSpan: encloseSpan3,
        mathMLnode: mathMLnode3,
        svgSpan: svgSpan3
      };
      function assertNodeType2(node, type) {
        if (!node || node.type !== type) {
          throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
        }
        return node;
      }
      function assertSymbolNodeType2(node) {
        var typedNode = checkSymbolNodeType2(node);
        if (!typedNode) {
          throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
        }
        return typedNode;
      }
      function checkSymbolNodeType2(node) {
        if (node && (node.type === "atom" || NON_ATOMS2.hasOwnProperty(node.type))) {
          return node;
        }
        return null;
      }
      var htmlBuilder3 = function htmlBuilder4(grp, options2) {
        var base2;
        var group;
        var supSubGroup;
        if (grp && grp.type === "supsub") {
          group = assertNodeType2(grp.base, "accent");
          base2 = group.base;
          grp.base = base2;
          supSubGroup = assertSpan2(buildGroup4(grp, options2));
          grp.base = group;
        } else {
          group = assertNodeType2(grp, "accent");
          base2 = group.base;
        }
        var body = buildGroup4(base2, options2.havingCrampedStyle());
        var mustShift = group.isShifty && utils2.isCharacterBox(base2);
        var skew = 0;
        if (mustShift) {
          var baseChar = utils2.getBaseElem(base2);
          var baseGroup = buildGroup4(baseChar, options2.havingCrampedStyle());
          skew = assertSymbolDomNode2(baseGroup).skew;
        }
        var accentBelow = group.label === "\\c";
        var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options2.fontMetrics().xHeight);
        var accentBody;
        if (!group.isStretchy) {
          var accent3;
          var width;
          if (group.label === "\\vec") {
            accent3 = buildCommon2.staticSvg("vec", options2);
            width = buildCommon2.svgData.vec[1];
          } else {
            accent3 = buildCommon2.makeOrd({
              mode: group.mode,
              text: group.label
            }, options2, "textord");
            accent3 = assertSymbolDomNode2(accent3);
            accent3.italic = 0;
            width = accent3.width;
            if (accentBelow) {
              clearance += accent3.depth;
            }
          }
          accentBody = buildCommon2.makeSpan(["accent-body"], [accent3]);
          var accentFull = group.label === "\\textcircled";
          if (accentFull) {
            accentBody.classes.push("accent-full");
            clearance = body.height;
          }
          var left2 = skew;
          if (!accentFull) {
            left2 -= width / 2;
          }
          accentBody.style.left = makeEm3(left2);
          if (group.label === "\\textcircled") {
            accentBody.style.top = ".2em";
          }
          accentBody = buildCommon2.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: -clearance
            }, {
              type: "elem",
              elem: accentBody
            }]
          }, options2);
        } else {
          accentBody = stretchy2.svgSpan(group, options2);
          accentBody = buildCommon2.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"],
              wrapperStyle: skew > 0 ? {
                width: "calc(100% - " + makeEm3(2 * skew) + ")",
                marginLeft: makeEm3(2 * skew)
              } : void 0
            }]
          }, options2);
        }
        var accentWrap = buildCommon2.makeSpan(["mord", "accent"], [accentBody], options2);
        if (supSubGroup) {
          supSubGroup.children[0] = accentWrap;
          supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
          supSubGroup.classes[0] = "mord";
          return supSubGroup;
        } else {
          return accentWrap;
        }
      };
      var mathmlBuilder3 = function mathmlBuilder4(group, options2) {
        var accentNode = group.isStretchy ? stretchy2.mathMLnode(group.label) : new mathMLTree2.MathNode("mo", [makeText3(group.label, group.mode)]);
        var node = new mathMLTree2.MathNode("mover", [buildMathML_buildGroup(group.base, options2), accentNode]);
        node.setAttribute("accent", "true");
        return node;
      };
      var NON_STRETCHY_ACCENT_REGEX2 = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function(accent3) {
        return "\\" + accent3;
      }).join("|"));
      defineFunction2({
        type: "accent",
        names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
        props: {
          numArgs: 1
        },
        handler: function handler(context2, args) {
          var base2 = normalizeArgument3(args[0]);
          var isStretchy = !NON_STRETCHY_ACCENT_REGEX2.test(context2.funcName);
          var isShifty = !isStretchy || context2.funcName === "\\widehat" || context2.funcName === "\\widetilde" || context2.funcName === "\\widecheck";
          return {
            type: "accent",
            mode: context2.parser.mode,
            label: context2.funcName,
            isStretchy,
            isShifty,
            base: base2
          };
        },
        htmlBuilder: htmlBuilder3,
        mathmlBuilder: mathmlBuilder3
      });
      defineFunction2({
        type: "accent",
        names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
        props: {
          numArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          argTypes: ["primitive"]
        },
        handler: function handler(context2, args) {
          var base2 = args[0];
          var mode = context2.parser.mode;
          if (mode === "math") {
            context2.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context2.funcName + " works only in text mode");
            mode = "text";
          }
          return {
            type: "accent",
            mode,
            label: context2.funcName,
            isStretchy: false,
            isShifty: true,
            base: base2
          };
        },
        htmlBuilder: htmlBuilder3,
        mathmlBuilder: mathmlBuilder3
      });
      defineFunction2({
        type: "accentUnder",
        names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var base2 = args[0];
          return {
            type: "accentUnder",
            mode: parser.mode,
            label: funcName,
            base: base2
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var innerGroup = buildGroup4(group.base, options2);
          var accentBody = stretchy2.svgSpan(group, options2);
          var kern = group.label === "\\utilde" ? 0.12 : 0;
          var vlist = buildCommon2.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: kern
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options2);
          return buildCommon2.makeSpan(["mord", "accentunder"], [vlist], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var accentNode = stretchy2.mathMLnode(group.label);
          var node = new mathMLTree2.MathNode("munder", [buildMathML_buildGroup(group.base, options2), accentNode]);
          node.setAttribute("accentunder", "true");
          return node;
        }
      });
      var paddedNode2 = function paddedNode3(group) {
        var node = new mathMLTree2.MathNode("mpadded", group ? [group] : []);
        node.setAttribute("width", "+0.6em");
        node.setAttribute("lspace", "0.3em");
        return node;
      };
      defineFunction2({
        type: "xArrow",
        names: [
          "\\xleftarrow",
          "\\xrightarrow",
          "\\xLeftarrow",
          "\\xRightarrow",
          "\\xleftrightarrow",
          "\\xLeftrightarrow",
          "\\xhookleftarrow",
          "\\xhookrightarrow",
          "\\xmapsto",
          "\\xrightharpoondown",
          "\\xrightharpoonup",
          "\\xleftharpoondown",
          "\\xleftharpoonup",
          "\\xrightleftharpoons",
          "\\xleftrightharpoons",
          "\\xlongequal",
          "\\xtwoheadrightarrow",
          "\\xtwoheadleftarrow",
          "\\xtofrom",
          "\\xrightleftarrows",
          "\\xrightequilibrium",
          "\\xleftequilibrium",
          "\\\\cdrightarrow",
          "\\\\cdleftarrow",
          "\\\\cdlongequal"
        ],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser, funcName = _ref.funcName;
          return {
            type: "xArrow",
            mode: parser.mode,
            label: funcName,
            body: args[0],
            below: optArgs[0]
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var style = options2.style;
          var newOptions = options2.havingStyle(style.sup());
          var upperGroup = buildCommon2.wrapFragment(buildGroup4(group.body, newOptions, options2), options2);
          var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
          upperGroup.classes.push(arrowPrefix + "-arrow-pad");
          var lowerGroup;
          if (group.below) {
            newOptions = options2.havingStyle(style.sub());
            lowerGroup = buildCommon2.wrapFragment(buildGroup4(group.below, newOptions, options2), options2);
            lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
          }
          var arrowBody = stretchy2.svgSpan(group, options2);
          var arrowShift = -options2.fontMetrics().axisHeight + 0.5 * arrowBody.height;
          var upperShift = -options2.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
          if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
            upperShift -= upperGroup.depth;
          }
          var vlist;
          if (lowerGroup) {
            var lowerShift = -options2.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
            vlist = buildCommon2.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }, {
                type: "elem",
                elem: lowerGroup,
                shift: lowerShift
              }]
            }, options2);
          } else {
            vlist = buildCommon2.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }]
            }, options2);
          }
          vlist.children[0].children[0].children[1].classes.push("svg-align");
          return buildCommon2.makeSpan(["mrel", "x-arrow"], [vlist], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var arrowNode = stretchy2.mathMLnode(group.label);
          arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
          var node;
          if (group.body) {
            var upperNode = paddedNode2(buildMathML_buildGroup(group.body, options2));
            if (group.below) {
              var lowerNode = paddedNode2(buildMathML_buildGroup(group.below, options2));
              node = new mathMLTree2.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
            } else {
              node = new mathMLTree2.MathNode("mover", [arrowNode, upperNode]);
            }
          } else if (group.below) {
            var _lowerNode = paddedNode2(buildMathML_buildGroup(group.below, options2));
            node = new mathMLTree2.MathNode("munder", [arrowNode, _lowerNode]);
          } else {
            node = paddedNode2();
            node = new mathMLTree2.MathNode("mover", [arrowNode, node]);
          }
          return node;
        }
      });
      var cdArrowFunctionName2 = {
        ">": "\\\\cdrightarrow",
        "<": "\\\\cdleftarrow",
        "=": "\\\\cdlongequal",
        "A": "\\uparrow",
        "V": "\\downarrow",
        "|": "\\Vert",
        ".": "no arrow"
      };
      var newCell2 = function newCell3() {
        return {
          type: "styling",
          body: [],
          mode: "math",
          style: "display"
        };
      };
      var isStartOfArrow2 = function isStartOfArrow3(node) {
        return node.type === "textord" && node.text === "@";
      };
      var isLabelEnd2 = function isLabelEnd3(node, endChar) {
        return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
      };
      function cdArrow2(arrowChar, labels, parser) {
        var funcName = cdArrowFunctionName2[arrowChar];
        switch (funcName) {
          case "\\\\cdrightarrow":
          case "\\\\cdleftarrow":
            return parser.callFunction(funcName, [labels[0]], [labels[1]]);
          case "\\uparrow":
          case "\\downarrow": {
            var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
            var bareArrow = {
              type: "atom",
              text: funcName,
              mode: "math",
              family: "rel"
            };
            var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
            var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
            var arrowGroup = {
              type: "ordgroup",
              mode: "math",
              body: [leftLabel, sizedArrow, rightLabel]
            };
            return parser.callFunction("\\\\cdparent", [arrowGroup], []);
          }
          case "\\\\cdlongequal":
            return parser.callFunction("\\\\cdlongequal", [], []);
          case "\\Vert": {
            var arrow = {
              type: "textord",
              text: "\\Vert",
              mode: "math"
            };
            return parser.callFunction("\\Big", [arrow], []);
          }
          default:
            return {
              type: "textord",
              text: " ",
              mode: "math"
            };
        }
      }
      function parseCD2(parser) {
        var parsedRows = [];
        parser.gullet.beginGroup();
        parser.gullet.macros.set("\\cr", "\\\\\\relax");
        parser.gullet.beginGroup();
        while (true) {
          parsedRows.push(parser.parseExpression(false, "\\\\"));
          parser.gullet.endGroup();
          parser.gullet.beginGroup();
          var next = parser.fetch().text;
          if (next === "&" || next === "\\\\") {
            parser.consume();
          } else if (next === "\\end") {
            if (parsedRows[parsedRows.length - 1].length === 0) {
              parsedRows.pop();
            }
            break;
          } else {
            throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
          }
        }
        var row = [];
        var body = [row];
        for (var i3 = 0; i3 < parsedRows.length; i3++) {
          var rowNodes = parsedRows[i3];
          var cell = newCell2();
          for (var j2 = 0; j2 < rowNodes.length; j2++) {
            if (!isStartOfArrow2(rowNodes[j2])) {
              cell.body.push(rowNodes[j2]);
            } else {
              row.push(cell);
              j2 += 1;
              var arrowChar = assertSymbolNodeType2(rowNodes[j2]).text;
              var labels = new Array(2);
              labels[0] = {
                type: "ordgroup",
                mode: "math",
                body: []
              };
              labels[1] = {
                type: "ordgroup",
                mode: "math",
                body: []
              };
              if ("=|.".indexOf(arrowChar) > -1)
                ;
              else if ("<>AV".indexOf(arrowChar) > -1) {
                for (var labelNum = 0; labelNum < 2; labelNum++) {
                  var inLabel = true;
                  for (var k2 = j2 + 1; k2 < rowNodes.length; k2++) {
                    if (isLabelEnd2(rowNodes[k2], arrowChar)) {
                      inLabel = false;
                      j2 = k2;
                      break;
                    }
                    if (isStartOfArrow2(rowNodes[k2])) {
                      throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k2]);
                    }
                    labels[labelNum].body.push(rowNodes[k2]);
                  }
                  if (inLabel) {
                    throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j2]);
                  }
                }
              } else {
                throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j2]);
              }
              var arrow = cdArrow2(arrowChar, labels, parser);
              var wrappedArrow = {
                type: "styling",
                body: [arrow],
                mode: "math",
                style: "display"
              };
              row.push(wrappedArrow);
              cell = newCell2();
            }
          }
          if (i3 % 2 === 0) {
            row.push(cell);
          } else {
            row.shift();
          }
          row = [];
          body.push(row);
        }
        parser.gullet.endGroup();
        parser.gullet.endGroup();
        var cols = new Array(body[0].length).fill({
          type: "align",
          align: "c",
          pregap: 0.25,
          postgap: 0.25
        });
        return {
          type: "array",
          mode: "math",
          body,
          arraystretch: 1,
          addJot: true,
          rowGaps: [null],
          cols,
          colSeparationType: "CD",
          hLinesBeforeRow: new Array(body.length + 1).fill([])
        };
      }
      defineFunction2({
        type: "cdlabel",
        names: ["\\\\cdleft", "\\\\cdright"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          return {
            type: "cdlabel",
            mode: parser.mode,
            side: funcName.slice(4),
            label: args[0]
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var newOptions = options2.havingStyle(options2.style.sup());
          var label = buildCommon2.wrapFragment(buildGroup4(group.label, newOptions, options2), options2);
          label.classes.push("cd-label-" + group.side);
          label.style.bottom = makeEm3(0.8 - label.depth);
          label.height = 0;
          label.depth = 0;
          return label;
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var label = new mathMLTree2.MathNode("mrow", [buildMathML_buildGroup(group.label, options2)]);
          label = new mathMLTree2.MathNode("mpadded", [label]);
          label.setAttribute("width", "0");
          if (group.side === "left") {
            label.setAttribute("lspace", "-1width");
          }
          label.setAttribute("voffset", "0.7em");
          label = new mathMLTree2.MathNode("mstyle", [label]);
          label.setAttribute("displaystyle", "false");
          label.setAttribute("scriptlevel", "1");
          return label;
        }
      });
      defineFunction2({
        type: "cdlabelparent",
        names: ["\\\\cdparent"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          return {
            type: "cdlabelparent",
            mode: parser.mode,
            fragment: args[0]
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var parent = buildCommon2.wrapFragment(buildGroup4(group.fragment, options2), options2);
          parent.classes.push("cd-vert-arrow");
          return parent;
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          return new mathMLTree2.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options2)]);
        }
      });
      defineFunction2({
        type: "textord",
        names: ["\\@char"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var arg = assertNodeType2(args[0], "ordgroup");
          var group = arg.body;
          var number = "";
          for (var i3 = 0; i3 < group.length; i3++) {
            var node = assertNodeType2(group[i3], "textord");
            number += node.text;
          }
          var code2 = parseInt(number);
          var text2;
          if (isNaN(code2)) {
            throw new src_ParseError("\\@char has non-numeric argument " + number);
          } else if (code2 < 0 || code2 >= 1114111) {
            throw new src_ParseError("\\@char with invalid code point " + number);
          } else if (code2 <= 65535) {
            text2 = String.fromCharCode(code2);
          } else {
            code2 -= 65536;
            text2 = String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
          }
          return {
            type: "textord",
            mode: parser.mode,
            text: text2
          };
        }
      });
      var color_htmlBuilder = function htmlBuilder4(group, options2) {
        var elements = buildExpression4(group.body, options2.withColor(group.color), false);
        return buildCommon2.makeFragment(elements);
      };
      var color_mathmlBuilder = function mathmlBuilder4(group, options2) {
        var inner3 = buildMathML_buildExpression(group.body, options2.withColor(group.color));
        var node = new mathMLTree2.MathNode("mstyle", inner3);
        node.setAttribute("mathcolor", group.color);
        return node;
      };
      defineFunction2({
        type: "color",
        names: ["\\textcolor"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "original"]
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var color = assertNodeType2(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "color",
            mode: parser.mode,
            color,
            body: ordargument3(body)
          };
        },
        htmlBuilder: color_htmlBuilder,
        mathmlBuilder: color_mathmlBuilder
      });
      defineFunction2({
        type: "color",
        names: ["\\color"],
        props: {
          numArgs: 1,
          allowedInText: true,
          argTypes: ["color"]
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser, breakOnTokenText = _ref2.breakOnTokenText;
          var color = assertNodeType2(args[0], "color-token").color;
          parser.gullet.macros.set("\\current@color", color);
          var body = parser.parseExpression(true, breakOnTokenText);
          return {
            type: "color",
            mode: parser.mode,
            color,
            body
          };
        },
        htmlBuilder: color_htmlBuilder,
        mathmlBuilder: color_mathmlBuilder
      });
      defineFunction2({
        type: "cr",
        names: ["\\\\"],
        props: {
          numArgs: 0,
          numOptionalArgs: 1,
          argTypes: ["size"],
          allowedInText: true
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var size = optArgs[0];
          var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
          return {
            type: "cr",
            mode: parser.mode,
            newLine,
            size: size && assertNodeType2(size, "size").value
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var span = buildCommon2.makeSpan(["mspace"], [], options2);
          if (group.newLine) {
            span.classes.push("newline");
            if (group.size) {
              span.style.marginTop = makeEm3(calculateSize3(group.size, options2));
            }
          }
          return span;
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var node = new mathMLTree2.MathNode("mspace");
          if (group.newLine) {
            node.setAttribute("linebreak", "newline");
            if (group.size) {
              node.setAttribute("height", makeEm3(calculateSize3(group.size, options2)));
            }
          }
          return node;
        }
      });
      var globalMap2 = {
        "\\global": "\\global",
        "\\long": "\\\\globallong",
        "\\\\globallong": "\\\\globallong",
        "\\def": "\\gdef",
        "\\gdef": "\\gdef",
        "\\edef": "\\xdef",
        "\\xdef": "\\xdef",
        "\\let": "\\\\globallet",
        "\\futurelet": "\\\\globalfuture"
      };
      var checkControlSequence2 = function checkControlSequence3(tok) {
        var name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new src_ParseError("Expected a control sequence", tok);
        }
        return name;
      };
      var getRHS2 = function getRHS3(parser) {
        var tok = parser.gullet.popToken();
        if (tok.text === "=") {
          tok = parser.gullet.popToken();
          if (tok.text === " ") {
            tok = parser.gullet.popToken();
          }
        }
        return tok;
      };
      var letCommand2 = function letCommand3(parser, name, tok, global2) {
        var macro = parser.gullet.macros.get(tok.text);
        if (macro == null) {
          tok.noexpand = true;
          macro = {
            tokens: [tok],
            numArgs: 0,
            unexpandable: !parser.gullet.isExpandable(tok.text)
          };
        }
        parser.gullet.macros.set(name, macro, global2);
      };
      defineFunction2({
        type: "internal",
        names: [
          "\\global",
          "\\long",
          "\\\\globallong"
        ],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref) {
          var parser = _ref.parser, funcName = _ref.funcName;
          parser.consumeSpaces();
          var token = parser.fetch();
          if (globalMap2[token.text]) {
            if (funcName === "\\global" || funcName === "\\\\globallong") {
              token.text = globalMap2[token.text];
            }
            return assertNodeType2(parser.parseFunction(), "internal");
          }
          throw new src_ParseError("Invalid token after macro prefix", token);
        }
      });
      defineFunction2({
        type: "internal",
        names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref2) {
          var parser = _ref2.parser, funcName = _ref2.funcName;
          var tok = parser.gullet.popToken();
          var name = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
            throw new src_ParseError("Expected a control sequence", tok);
          }
          var numArgs = 0;
          var insert;
          var delimiters3 = [[]];
          while (parser.gullet.future().text !== "{") {
            tok = parser.gullet.popToken();
            if (tok.text === "#") {
              if (parser.gullet.future().text === "{") {
                insert = parser.gullet.future();
                delimiters3[numArgs].push("{");
                break;
              }
              tok = parser.gullet.popToken();
              if (!/^[1-9]$/.test(tok.text)) {
                throw new src_ParseError('Invalid argument number "' + tok.text + '"');
              }
              if (parseInt(tok.text) !== numArgs + 1) {
                throw new src_ParseError('Argument number "' + tok.text + '" out of order');
              }
              numArgs++;
              delimiters3.push([]);
            } else if (tok.text === "EOF") {
              throw new src_ParseError("Expected a macro definition");
            } else {
              delimiters3[numArgs].push(tok.text);
            }
          }
          var _parser$gullet$consum = parser.gullet.consumeArg(), tokens = _parser$gullet$consum.tokens;
          if (insert) {
            tokens.unshift(insert);
          }
          if (funcName === "\\edef" || funcName === "\\xdef") {
            tokens = parser.gullet.expandTokens(tokens);
            tokens.reverse();
          }
          parser.gullet.macros.set(name, {
            tokens,
            numArgs,
            delimiters: delimiters3
          }, funcName === globalMap2[funcName]);
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      defineFunction2({
        type: "internal",
        names: [
          "\\let",
          "\\\\globallet"
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref3) {
          var parser = _ref3.parser, funcName = _ref3.funcName;
          var name = checkControlSequence2(parser.gullet.popToken());
          parser.gullet.consumeSpaces();
          var tok = getRHS2(parser);
          letCommand2(parser, name, tok, funcName === "\\\\globallet");
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      defineFunction2({
        type: "internal",
        names: [
          "\\futurelet",
          "\\\\globalfuture"
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref4) {
          var parser = _ref4.parser, funcName = _ref4.funcName;
          var name = checkControlSequence2(parser.gullet.popToken());
          var middle = parser.gullet.popToken();
          var tok = parser.gullet.popToken();
          letCommand2(parser, name, tok, funcName === "\\\\globalfuture");
          parser.gullet.pushToken(tok);
          parser.gullet.pushToken(middle);
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      var getMetrics3 = function getMetrics4(symbol, font, mode) {
        var replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
        var metrics = getCharacterMetrics2(replace || symbol, font, mode);
        if (!metrics) {
          throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
        }
        return metrics;
      };
      var styleWrap3 = function styleWrap4(delim, toStyle, options2, classes) {
        var newOptions = options2.havingBaseStyle(toStyle);
        var span = buildCommon2.makeSpan(classes.concat(newOptions.sizingClasses(options2)), [delim], options2);
        var delimSizeMultiplier = newOptions.sizeMultiplier / options2.sizeMultiplier;
        span.height *= delimSizeMultiplier;
        span.depth *= delimSizeMultiplier;
        span.maxFontSize = newOptions.sizeMultiplier;
        return span;
      };
      var centerSpan3 = function centerSpan4(span, options2, style) {
        var newOptions = options2.havingBaseStyle(style);
        var shift = (1 - options2.sizeMultiplier / newOptions.sizeMultiplier) * options2.fontMetrics().axisHeight;
        span.classes.push("delimcenter");
        span.style.top = makeEm3(shift);
        span.height -= shift;
        span.depth += shift;
      };
      var makeSmallDelim3 = function makeSmallDelim4(delim, style, center, options2, mode, classes) {
        var text2 = buildCommon2.makeSymbol(delim, "Main-Regular", mode, options2);
        var span = styleWrap3(text2, style, options2, classes);
        if (center) {
          centerSpan3(span, options2, style);
        }
        return span;
      };
      var mathrmSize3 = function mathrmSize4(value, size, mode, options2) {
        return buildCommon2.makeSymbol(value, "Size" + size + "-Regular", mode, options2);
      };
      var makeLargeDelim3 = function makeLargeDelim4(delim, size, center, options2, mode, classes) {
        var inner3 = mathrmSize3(delim, size, mode, options2);
        var span = styleWrap3(buildCommon2.makeSpan(["delimsizing", "size" + size], [inner3], options2), src_Style.TEXT, options2, classes);
        if (center) {
          centerSpan3(span, options2, src_Style.TEXT);
        }
        return span;
      };
      var makeGlyphSpan3 = function makeGlyphSpan4(symbol, font, mode) {
        var sizeClass;
        if (font === "Size1-Regular") {
          sizeClass = "delim-size1";
        } else {
          sizeClass = "delim-size4";
        }
        var corner = buildCommon2.makeSpan(["delimsizinginner", sizeClass], [buildCommon2.makeSpan([], [buildCommon2.makeSymbol(symbol, font, mode)])]);
        return {
          type: "elem",
          elem: corner
        };
      };
      var makeInner3 = function makeInner4(ch3, height, options2) {
        var width = fontMetricsData2["Size4-Regular"][ch3.charCodeAt(0)] ? fontMetricsData2["Size4-Regular"][ch3.charCodeAt(0)][4] : fontMetricsData2["Size1-Regular"][ch3.charCodeAt(0)][4];
        var path3 = new PathNode2("inner", innerPath3(ch3, Math.round(1e3 * height)));
        var svgNode = new SvgNode2([path3], {
          "width": makeEm3(width),
          "height": makeEm3(height),
          "style": "width:" + makeEm3(width),
          "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
          "preserveAspectRatio": "xMinYMin"
        });
        var span = buildCommon2.makeSvgSpan([], [svgNode], options2);
        span.height = height;
        span.style.height = makeEm3(height);
        span.style.width = makeEm3(width);
        return {
          type: "elem",
          elem: span
        };
      };
      var lapInEms2 = 8e-3;
      var lap2 = {
        type: "kern",
        size: -1 * lapInEms2
      };
      var verts2 = ["|", "\\lvert", "\\rvert", "\\vert"];
      var doubleVerts2 = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
      var makeStackedDelim3 = function makeStackedDelim4(delim, heightTotal, center, options2, mode, classes) {
        var top;
        var middle;
        var repeat;
        var bottom;
        top = repeat = bottom = delim;
        middle = null;
        var font = "Size1-Regular";
        if (delim === "\\uparrow") {
          repeat = bottom = "\u23D0";
        } else if (delim === "\\Uparrow") {
          repeat = bottom = "\u2016";
        } else if (delim === "\\downarrow") {
          top = repeat = "\u23D0";
        } else if (delim === "\\Downarrow") {
          top = repeat = "\u2016";
        } else if (delim === "\\updownarrow") {
          top = "\\uparrow";
          repeat = "\u23D0";
          bottom = "\\downarrow";
        } else if (delim === "\\Updownarrow") {
          top = "\\Uparrow";
          repeat = "\u2016";
          bottom = "\\Downarrow";
        } else if (utils2.contains(verts2, delim)) {
          repeat = "\u2223";
        } else if (utils2.contains(doubleVerts2, delim)) {
          repeat = "\u2225";
        } else if (delim === "[" || delim === "\\lbrack") {
          top = "\u23A1";
          repeat = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
        } else if (delim === "]" || delim === "\\rbrack") {
          top = "\u23A4";
          repeat = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
        } else if (delim === "\\lfloor" || delim === "\u230A") {
          repeat = top = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
        } else if (delim === "\\lceil" || delim === "\u2308") {
          top = "\u23A1";
          repeat = bottom = "\u23A2";
          font = "Size4-Regular";
        } else if (delim === "\\rfloor" || delim === "\u230B") {
          repeat = top = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
        } else if (delim === "\\rceil" || delim === "\u2309") {
          top = "\u23A4";
          repeat = bottom = "\u23A5";
          font = "Size4-Regular";
        } else if (delim === "(" || delim === "\\lparen") {
          top = "\u239B";
          repeat = "\u239C";
          bottom = "\u239D";
          font = "Size4-Regular";
        } else if (delim === ")" || delim === "\\rparen") {
          top = "\u239E";
          repeat = "\u239F";
          bottom = "\u23A0";
          font = "Size4-Regular";
        } else if (delim === "\\{" || delim === "\\lbrace") {
          top = "\u23A7";
          middle = "\u23A8";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\}" || delim === "\\rbrace") {
          top = "\u23AB";
          middle = "\u23AC";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lgroup" || delim === "\u27EE") {
          top = "\u23A7";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rgroup" || delim === "\u27EF") {
          top = "\u23AB";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lmoustache" || delim === "\u23B0") {
          top = "\u23A7";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rmoustache" || delim === "\u23B1") {
          top = "\u23AB";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        }
        var topMetrics = getMetrics3(top, font, mode);
        var topHeightTotal = topMetrics.height + topMetrics.depth;
        var repeatMetrics = getMetrics3(repeat, font, mode);
        var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
        var bottomMetrics = getMetrics3(bottom, font, mode);
        var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
        var middleHeightTotal = 0;
        var middleFactor = 1;
        if (middle !== null) {
          var middleMetrics = getMetrics3(middle, font, mode);
          middleHeightTotal = middleMetrics.height + middleMetrics.depth;
          middleFactor = 2;
        }
        var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
        var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
        var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
        var axisHeight = options2.fontMetrics().axisHeight;
        if (center) {
          axisHeight *= options2.sizeMultiplier;
        }
        var depth = realHeightTotal / 2 - axisHeight;
        var stack = [];
        stack.push(makeGlyphSpan3(bottom, font, mode));
        stack.push(lap2);
        if (middle === null) {
          var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms2;
          stack.push(makeInner3(repeat, innerHeight, options2));
        } else {
          var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms2;
          stack.push(makeInner3(repeat, _innerHeight, options2));
          stack.push(lap2);
          stack.push(makeGlyphSpan3(middle, font, mode));
          stack.push(lap2);
          stack.push(makeInner3(repeat, _innerHeight, options2));
        }
        stack.push(lap2);
        stack.push(makeGlyphSpan3(top, font, mode));
        var newOptions = options2.havingBaseStyle(src_Style.TEXT);
        var inner3 = buildCommon2.makeVList({
          positionType: "bottom",
          positionData: depth,
          children: stack
        }, newOptions);
        return styleWrap3(buildCommon2.makeSpan(["delimsizing", "mult"], [inner3], newOptions), src_Style.TEXT, options2, classes);
      };
      var vbPad2 = 80;
      var emPad2 = 0.08;
      var sqrtSvg3 = function sqrtSvg4(sqrtName, height, viewBoxHeight, extraViniculum, options2) {
        var path3 = sqrtPath3(sqrtName, extraViniculum, viewBoxHeight);
        var pathNode = new PathNode2(sqrtName, path3);
        var svg = new SvgNode2([pathNode], {
          "width": "400em",
          "height": makeEm3(height),
          "viewBox": "0 0 400000 " + viewBoxHeight,
          "preserveAspectRatio": "xMinYMin slice"
        });
        return buildCommon2.makeSvgSpan(["hide-tail"], [svg], options2);
      };
      var makeSqrtImage3 = function makeSqrtImage4(height, options2) {
        var newOptions = options2.havingBaseSizing();
        var delim = traverseSequence3("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence2, newOptions);
        var sizeMultiplier = newOptions.sizeMultiplier;
        var extraViniculum = Math.max(0, options2.minRuleThickness - options2.fontMetrics().sqrtRuleThickness);
        var span;
        var spanHeight = 0;
        var texHeight = 0;
        var viewBoxHeight = 0;
        var advanceWidth;
        if (delim.type === "small") {
          viewBoxHeight = 1e3 + 1e3 * extraViniculum + vbPad2;
          if (height < 1) {
            sizeMultiplier = 1;
          } else if (height < 1.4) {
            sizeMultiplier = 0.7;
          }
          spanHeight = (1 + extraViniculum + emPad2) / sizeMultiplier;
          texHeight = (1 + extraViniculum) / sizeMultiplier;
          span = sqrtSvg3("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options2);
          span.style.minWidth = "0.853em";
          advanceWidth = 0.833 / sizeMultiplier;
        } else if (delim.type === "large") {
          viewBoxHeight = (1e3 + vbPad2) * sizeToMaxHeight2[delim.size];
          texHeight = (sizeToMaxHeight2[delim.size] + extraViniculum) / sizeMultiplier;
          spanHeight = (sizeToMaxHeight2[delim.size] + extraViniculum + emPad2) / sizeMultiplier;
          span = sqrtSvg3("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options2);
          span.style.minWidth = "1.02em";
          advanceWidth = 1 / sizeMultiplier;
        } else {
          spanHeight = height + extraViniculum + emPad2;
          texHeight = height + extraViniculum;
          viewBoxHeight = Math.floor(1e3 * height + extraViniculum) + vbPad2;
          span = sqrtSvg3("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options2);
          span.style.minWidth = "0.742em";
          advanceWidth = 1.056;
        }
        span.height = texHeight;
        span.style.height = makeEm3(spanHeight);
        return {
          span,
          advanceWidth,
          ruleWidth: (options2.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
        };
      };
      var stackLargeDelimiters2 = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
      var stackAlwaysDelimiters2 = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
      var stackNeverDelimiters2 = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
      var sizeToMaxHeight2 = [0, 1.2, 1.8, 2.4, 3];
      var makeSizedDelim3 = function makeSizedDelim4(delim, size, options2, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        if (utils2.contains(stackLargeDelimiters2, delim) || utils2.contains(stackNeverDelimiters2, delim)) {
          return makeLargeDelim3(delim, size, false, options2, mode, classes);
        } else if (utils2.contains(stackAlwaysDelimiters2, delim)) {
          return makeStackedDelim3(delim, sizeToMaxHeight2[size], false, options2, mode, classes);
        } else {
          throw new src_ParseError("Illegal delimiter: '" + delim + "'");
        }
      };
      var stackNeverDelimiterSequence2 = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }];
      var stackAlwaysDelimiterSequence2 = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "stack"
      }];
      var stackLargeDelimiterSequence2 = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }, {
        type: "stack"
      }];
      var delimTypeToFont3 = function delimTypeToFont4(type) {
        if (type.type === "small") {
          return "Main-Regular";
        } else if (type.type === "large") {
          return "Size" + type.size + "-Regular";
        } else if (type.type === "stack") {
          return "Size4-Regular";
        } else {
          throw new Error("Add support for delim type '" + type.type + "' here.");
        }
      };
      var traverseSequence3 = function traverseSequence4(delim, height, sequence, options2) {
        var start = Math.min(2, 3 - options2.style.size);
        for (var i3 = start; i3 < sequence.length; i3++) {
          if (sequence[i3].type === "stack") {
            break;
          }
          var metrics = getMetrics3(delim, delimTypeToFont3(sequence[i3]), "math");
          var heightDepth = metrics.height + metrics.depth;
          if (sequence[i3].type === "small") {
            var newOptions = options2.havingBaseStyle(sequence[i3].style);
            heightDepth *= newOptions.sizeMultiplier;
          }
          if (heightDepth > height) {
            return sequence[i3];
          }
        }
        return sequence[sequence.length - 1];
      };
      var makeCustomSizedDelim3 = function makeCustomSizedDelim4(delim, height, center, options2, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        var sequence;
        if (utils2.contains(stackNeverDelimiters2, delim)) {
          sequence = stackNeverDelimiterSequence2;
        } else if (utils2.contains(stackLargeDelimiters2, delim)) {
          sequence = stackLargeDelimiterSequence2;
        } else {
          sequence = stackAlwaysDelimiterSequence2;
        }
        var delimType = traverseSequence3(delim, height, sequence, options2);
        if (delimType.type === "small") {
          return makeSmallDelim3(delim, delimType.style, center, options2, mode, classes);
        } else if (delimType.type === "large") {
          return makeLargeDelim3(delim, delimType.size, center, options2, mode, classes);
        } else {
          return makeStackedDelim3(delim, height, center, options2, mode, classes);
        }
      };
      var makeLeftRightDelim3 = function makeLeftRightDelim4(delim, height, depth, options2, mode, classes) {
        var axisHeight = options2.fontMetrics().axisHeight * options2.sizeMultiplier;
        var delimiterFactor = 901;
        var delimiterExtend = 5 / options2.fontMetrics().ptPerEm;
        var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
        var totalHeight = Math.max(maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);
        return makeCustomSizedDelim3(delim, totalHeight, true, options2, mode, classes);
      };
      var delimiter2 = {
        sqrtImage: makeSqrtImage3,
        sizedDelim: makeSizedDelim3,
        sizeToMaxHeight: sizeToMaxHeight2,
        customSizedDelim: makeCustomSizedDelim3,
        leftRightDelim: makeLeftRightDelim3
      };
      var delimiterSizes2 = {
        "\\bigl": {
          mclass: "mopen",
          size: 1
        },
        "\\Bigl": {
          mclass: "mopen",
          size: 2
        },
        "\\biggl": {
          mclass: "mopen",
          size: 3
        },
        "\\Biggl": {
          mclass: "mopen",
          size: 4
        },
        "\\bigr": {
          mclass: "mclose",
          size: 1
        },
        "\\Bigr": {
          mclass: "mclose",
          size: 2
        },
        "\\biggr": {
          mclass: "mclose",
          size: 3
        },
        "\\Biggr": {
          mclass: "mclose",
          size: 4
        },
        "\\bigm": {
          mclass: "mrel",
          size: 1
        },
        "\\Bigm": {
          mclass: "mrel",
          size: 2
        },
        "\\biggm": {
          mclass: "mrel",
          size: 3
        },
        "\\Biggm": {
          mclass: "mrel",
          size: 4
        },
        "\\big": {
          mclass: "mord",
          size: 1
        },
        "\\Big": {
          mclass: "mord",
          size: 2
        },
        "\\bigg": {
          mclass: "mord",
          size: 3
        },
        "\\Bigg": {
          mclass: "mord",
          size: 4
        }
      };
      var delimiters2 = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
      function checkDelimiter2(delim, context2) {
        var symDelim = checkSymbolNodeType2(delim);
        if (symDelim && utils2.contains(delimiters2, symDelim.text)) {
          return symDelim;
        } else if (symDelim) {
          throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context2.funcName + "'", delim);
        } else {
          throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
        }
      }
      defineFunction2({
        type: "delimsizing",
        names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
        props: {
          numArgs: 1,
          argTypes: ["primitive"]
        },
        handler: function handler(context2, args) {
          var delim = checkDelimiter2(args[0], context2);
          return {
            type: "delimsizing",
            mode: context2.parser.mode,
            size: delimiterSizes2[context2.funcName].size,
            mclass: delimiterSizes2[context2.funcName].mclass,
            delim: delim.text
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          if (group.delim === ".") {
            return buildCommon2.makeSpan([group.mclass]);
          }
          return delimiter2.sizedDelim(group.delim, group.size, options2, group.mode, [group.mclass]);
        },
        mathmlBuilder: function mathmlBuilder4(group) {
          var children = [];
          if (group.delim !== ".") {
            children.push(makeText3(group.delim, group.mode));
          }
          var node = new mathMLTree2.MathNode("mo", children);
          if (group.mclass === "mopen" || group.mclass === "mclose") {
            node.setAttribute("fence", "true");
          } else {
            node.setAttribute("fence", "false");
          }
          node.setAttribute("stretchy", "true");
          var size = makeEm3(delimiter2.sizeToMaxHeight[group.size]);
          node.setAttribute("minsize", size);
          node.setAttribute("maxsize", size);
          return node;
        }
      });
      function assertParsed2(group) {
        if (!group.body) {
          throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
        }
      }
      defineFunction2({
        type: "leftright-right",
        names: ["\\right"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context2, args) {
          var color = context2.parser.gullet.macros.get("\\current@color");
          if (color && typeof color !== "string") {
            throw new src_ParseError("\\current@color set to non-string in \\right");
          }
          return {
            type: "leftright-right",
            mode: context2.parser.mode,
            delim: checkDelimiter2(args[0], context2).text,
            color
          };
        }
      });
      defineFunction2({
        type: "leftright",
        names: ["\\left"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context2, args) {
          var delim = checkDelimiter2(args[0], context2);
          var parser = context2.parser;
          ++parser.leftrightDepth;
          var body = parser.parseExpression(false);
          --parser.leftrightDepth;
          parser.expect("\\right", false);
          var right = assertNodeType2(parser.parseFunction(), "leftright-right");
          return {
            type: "leftright",
            mode: parser.mode,
            body,
            left: delim.text,
            right: right.delim,
            rightColor: right.color
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          assertParsed2(group);
          var inner3 = buildExpression4(group.body, options2, true, ["mopen", "mclose"]);
          var innerHeight = 0;
          var innerDepth = 0;
          var hadMiddle = false;
          for (var i3 = 0; i3 < inner3.length; i3++) {
            if (inner3[i3].isMiddle) {
              hadMiddle = true;
            } else {
              innerHeight = Math.max(inner3[i3].height, innerHeight);
              innerDepth = Math.max(inner3[i3].depth, innerDepth);
            }
          }
          innerHeight *= options2.sizeMultiplier;
          innerDepth *= options2.sizeMultiplier;
          var leftDelim;
          if (group.left === ".") {
            leftDelim = makeNullDelimiter3(options2, ["mopen"]);
          } else {
            leftDelim = delimiter2.leftRightDelim(group.left, innerHeight, innerDepth, options2, group.mode, ["mopen"]);
          }
          inner3.unshift(leftDelim);
          if (hadMiddle) {
            for (var _i7 = 1; _i7 < inner3.length; _i7++) {
              var middleDelim = inner3[_i7];
              var isMiddle = middleDelim.isMiddle;
              if (isMiddle) {
                inner3[_i7] = delimiter2.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
              }
            }
          }
          var rightDelim;
          if (group.right === ".") {
            rightDelim = makeNullDelimiter3(options2, ["mclose"]);
          } else {
            var colorOptions = group.rightColor ? options2.withColor(group.rightColor) : options2;
            rightDelim = delimiter2.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
          }
          inner3.push(rightDelim);
          return buildCommon2.makeSpan(["minner"], inner3, options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          assertParsed2(group);
          var inner3 = buildMathML_buildExpression(group.body, options2);
          if (group.left !== ".") {
            var leftNode = new mathMLTree2.MathNode("mo", [makeText3(group.left, group.mode)]);
            leftNode.setAttribute("fence", "true");
            inner3.unshift(leftNode);
          }
          if (group.right !== ".") {
            var rightNode = new mathMLTree2.MathNode("mo", [makeText3(group.right, group.mode)]);
            rightNode.setAttribute("fence", "true");
            if (group.rightColor) {
              rightNode.setAttribute("mathcolor", group.rightColor);
            }
            inner3.push(rightNode);
          }
          return makeRow3(inner3);
        }
      });
      defineFunction2({
        type: "middle",
        names: ["\\middle"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context2, args) {
          var delim = checkDelimiter2(args[0], context2);
          if (!context2.parser.leftrightDepth) {
            throw new src_ParseError("\\middle without preceding \\left", delim);
          }
          return {
            type: "middle",
            mode: context2.parser.mode,
            delim: delim.text
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var middleDelim;
          if (group.delim === ".") {
            middleDelim = makeNullDelimiter3(options2, []);
          } else {
            middleDelim = delimiter2.sizedDelim(group.delim, 1, options2, group.mode, []);
            var isMiddle = {
              delim: group.delim,
              options: options2
            };
            middleDelim.isMiddle = isMiddle;
          }
          return middleDelim;
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText3("|", "text") : makeText3(group.delim, group.mode);
          var middleNode = new mathMLTree2.MathNode("mo", [textNode]);
          middleNode.setAttribute("fence", "true");
          middleNode.setAttribute("lspace", "0.05em");
          middleNode.setAttribute("rspace", "0.05em");
          return middleNode;
        }
      });
      var enclose_htmlBuilder = function htmlBuilder4(group, options2) {
        var inner3 = buildCommon2.wrapFragment(buildGroup4(group.body, options2), options2);
        var label = group.label.substr(1);
        var scale = options2.sizeMultiplier;
        var img;
        var imgShift = 0;
        var isSingleChar = utils2.isCharacterBox(group.body);
        if (label === "sout") {
          img = buildCommon2.makeSpan(["stretchy", "sout"]);
          img.height = options2.fontMetrics().defaultRuleThickness / scale;
          imgShift = -0.5 * options2.fontMetrics().xHeight;
        } else if (label === "phase") {
          var lineWeight = calculateSize3({
            number: 0.6,
            unit: "pt"
          }, options2);
          var clearance = calculateSize3({
            number: 0.35,
            unit: "ex"
          }, options2);
          var newOptions = options2.havingBaseSizing();
          scale = scale / newOptions.sizeMultiplier;
          var angleHeight = inner3.height + inner3.depth + lineWeight + clearance;
          inner3.style.paddingLeft = makeEm3(angleHeight / 2 + lineWeight);
          var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
          var path3 = phasePath3(viewBoxHeight);
          var svgNode = new SvgNode2([new PathNode2("phase", path3)], {
            "width": "400em",
            "height": makeEm3(viewBoxHeight / 1e3),
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          img = buildCommon2.makeSvgSpan(["hide-tail"], [svgNode], options2);
          img.style.height = makeEm3(angleHeight);
          imgShift = inner3.depth + lineWeight + clearance;
        } else {
          if (/cancel/.test(label)) {
            if (!isSingleChar) {
              inner3.classes.push("cancel-pad");
            }
          } else if (label === "angl") {
            inner3.classes.push("anglpad");
          } else {
            inner3.classes.push("boxpad");
          }
          var topPad = 0;
          var bottomPad = 0;
          var ruleThickness = 0;
          if (/box/.test(label)) {
            ruleThickness = Math.max(options2.fontMetrics().fboxrule, options2.minRuleThickness);
            topPad = options2.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
            bottomPad = topPad;
          } else if (label === "angl") {
            ruleThickness = Math.max(options2.fontMetrics().defaultRuleThickness, options2.minRuleThickness);
            topPad = 4 * ruleThickness;
            bottomPad = Math.max(0, 0.25 - inner3.depth);
          } else {
            topPad = isSingleChar ? 0.2 : 0;
            bottomPad = topPad;
          }
          img = stretchy2.encloseSpan(inner3, label, topPad, bottomPad, options2);
          if (/fbox|boxed|fcolorbox/.test(label)) {
            img.style.borderStyle = "solid";
            img.style.borderWidth = makeEm3(ruleThickness);
          } else if (label === "angl" && ruleThickness !== 0.049) {
            img.style.borderTopWidth = makeEm3(ruleThickness);
            img.style.borderRightWidth = makeEm3(ruleThickness);
          }
          imgShift = inner3.depth + bottomPad;
          if (group.backgroundColor) {
            img.style.backgroundColor = group.backgroundColor;
            if (group.borderColor) {
              img.style.borderColor = group.borderColor;
            }
          }
        }
        var vlist;
        if (group.backgroundColor) {
          vlist = buildCommon2.makeVList({
            positionType: "individualShift",
            children: [
              {
                type: "elem",
                elem: img,
                shift: imgShift
              },
              {
                type: "elem",
                elem: inner3,
                shift: 0
              }
            ]
          }, options2);
        } else {
          var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
          vlist = buildCommon2.makeVList({
            positionType: "individualShift",
            children: [
              {
                type: "elem",
                elem: inner3,
                shift: 0
              },
              {
                type: "elem",
                elem: img,
                shift: imgShift,
                wrapperClasses: classes
              }
            ]
          }, options2);
        }
        if (/cancel/.test(label)) {
          vlist.height = inner3.height;
          vlist.depth = inner3.depth;
        }
        if (/cancel/.test(label) && !isSingleChar) {
          return buildCommon2.makeSpan(["mord", "cancel-lap"], [vlist], options2);
        } else {
          return buildCommon2.makeSpan(["mord"], [vlist], options2);
        }
      };
      var enclose_mathmlBuilder = function mathmlBuilder4(group, options2) {
        var fboxsep = 0;
        var node = new mathMLTree2.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options2)]);
        switch (group.label) {
          case "\\cancel":
            node.setAttribute("notation", "updiagonalstrike");
            break;
          case "\\bcancel":
            node.setAttribute("notation", "downdiagonalstrike");
            break;
          case "\\phase":
            node.setAttribute("notation", "phasorangle");
            break;
          case "\\sout":
            node.setAttribute("notation", "horizontalstrike");
            break;
          case "\\fbox":
            node.setAttribute("notation", "box");
            break;
          case "\\angl":
            node.setAttribute("notation", "actuarial");
            break;
          case "\\fcolorbox":
          case "\\colorbox":
            fboxsep = options2.fontMetrics().fboxsep * options2.fontMetrics().ptPerEm;
            node.setAttribute("width", "+" + 2 * fboxsep + "pt");
            node.setAttribute("height", "+" + 2 * fboxsep + "pt");
            node.setAttribute("lspace", fboxsep + "pt");
            node.setAttribute("voffset", fboxsep + "pt");
            if (group.label === "\\fcolorbox") {
              var thk = Math.max(options2.fontMetrics().fboxrule, options2.minRuleThickness);
              node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
            }
            break;
          case "\\xcancel":
            node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
            break;
        }
        if (group.backgroundColor) {
          node.setAttribute("mathbackground", group.backgroundColor);
        }
        return node;
      };
      defineFunction2({
        type: "enclose",
        names: ["\\colorbox"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "text"]
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var color = assertNodeType2(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            backgroundColor: color,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction2({
        type: "enclose",
        names: ["\\fcolorbox"],
        props: {
          numArgs: 3,
          allowedInText: true,
          argTypes: ["color", "color", "text"]
        },
        handler: function handler(_ref2, args, optArgs) {
          var parser = _ref2.parser, funcName = _ref2.funcName;
          var borderColor = assertNodeType2(args[0], "color-token").color;
          var backgroundColor = assertNodeType2(args[1], "color-token").color;
          var body = args[2];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            backgroundColor,
            borderColor,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction2({
        type: "enclose",
        names: ["\\fbox"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser = _ref3.parser;
          return {
            type: "enclose",
            mode: parser.mode,
            label: "\\fbox",
            body: args[0]
          };
        }
      });
      defineFunction2({
        type: "enclose",
        names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref4, args) {
          var parser = _ref4.parser, funcName = _ref4.funcName;
          var body = args[0];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction2({
        type: "enclose",
        names: ["\\angl"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: false
        },
        handler: function handler(_ref5, args) {
          var parser = _ref5.parser;
          return {
            type: "enclose",
            mode: parser.mode,
            label: "\\angl",
            body: args[0]
          };
        }
      });
      var _environments2 = {};
      function defineEnvironment2(_ref) {
        var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder4 = _ref.htmlBuilder, mathmlBuilder4 = _ref.mathmlBuilder;
        var data2 = {
          type,
          numArgs: props.numArgs || 0,
          allowedInText: false,
          numOptionalArgs: 0,
          handler
        };
        for (var i3 = 0; i3 < names.length; ++i3) {
          _environments2[names[i3]] = data2;
        }
        if (htmlBuilder4) {
          _htmlGroupBuilders2[type] = htmlBuilder4;
        }
        if (mathmlBuilder4) {
          _mathmlGroupBuilders2[type] = mathmlBuilder4;
        }
      }
      function getHLines2(parser) {
        var hlineInfo = [];
        parser.consumeSpaces();
        var nxt = parser.fetch().text;
        while (nxt === "\\hline" || nxt === "\\hdashline") {
          parser.consume();
          hlineInfo.push(nxt === "\\hdashline");
          parser.consumeSpaces();
          nxt = parser.fetch().text;
        }
        return hlineInfo;
      }
      var validateAmsEnvironmentContext2 = function validateAmsEnvironmentContext3(context2) {
        var settings = context2.parser.settings;
        if (!settings.displayMode) {
          throw new src_ParseError("{" + context2.envName + "} can be used only in display mode.");
        }
      };
      function parseArray2(parser, _ref, style) {
        var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter, addJot = _ref.addJot, cols = _ref.cols, arraystretch = _ref.arraystretch, colSeparationType = _ref.colSeparationType, addEqnNum = _ref.addEqnNum, singleRow = _ref.singleRow, emptySingleRow = _ref.emptySingleRow, maxNumCols = _ref.maxNumCols, leqno = _ref.leqno;
        parser.gullet.beginGroup();
        if (!singleRow) {
          parser.gullet.macros.set("\\cr", "\\\\\\relax");
        }
        if (!arraystretch) {
          var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
          if (stretch == null) {
            arraystretch = 1;
          } else {
            arraystretch = parseFloat(stretch);
            if (!arraystretch || arraystretch < 0) {
              throw new src_ParseError("Invalid \\arraystretch: " + stretch);
            }
          }
        }
        parser.gullet.beginGroup();
        var row = [];
        var body = [row];
        var rowGaps = [];
        var hLinesBeforeRow = [];
        hLinesBeforeRow.push(getHLines2(parser));
        while (true) {
          var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
          parser.gullet.endGroup();
          parser.gullet.beginGroup();
          cell = {
            type: "ordgroup",
            mode: parser.mode,
            body: cell
          };
          if (style) {
            cell = {
              type: "styling",
              mode: parser.mode,
              style,
              body: [cell]
            };
          }
          row.push(cell);
          var next = parser.fetch().text;
          if (next === "&") {
            if (maxNumCols && row.length === maxNumCols) {
              if (singleRow || colSeparationType) {
                throw new src_ParseError("Too many tab characters: &", parser.nextToken);
              } else {
                parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
              }
            }
            parser.consume();
          } else if (next === "\\end") {
            if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
              body.pop();
            }
            if (hLinesBeforeRow.length < body.length + 1) {
              hLinesBeforeRow.push([]);
            }
            break;
          } else if (next === "\\\\") {
            parser.consume();
            var size = void 0;
            if (parser.gullet.future().text !== " ") {
              size = parser.parseSizeGroup(true);
            }
            rowGaps.push(size ? size.value : null);
            hLinesBeforeRow.push(getHLines2(parser));
            row = [];
            body.push(row);
          } else {
            throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
          }
        }
        parser.gullet.endGroup();
        parser.gullet.endGroup();
        return {
          type: "array",
          mode: parser.mode,
          addJot,
          arraystretch,
          body,
          cols,
          rowGaps,
          hskipBeforeAndAfter,
          hLinesBeforeRow,
          colSeparationType,
          addEqnNum,
          leqno
        };
      }
      function dCellStyle2(envName) {
        if (envName.substr(0, 1) === "d") {
          return "display";
        } else {
          return "text";
        }
      }
      var array_htmlBuilder = function htmlBuilder4(group, options2) {
        var r2;
        var c2;
        var nr = group.body.length;
        var hLinesBeforeRow = group.hLinesBeforeRow;
        var nc = 0;
        var body = new Array(nr);
        var hlines = [];
        var ruleThickness = Math.max(options2.fontMetrics().arrayRuleWidth, options2.minRuleThickness);
        var pt = 1 / options2.fontMetrics().ptPerEm;
        var arraycolsep = 5 * pt;
        if (group.colSeparationType && group.colSeparationType === "small") {
          var localMultiplier = options2.havingStyle(src_Style.SCRIPT).sizeMultiplier;
          arraycolsep = 0.2778 * (localMultiplier / options2.sizeMultiplier);
        }
        var baselineskip = group.colSeparationType === "CD" ? calculateSize3({
          number: 3,
          unit: "ex"
        }, options2) : 12 * pt;
        var jot = 3 * pt;
        var arrayskip = group.arraystretch * baselineskip;
        var arstrutHeight = 0.7 * arrayskip;
        var arstrutDepth = 0.3 * arrayskip;
        var totalHeight = 0;
        function setHLinePos(hlinesInGap) {
          for (var i3 = 0; i3 < hlinesInGap.length; ++i3) {
            if (i3 > 0) {
              totalHeight += 0.25;
            }
            hlines.push({
              pos: totalHeight,
              isDashed: hlinesInGap[i3]
            });
          }
        }
        setHLinePos(hLinesBeforeRow[0]);
        for (r2 = 0; r2 < group.body.length; ++r2) {
          var inrow = group.body[r2];
          var height = arstrutHeight;
          var depth = arstrutDepth;
          if (nc < inrow.length) {
            nc = inrow.length;
          }
          var outrow = new Array(inrow.length);
          for (c2 = 0; c2 < inrow.length; ++c2) {
            var elt = buildGroup4(inrow[c2], options2);
            if (depth < elt.depth) {
              depth = elt.depth;
            }
            if (height < elt.height) {
              height = elt.height;
            }
            outrow[c2] = elt;
          }
          var rowGap = group.rowGaps[r2];
          var gap = 0;
          if (rowGap) {
            gap = calculateSize3(rowGap, options2);
            if (gap > 0) {
              gap += arstrutDepth;
              if (depth < gap) {
                depth = gap;
              }
              gap = 0;
            }
          }
          if (group.addJot) {
            depth += jot;
          }
          outrow.height = height;
          outrow.depth = depth;
          totalHeight += height;
          outrow.pos = totalHeight;
          totalHeight += depth + gap;
          body[r2] = outrow;
          setHLinePos(hLinesBeforeRow[r2 + 1]);
        }
        var offset = totalHeight / 2 + options2.fontMetrics().axisHeight;
        var colDescriptions = group.cols || [];
        var cols = [];
        var colSep;
        var colDescrNum;
        var eqnNumSpans = [];
        if (group.addEqnNum) {
          for (r2 = 0; r2 < nr; ++r2) {
            var rw = body[r2];
            var shift = rw.pos - offset;
            var eqnTag = buildCommon2.makeSpan(["eqn-num"], [], options2);
            eqnTag.depth = rw.depth;
            eqnTag.height = rw.height;
            eqnNumSpans.push({
              type: "elem",
              elem: eqnTag,
              shift
            });
          }
        }
        for (c2 = 0, colDescrNum = 0; c2 < nc || colDescrNum < colDescriptions.length; ++c2, ++colDescrNum) {
          var colDescr = colDescriptions[colDescrNum] || {};
          var firstSeparator = true;
          while (colDescr.type === "separator") {
            if (!firstSeparator) {
              colSep = buildCommon2.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm3(options2.fontMetrics().doubleRuleSep);
              cols.push(colSep);
            }
            if (colDescr.separator === "|" || colDescr.separator === ":") {
              var lineType = colDescr.separator === "|" ? "solid" : "dashed";
              var separator = buildCommon2.makeSpan(["vertical-separator"], [], options2);
              separator.style.height = makeEm3(totalHeight);
              separator.style.borderRightWidth = makeEm3(ruleThickness);
              separator.style.borderRightStyle = lineType;
              separator.style.margin = "0 " + makeEm3(-ruleThickness / 2);
              var _shift = totalHeight - offset;
              if (_shift) {
                separator.style.verticalAlign = makeEm3(-_shift);
              }
              cols.push(separator);
            } else {
              throw new src_ParseError("Invalid separator type: " + colDescr.separator);
            }
            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
          }
          if (c2 >= nc) {
            continue;
          }
          var sepwidth = void 0;
          if (c2 > 0 || group.hskipBeforeAndAfter) {
            sepwidth = utils2.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon2.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm3(sepwidth);
              cols.push(colSep);
            }
          }
          var col = [];
          for (r2 = 0; r2 < nr; ++r2) {
            var row = body[r2];
            var elem = row[c2];
            if (!elem) {
              continue;
            }
            var _shift2 = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({
              type: "elem",
              elem,
              shift: _shift2
            });
          }
          col = buildCommon2.makeVList({
            positionType: "individualShift",
            children: col
          }, options2);
          col = buildCommon2.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
          cols.push(col);
          if (c2 < nc - 1 || group.hskipBeforeAndAfter) {
            sepwidth = utils2.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon2.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm3(sepwidth);
              cols.push(colSep);
            }
          }
        }
        body = buildCommon2.makeSpan(["mtable"], cols);
        if (hlines.length > 0) {
          var line = buildCommon2.makeLineSpan("hline", options2, ruleThickness);
          var dashes = buildCommon2.makeLineSpan("hdashline", options2, ruleThickness);
          var vListElems = [{
            type: "elem",
            elem: body,
            shift: 0
          }];
          while (hlines.length > 0) {
            var hline = hlines.pop();
            var lineShift = hline.pos - offset;
            if (hline.isDashed) {
              vListElems.push({
                type: "elem",
                elem: dashes,
                shift: lineShift
              });
            } else {
              vListElems.push({
                type: "elem",
                elem: line,
                shift: lineShift
              });
            }
          }
          body = buildCommon2.makeVList({
            positionType: "individualShift",
            children: vListElems
          }, options2);
        }
        if (!group.addEqnNum) {
          return buildCommon2.makeSpan(["mord"], [body], options2);
        } else {
          var eqnNumCol = buildCommon2.makeVList({
            positionType: "individualShift",
            children: eqnNumSpans
          }, options2);
          eqnNumCol = buildCommon2.makeSpan(["tag"], [eqnNumCol], options2);
          return buildCommon2.makeFragment([body, eqnNumCol]);
        }
      };
      var alignMap2 = {
        c: "center ",
        l: "left ",
        r: "right "
      };
      var array_mathmlBuilder = function mathmlBuilder4(group, options2) {
        var tbl = [];
        var glue = new mathMLTree2.MathNode("mtd", [], ["mtr-glue"]);
        var tag2 = new mathMLTree2.MathNode("mtd", [], ["mml-eqn-num"]);
        for (var i3 = 0; i3 < group.body.length; i3++) {
          var rw = group.body[i3];
          var row = [];
          for (var j2 = 0; j2 < rw.length; j2++) {
            row.push(new mathMLTree2.MathNode("mtd", [buildMathML_buildGroup(rw[j2], options2)]));
          }
          if (group.addEqnNum) {
            row.unshift(glue);
            row.push(glue);
            if (group.leqno) {
              row.unshift(tag2);
            } else {
              row.push(tag2);
            }
          }
          tbl.push(new mathMLTree2.MathNode("mtr", row));
        }
        var table = new mathMLTree2.MathNode("mtable", tbl);
        var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
        table.setAttribute("rowspacing", makeEm3(gap));
        var menclose = "";
        var align = "";
        if (group.cols && group.cols.length > 0) {
          var cols = group.cols;
          var columnLines = "";
          var prevTypeWasAlign = false;
          var iStart = 0;
          var iEnd = cols.length;
          if (cols[0].type === "separator") {
            menclose += "top ";
            iStart = 1;
          }
          if (cols[cols.length - 1].type === "separator") {
            menclose += "bottom ";
            iEnd -= 1;
          }
          for (var _i7 = iStart; _i7 < iEnd; _i7++) {
            if (cols[_i7].type === "align") {
              align += alignMap2[cols[_i7].align];
              if (prevTypeWasAlign) {
                columnLines += "none ";
              }
              prevTypeWasAlign = true;
            } else if (cols[_i7].type === "separator") {
              if (prevTypeWasAlign) {
                columnLines += cols[_i7].separator === "|" ? "solid " : "dashed ";
                prevTypeWasAlign = false;
              }
            }
          }
          table.setAttribute("columnalign", align.trim());
          if (/[sd]/.test(columnLines)) {
            table.setAttribute("columnlines", columnLines.trim());
          }
        }
        if (group.colSeparationType === "align") {
          var _cols = group.cols || [];
          var spacing3 = "";
          for (var _i23 = 1; _i23 < _cols.length; _i23++) {
            spacing3 += _i23 % 2 ? "0em " : "1em ";
          }
          table.setAttribute("columnspacing", spacing3.trim());
        } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
          table.setAttribute("columnspacing", "0em");
        } else if (group.colSeparationType === "small") {
          table.setAttribute("columnspacing", "0.2778em");
        } else if (group.colSeparationType === "CD") {
          table.setAttribute("columnspacing", "0.5em");
        } else {
          table.setAttribute("columnspacing", "1em");
        }
        var rowLines = "";
        var hlines = group.hLinesBeforeRow;
        menclose += hlines[0].length > 0 ? "left " : "";
        menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
        for (var _i33 = 1; _i33 < hlines.length - 1; _i33++) {
          rowLines += hlines[_i33].length === 0 ? "none " : hlines[_i33][0] ? "dashed " : "solid ";
        }
        if (/[sd]/.test(rowLines)) {
          table.setAttribute("rowlines", rowLines.trim());
        }
        if (menclose !== "") {
          table = new mathMLTree2.MathNode("menclose", [table]);
          table.setAttribute("notation", menclose.trim());
        }
        if (group.arraystretch && group.arraystretch < 1) {
          table = new mathMLTree2.MathNode("mstyle", [table]);
          table.setAttribute("scriptlevel", "1");
        }
        return table;
      };
      var alignedHandler3 = function alignedHandler4(context2, args) {
        if (context2.envName.indexOf("ed") === -1) {
          validateAmsEnvironmentContext2(context2);
        }
        var cols = [];
        var separationType = context2.envName.indexOf("at") > -1 ? "alignat" : "align";
        var res = parseArray2(context2.parser, {
          cols,
          addJot: true,
          addEqnNum: context2.envName === "align" || context2.envName === "alignat",
          emptySingleRow: true,
          colSeparationType: separationType,
          maxNumCols: context2.envName === "split" ? 2 : void 0,
          leqno: context2.parser.settings.leqno
        }, "display");
        var numMaths;
        var numCols = 0;
        var emptyGroup = {
          type: "ordgroup",
          mode: context2.mode,
          body: []
        };
        if (args[0] && args[0].type === "ordgroup") {
          var arg0 = "";
          for (var i3 = 0; i3 < args[0].body.length; i3++) {
            var textord3 = assertNodeType2(args[0].body[i3], "textord");
            arg0 += textord3.text;
          }
          numMaths = Number(arg0);
          numCols = numMaths * 2;
        }
        var isAligned = !numCols;
        res.body.forEach(function(row) {
          for (var _i43 = 1; _i43 < row.length; _i43 += 2) {
            var styling = assertNodeType2(row[_i43], "styling");
            var ordgroup = assertNodeType2(styling.body[0], "ordgroup");
            ordgroup.body.unshift(emptyGroup);
          }
          if (!isAligned) {
            var curMaths = row.length / 2;
            if (numMaths < curMaths) {
              throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
            }
          } else if (numCols < row.length) {
            numCols = row.length;
          }
        });
        for (var _i53 = 0; _i53 < numCols; ++_i53) {
          var align = "r";
          var pregap = 0;
          if (_i53 % 2 === 1) {
            align = "l";
          } else if (_i53 > 0 && isAligned) {
            pregap = 1;
          }
          cols[_i53] = {
            type: "align",
            align,
            pregap,
            postgap: 0
          };
        }
        res.colSeparationType = isAligned ? "align" : "alignat";
        return res;
      };
      defineEnvironment2({
        type: "array",
        names: ["array", "darray"],
        props: {
          numArgs: 1
        },
        handler: function handler(context2, args) {
          var symNode = checkSymbolNodeType2(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType2(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node = assertSymbolNodeType2(nde);
            var ca = node.text;
            if ("lcr".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            } else if (ca === "|") {
              return {
                type: "separator",
                separator: "|"
              };
            } else if (ca === ":") {
              return {
                type: "separator",
                separator: ":"
              };
            }
            throw new src_ParseError("Unknown column alignment: " + ca, nde);
          });
          var res = {
            cols,
            hskipBeforeAndAfter: true,
            maxNumCols: cols.length
          };
          return parseArray2(context2.parser, res, dCellStyle2(context2.envName));
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context2) {
          var delimiters3 = {
            "matrix": null,
            "pmatrix": ["(", ")"],
            "bmatrix": ["[", "]"],
            "Bmatrix": ["\\{", "\\}"],
            "vmatrix": ["|", "|"],
            "Vmatrix": ["\\Vert", "\\Vert"]
          }[context2.envName.replace("*", "")];
          var colAlign = "c";
          var payload = {
            hskipBeforeAndAfter: false,
            cols: [{
              type: "align",
              align: colAlign
            }]
          };
          if (context2.envName.charAt(context2.envName.length - 1) === "*") {
            var parser = context2.parser;
            parser.consumeSpaces();
            if (parser.fetch().text === "[") {
              parser.consume();
              parser.consumeSpaces();
              colAlign = parser.fetch().text;
              if ("lcr".indexOf(colAlign) === -1) {
                throw new src_ParseError("Expected l or c or r", parser.nextToken);
              }
              parser.consume();
              parser.consumeSpaces();
              parser.expect("]");
              parser.consume();
              payload.cols = [{
                type: "align",
                align: colAlign
              }];
            }
          }
          var res = parseArray2(context2.parser, payload, dCellStyle2(context2.envName));
          var numCols = Math.max.apply(Math, [0].concat(res.body.map(function(row) {
            return row.length;
          })));
          res.cols = new Array(numCols).fill({
            type: "align",
            align: colAlign
          });
          return delimiters3 ? {
            type: "leftright",
            mode: context2.mode,
            body: [res],
            left: delimiters3[0],
            right: delimiters3[1],
            rightColor: void 0
          } : res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["smallmatrix"],
        props: {
          numArgs: 0
        },
        handler: function handler(context2) {
          var payload = {
            arraystretch: 0.5
          };
          var res = parseArray2(context2.parser, payload, "script");
          res.colSeparationType = "small";
          return res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["subarray"],
        props: {
          numArgs: 1
        },
        handler: function handler(context2, args) {
          var symNode = checkSymbolNodeType2(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType2(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node = assertSymbolNodeType2(nde);
            var ca = node.text;
            if ("lc".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            }
            throw new src_ParseError("Unknown column alignment: " + ca, nde);
          });
          if (cols.length > 1) {
            throw new src_ParseError("{subarray} can contain only one column");
          }
          var res = {
            cols,
            hskipBeforeAndAfter: false,
            arraystretch: 0.5
          };
          res = parseArray2(context2.parser, res, "script");
          if (res.body.length > 0 && res.body[0].length > 1) {
            throw new src_ParseError("{subarray} can contain only one column");
          }
          return res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["cases", "dcases", "rcases", "drcases"],
        props: {
          numArgs: 0
        },
        handler: function handler(context2) {
          var payload = {
            arraystretch: 1.2,
            cols: [{
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 1
            }, {
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 0
            }]
          };
          var res = parseArray2(context2.parser, payload, dCellStyle2(context2.envName));
          return {
            type: "leftright",
            mode: context2.mode,
            body: [res],
            left: context2.envName.indexOf("r") > -1 ? "." : "\\{",
            right: context2.envName.indexOf("r") > -1 ? "\\}" : ".",
            rightColor: void 0
          };
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["align", "align*", "aligned", "split"],
        props: {
          numArgs: 0
        },
        handler: alignedHandler3,
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["gathered", "gather", "gather*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context2) {
          if (utils2.contains(["gather", "gather*"], context2.envName)) {
            validateAmsEnvironmentContext2(context2);
          }
          var res = {
            cols: [{
              type: "align",
              align: "c"
            }],
            addJot: true,
            colSeparationType: "gather",
            addEqnNum: context2.envName === "gather",
            emptySingleRow: true,
            leqno: context2.parser.settings.leqno
          };
          return parseArray2(context2.parser, res, "display");
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["alignat", "alignat*", "alignedat"],
        props: {
          numArgs: 1
        },
        handler: alignedHandler3,
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["equation", "equation*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context2) {
          validateAmsEnvironmentContext2(context2);
          var res = {
            addEqnNum: context2.envName === "equation",
            emptySingleRow: true,
            singleRow: true,
            maxNumCols: 1,
            leqno: context2.parser.settings.leqno
          };
          return parseArray2(context2.parser, res, "display");
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment2({
        type: "array",
        names: ["CD"],
        props: {
          numArgs: 0
        },
        handler: function handler(context2) {
          validateAmsEnvironmentContext2(context2);
          return parseCD2(context2.parser);
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineFunction2({
        type: "text",
        names: ["\\hline", "\\hdashline"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: true
        },
        handler: function handler(context2, args) {
          throw new src_ParseError(context2.funcName + " valid only within array environment");
        }
      });
      var environments2 = _environments2;
      var src_environments = environments2;
      defineFunction2({
        type: "environment",
        names: ["\\begin", "\\end"],
        props: {
          numArgs: 1,
          argTypes: ["text"]
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var nameGroup = args[0];
          if (nameGroup.type !== "ordgroup") {
            throw new src_ParseError("Invalid environment name", nameGroup);
          }
          var envName = "";
          for (var i3 = 0; i3 < nameGroup.body.length; ++i3) {
            envName += assertNodeType2(nameGroup.body[i3], "textord").text;
          }
          if (funcName === "\\begin") {
            if (!src_environments.hasOwnProperty(envName)) {
              throw new src_ParseError("No such environment: " + envName, nameGroup);
            }
            var env = src_environments[envName];
            var _parser$parseArgument = parser.parseArguments("\\begin{" + envName + "}", env), _args = _parser$parseArgument.args, optArgs = _parser$parseArgument.optArgs;
            var context2 = {
              mode: parser.mode,
              envName,
              parser
            };
            var result2 = env.handler(context2, _args, optArgs);
            parser.expect("\\end", false);
            var endNameToken = parser.nextToken;
            var end = assertNodeType2(parser.parseFunction(), "environment");
            if (end.name !== envName) {
              throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
            }
            return result2;
          }
          return {
            type: "environment",
            mode: parser.mode,
            name: envName,
            nameGroup
          };
        }
      });
      var mclass_makeSpan = buildCommon2.makeSpan;
      function mclass_htmlBuilder(group, options2) {
        var elements = buildExpression4(group.body, options2, true);
        return mclass_makeSpan([group.mclass], elements, options2);
      }
      function mclass_mathmlBuilder(group, options2) {
        var node;
        var inner3 = buildMathML_buildExpression(group.body, options2);
        if (group.mclass === "minner") {
          return mathMLTree2.newDocumentFragment(inner3);
        } else if (group.mclass === "mord") {
          if (group.isCharacterBox) {
            node = inner3[0];
            node.type = "mi";
          } else {
            node = new mathMLTree2.MathNode("mi", inner3);
          }
        } else {
          if (group.isCharacterBox) {
            node = inner3[0];
            node.type = "mo";
          } else {
            node = new mathMLTree2.MathNode("mo", inner3);
          }
          if (group.mclass === "mbin") {
            node.attributes.lspace = "0.22em";
            node.attributes.rspace = "0.22em";
          } else if (group.mclass === "mpunct") {
            node.attributes.lspace = "0em";
            node.attributes.rspace = "0.17em";
          } else if (group.mclass === "mopen" || group.mclass === "mclose") {
            node.attributes.lspace = "0em";
            node.attributes.rspace = "0em";
          }
        }
        return node;
      }
      defineFunction2({
        type: "mclass",
        names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: "m" + funcName.substr(5),
            body: ordargument3(body),
            isCharacterBox: utils2.isCharacterBox(body)
          };
        },
        htmlBuilder: mclass_htmlBuilder,
        mathmlBuilder: mclass_mathmlBuilder
      });
      var binrelClass2 = function binrelClass3(arg) {
        var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
        if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
          return "m" + atom.family;
        } else {
          return "mord";
        }
      };
      defineFunction2({
        type: "mclass",
        names: ["\\@binrel"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: binrelClass2(args[0]),
            body: ordargument3(args[1]),
            isCharacterBox: utils2.isCharacterBox(args[1])
          };
        }
      });
      defineFunction2({
        type: "mclass",
        names: ["\\stackrel", "\\overset", "\\underset"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref3, args) {
          var parser = _ref3.parser, funcName = _ref3.funcName;
          var baseArg = args[1];
          var shiftedArg = args[0];
          var mclass;
          if (funcName !== "\\stackrel") {
            mclass = binrelClass2(baseArg);
          } else {
            mclass = "mrel";
          }
          var baseOp = {
            type: "op",
            mode: baseArg.mode,
            limits: true,
            alwaysHandleSupSub: true,
            parentIsSupSub: false,
            symbol: false,
            suppressBaseShift: funcName !== "\\stackrel",
            body: ordargument3(baseArg)
          };
          var supsub = {
            type: "supsub",
            mode: shiftedArg.mode,
            base: baseOp,
            sup: funcName === "\\underset" ? null : shiftedArg,
            sub: funcName === "\\underset" ? shiftedArg : null
          };
          return {
            type: "mclass",
            mode: parser.mode,
            mclass,
            body: [supsub],
            isCharacterBox: utils2.isCharacterBox(supsub)
          };
        },
        htmlBuilder: mclass_htmlBuilder,
        mathmlBuilder: mclass_mathmlBuilder
      });
      var font_htmlBuilder = function htmlBuilder4(group, options2) {
        var font = group.font;
        var newOptions = options2.withFont(font);
        return buildGroup4(group.body, newOptions);
      };
      var font_mathmlBuilder = function mathmlBuilder4(group, options2) {
        var font = group.font;
        var newOptions = options2.withFont(font);
        return buildMathML_buildGroup(group.body, newOptions);
      };
      var fontAliases2 = {
        "\\Bbb": "\\mathbb",
        "\\bold": "\\mathbf",
        "\\frak": "\\mathfrak",
        "\\bm": "\\boldsymbol"
      };
      defineFunction2({
        type: "font",
        names: [
          "\\mathrm",
          "\\mathit",
          "\\mathbf",
          "\\mathnormal",
          "\\mathbb",
          "\\mathcal",
          "\\mathfrak",
          "\\mathscr",
          "\\mathsf",
          "\\mathtt",
          "\\Bbb",
          "\\bold",
          "\\frak"
        ],
        props: {
          numArgs: 1,
          allowedInArgument: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = normalizeArgument3(args[0]);
          var func = funcName;
          if (func in fontAliases2) {
            func = fontAliases2[func];
          }
          return {
            type: "font",
            mode: parser.mode,
            font: func.slice(1),
            body
          };
        },
        htmlBuilder: font_htmlBuilder,
        mathmlBuilder: font_mathmlBuilder
      });
      defineFunction2({
        type: "mclass",
        names: ["\\boldsymbol", "\\bm"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          var body = args[0];
          var isCharacterBox4 = utils2.isCharacterBox(body);
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: binrelClass2(body),
            body: [{
              type: "font",
              mode: parser.mode,
              font: "boldsymbol",
              body
            }],
            isCharacterBox: isCharacterBox4
          };
        }
      });
      defineFunction2({
        type: "font",
        names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser = _ref3.parser, funcName = _ref3.funcName, breakOnTokenText = _ref3.breakOnTokenText;
          var mode = parser.mode;
          var body = parser.parseExpression(true, breakOnTokenText);
          var style = "math" + funcName.slice(1);
          return {
            type: "font",
            mode,
            font: style,
            body: {
              type: "ordgroup",
              mode: parser.mode,
              body
            }
          };
        },
        htmlBuilder: font_htmlBuilder,
        mathmlBuilder: font_mathmlBuilder
      });
      var adjustStyle2 = function adjustStyle3(size, originalStyle) {
        var style = originalStyle;
        if (size === "display") {
          style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
        } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
          style = src_Style.TEXT;
        } else if (size === "script") {
          style = src_Style.SCRIPT;
        } else if (size === "scriptscript") {
          style = src_Style.SCRIPTSCRIPT;
        }
        return style;
      };
      var genfrac_htmlBuilder = function htmlBuilder4(group, options2) {
        var style = adjustStyle2(group.size, options2.style);
        var nstyle = style.fracNum();
        var dstyle = style.fracDen();
        var newOptions;
        newOptions = options2.havingStyle(nstyle);
        var numerm = buildGroup4(group.numer, newOptions, options2);
        if (group.continued) {
          var hStrut = 8.5 / options2.fontMetrics().ptPerEm;
          var dStrut = 3.5 / options2.fontMetrics().ptPerEm;
          numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
          numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
        }
        newOptions = options2.havingStyle(dstyle);
        var denomm = buildGroup4(group.denom, newOptions, options2);
        var rule;
        var ruleWidth;
        var ruleSpacing;
        if (group.hasBarLine) {
          if (group.barSize) {
            ruleWidth = calculateSize3(group.barSize, options2);
            rule = buildCommon2.makeLineSpan("frac-line", options2, ruleWidth);
          } else {
            rule = buildCommon2.makeLineSpan("frac-line", options2);
          }
          ruleWidth = rule.height;
          ruleSpacing = rule.height;
        } else {
          rule = null;
          ruleWidth = 0;
          ruleSpacing = options2.fontMetrics().defaultRuleThickness;
        }
        var numShift;
        var clearance;
        var denomShift;
        if (style.size === src_Style.DISPLAY.size || group.size === "display") {
          numShift = options2.fontMetrics().num1;
          if (ruleWidth > 0) {
            clearance = 3 * ruleSpacing;
          } else {
            clearance = 7 * ruleSpacing;
          }
          denomShift = options2.fontMetrics().denom1;
        } else {
          if (ruleWidth > 0) {
            numShift = options2.fontMetrics().num2;
            clearance = ruleSpacing;
          } else {
            numShift = options2.fontMetrics().num3;
            clearance = 3 * ruleSpacing;
          }
          denomShift = options2.fontMetrics().denom2;
        }
        var frac;
        if (!rule) {
          var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
          if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
          }
          frac = buildCommon2.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options2);
        } else {
          var axisHeight = options2.fontMetrics().axisHeight;
          if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
            numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
          }
          if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
            denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
          }
          var midShift = -(axisHeight - 0.5 * ruleWidth);
          frac = buildCommon2.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: rule,
              shift: midShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options2);
        }
        newOptions = options2.havingStyle(style);
        frac.height *= newOptions.sizeMultiplier / options2.sizeMultiplier;
        frac.depth *= newOptions.sizeMultiplier / options2.sizeMultiplier;
        var delimSize;
        if (style.size === src_Style.DISPLAY.size) {
          delimSize = options2.fontMetrics().delim1;
        } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
          delimSize = options2.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
        } else {
          delimSize = options2.fontMetrics().delim2;
        }
        var leftDelim;
        var rightDelim;
        if (group.leftDelim == null) {
          leftDelim = makeNullDelimiter3(options2, ["mopen"]);
        } else {
          leftDelim = delimiter2.customSizedDelim(group.leftDelim, delimSize, true, options2.havingStyle(style), group.mode, ["mopen"]);
        }
        if (group.continued) {
          rightDelim = buildCommon2.makeSpan([]);
        } else if (group.rightDelim == null) {
          rightDelim = makeNullDelimiter3(options2, ["mclose"]);
        } else {
          rightDelim = delimiter2.customSizedDelim(group.rightDelim, delimSize, true, options2.havingStyle(style), group.mode, ["mclose"]);
        }
        return buildCommon2.makeSpan(["mord"].concat(newOptions.sizingClasses(options2)), [leftDelim, buildCommon2.makeSpan(["mfrac"], [frac]), rightDelim], options2);
      };
      var genfrac_mathmlBuilder = function mathmlBuilder4(group, options2) {
        var node = new mathMLTree2.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options2), buildMathML_buildGroup(group.denom, options2)]);
        if (!group.hasBarLine) {
          node.setAttribute("linethickness", "0px");
        } else if (group.barSize) {
          var ruleWidth = calculateSize3(group.barSize, options2);
          node.setAttribute("linethickness", makeEm3(ruleWidth));
        }
        var style = adjustStyle2(group.size, options2.style);
        if (style.size !== options2.style.size) {
          node = new mathMLTree2.MathNode("mstyle", [node]);
          var isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
          node.setAttribute("displaystyle", isDisplay);
          node.setAttribute("scriptlevel", "0");
        }
        if (group.leftDelim != null || group.rightDelim != null) {
          var withDelims = [];
          if (group.leftDelim != null) {
            var leftOp = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode(group.leftDelim.replace("\\", ""))]);
            leftOp.setAttribute("fence", "true");
            withDelims.push(leftOp);
          }
          withDelims.push(node);
          if (group.rightDelim != null) {
            var rightOp = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode(group.rightDelim.replace("\\", ""))]);
            rightOp.setAttribute("fence", "true");
            withDelims.push(rightOp);
          }
          return makeRow3(withDelims);
        }
        return node;
      };
      defineFunction2({
        type: "genfrac",
        names: [
          "\\dfrac",
          "\\frac",
          "\\tfrac",
          "\\dbinom",
          "\\binom",
          "\\tbinom",
          "\\\\atopfrac",
          "\\\\bracefrac",
          "\\\\brackfrac"
        ],
        props: {
          numArgs: 2,
          allowedInArgument: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var numer = args[0];
          var denom = args[1];
          var hasBarLine;
          var leftDelim = null;
          var rightDelim = null;
          var size = "auto";
          switch (funcName) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              hasBarLine = true;
              break;
            case "\\\\atopfrac":
              hasBarLine = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              hasBarLine = false;
              leftDelim = "(";
              rightDelim = ")";
              break;
            case "\\\\bracefrac":
              hasBarLine = false;
              leftDelim = "\\{";
              rightDelim = "\\}";
              break;
            case "\\\\brackfrac":
              hasBarLine = false;
              leftDelim = "[";
              rightDelim = "]";
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          switch (funcName) {
            case "\\dfrac":
            case "\\dbinom":
              size = "display";
              break;
            case "\\tfrac":
            case "\\tbinom":
              size = "text";
              break;
          }
          return {
            type: "genfrac",
            mode: parser.mode,
            continued: false,
            numer,
            denom,
            hasBarLine,
            leftDelim,
            rightDelim,
            size,
            barSize: null
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      defineFunction2({
        type: "genfrac",
        names: ["\\cfrac"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          _ref2.funcName;
          var numer = args[0];
          var denom = args[1];
          return {
            type: "genfrac",
            mode: parser.mode,
            continued: true,
            numer,
            denom,
            hasBarLine: true,
            leftDelim: null,
            rightDelim: null,
            size: "display",
            barSize: null
          };
        }
      });
      defineFunction2({
        type: "infix",
        names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
        props: {
          numArgs: 0,
          infix: true
        },
        handler: function handler(_ref3) {
          var parser = _ref3.parser, funcName = _ref3.funcName, token = _ref3.token;
          var replaceWith;
          switch (funcName) {
            case "\\over":
              replaceWith = "\\frac";
              break;
            case "\\choose":
              replaceWith = "\\binom";
              break;
            case "\\atop":
              replaceWith = "\\\\atopfrac";
              break;
            case "\\brace":
              replaceWith = "\\\\bracefrac";
              break;
            case "\\brack":
              replaceWith = "\\\\brackfrac";
              break;
            default:
              throw new Error("Unrecognized infix genfrac command");
          }
          return {
            type: "infix",
            mode: parser.mode,
            replaceWith,
            token
          };
        }
      });
      var stylArray2 = ["display", "text", "script", "scriptscript"];
      var delimFromValue3 = function delimFromValue4(delimString) {
        var delim = null;
        if (delimString.length > 0) {
          delim = delimString;
          delim = delim === "." ? null : delim;
        }
        return delim;
      };
      defineFunction2({
        type: "genfrac",
        names: ["\\genfrac"],
        props: {
          numArgs: 6,
          allowedInArgument: true,
          argTypes: ["math", "math", "size", "text", "math", "math"]
        },
        handler: function handler(_ref4, args) {
          var parser = _ref4.parser;
          var numer = args[4];
          var denom = args[5];
          var leftNode = normalizeArgument3(args[0]);
          var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue3(leftNode.text) : null;
          var rightNode = normalizeArgument3(args[1]);
          var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue3(rightNode.text) : null;
          var barNode = assertNodeType2(args[2], "size");
          var hasBarLine;
          var barSize = null;
          if (barNode.isBlank) {
            hasBarLine = true;
          } else {
            barSize = barNode.value;
            hasBarLine = barSize.number > 0;
          }
          var size = "auto";
          var styl = args[3];
          if (styl.type === "ordgroup") {
            if (styl.body.length > 0) {
              var textOrd = assertNodeType2(styl.body[0], "textord");
              size = stylArray2[Number(textOrd.text)];
            }
          } else {
            styl = assertNodeType2(styl, "textord");
            size = stylArray2[Number(styl.text)];
          }
          return {
            type: "genfrac",
            mode: parser.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim,
            rightDelim,
            size
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      defineFunction2({
        type: "infix",
        names: ["\\above"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          infix: true
        },
        handler: function handler(_ref5, args) {
          var parser = _ref5.parser;
          _ref5.funcName;
          var token = _ref5.token;
          return {
            type: "infix",
            mode: parser.mode,
            replaceWith: "\\\\abovefrac",
            size: assertNodeType2(args[0], "size").value,
            token
          };
        }
      });
      defineFunction2({
        type: "genfrac",
        names: ["\\\\abovefrac"],
        props: {
          numArgs: 3,
          argTypes: ["math", "size", "math"]
        },
        handler: function handler(_ref6, args) {
          var parser = _ref6.parser;
          _ref6.funcName;
          var numer = args[0];
          var barSize = assert3(assertNodeType2(args[1], "infix").size);
          var denom = args[2];
          var hasBarLine = barSize.number > 0;
          return {
            type: "genfrac",
            mode: parser.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim: null,
            rightDelim: null,
            size: "auto"
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      var horizBrace_htmlBuilder = function htmlBuilder4(grp, options2) {
        var style = options2.style;
        var supSubGroup;
        var group;
        if (grp.type === "supsub") {
          supSubGroup = grp.sup ? buildGroup4(grp.sup, options2.havingStyle(style.sup()), options2) : buildGroup4(grp.sub, options2.havingStyle(style.sub()), options2);
          group = assertNodeType2(grp.base, "horizBrace");
        } else {
          group = assertNodeType2(grp, "horizBrace");
        }
        var body = buildGroup4(group.base, options2.havingBaseStyle(src_Style.DISPLAY));
        var braceBody = stretchy2.svgSpan(group, options2);
        var vlist;
        if (group.isOver) {
          vlist = buildCommon2.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: braceBody
            }]
          }, options2);
          vlist.children[0].children[0].children[1].classes.push("svg-align");
        } else {
          vlist = buildCommon2.makeVList({
            positionType: "bottom",
            positionData: body.depth + 0.1 + braceBody.height,
            children: [{
              type: "elem",
              elem: braceBody
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: body
            }]
          }, options2);
          vlist.children[0].children[0].children[0].classes.push("svg-align");
        }
        if (supSubGroup) {
          var vSpan = buildCommon2.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options2);
          if (group.isOver) {
            vlist = buildCommon2.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: vSpan
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: supSubGroup
              }]
            }, options2);
          } else {
            vlist = buildCommon2.makeVList({
              positionType: "bottom",
              positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
              children: [{
                type: "elem",
                elem: supSubGroup
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: vSpan
              }]
            }, options2);
          }
        }
        return buildCommon2.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options2);
      };
      var horizBrace_mathmlBuilder = function mathmlBuilder4(group, options2) {
        var accentNode = stretchy2.mathMLnode(group.label);
        return new mathMLTree2.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options2), accentNode]);
      };
      defineFunction2({
        type: "horizBrace",
        names: ["\\overbrace", "\\underbrace"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          return {
            type: "horizBrace",
            mode: parser.mode,
            label: funcName,
            isOver: /^\\over/.test(funcName),
            base: args[0]
          };
        },
        htmlBuilder: horizBrace_htmlBuilder,
        mathmlBuilder: horizBrace_mathmlBuilder
      });
      defineFunction2({
        type: "href",
        names: ["\\href"],
        props: {
          numArgs: 2,
          argTypes: ["url", "original"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var body = args[1];
          var href = assertNodeType2(args[0], "url").url;
          if (!parser.settings.isTrusted({
            command: "\\href",
            url: href
          })) {
            return parser.formatUnsupportedCmd("\\href");
          }
          return {
            type: "href",
            mode: parser.mode,
            href,
            body: ordargument3(body)
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var elements = buildExpression4(group.body, options2, false);
          return buildCommon2.makeAnchor(group.href, [], elements, options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var math3 = buildExpressionRow3(group.body, options2);
          if (!(math3 instanceof MathNode2)) {
            math3 = new MathNode2("mrow", [math3]);
          }
          math3.setAttribute("href", group.href);
          return math3;
        }
      });
      defineFunction2({
        type: "href",
        names: ["\\url"],
        props: {
          numArgs: 1,
          argTypes: ["url"],
          allowedInText: true
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          var href = assertNodeType2(args[0], "url").url;
          if (!parser.settings.isTrusted({
            command: "\\url",
            url: href
          })) {
            return parser.formatUnsupportedCmd("\\url");
          }
          var chars = [];
          for (var i3 = 0; i3 < href.length; i3++) {
            var c2 = href[i3];
            if (c2 === "~") {
              c2 = "\\textasciitilde";
            }
            chars.push({
              type: "textord",
              mode: "text",
              text: c2
            });
          }
          var body = {
            type: "text",
            mode: parser.mode,
            font: "\\texttt",
            body: chars
          };
          return {
            type: "href",
            mode: parser.mode,
            href,
            body: ordargument3(body)
          };
        }
      });
      defineFunction2({
        type: "hbox",
        names: ["\\hbox"],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "hbox",
            mode: parser.mode,
            body: ordargument3(args[0])
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var elements = buildExpression4(group.body, options2, false);
          return buildCommon2.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          return new mathMLTree2.MathNode("mrow", buildMathML_buildExpression(group.body, options2));
        }
      });
      defineFunction2({
        type: "html",
        names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
        props: {
          numArgs: 2,
          argTypes: ["raw", "original"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          _ref.token;
          var value = assertNodeType2(args[0], "raw").string;
          var body = args[1];
          if (parser.settings.strict) {
            parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
          }
          var trustContext;
          var attributes = {};
          switch (funcName) {
            case "\\htmlClass":
              attributes.class = value;
              trustContext = {
                command: "\\htmlClass",
                class: value
              };
              break;
            case "\\htmlId":
              attributes.id = value;
              trustContext = {
                command: "\\htmlId",
                id: value
              };
              break;
            case "\\htmlStyle":
              attributes.style = value;
              trustContext = {
                command: "\\htmlStyle",
                style: value
              };
              break;
            case "\\htmlData": {
              var data2 = value.split(",");
              for (var i3 = 0; i3 < data2.length; i3++) {
                var keyVal = data2[i3].split("=");
                if (keyVal.length !== 2) {
                  throw new src_ParseError("Error parsing key-value for \\htmlData");
                }
                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }
              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }
            default:
              throw new Error("Unrecognized html command");
          }
          if (!parser.settings.isTrusted(trustContext)) {
            return parser.formatUnsupportedCmd(funcName);
          }
          return {
            type: "html",
            mode: parser.mode,
            attributes,
            body: ordargument3(body)
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var elements = buildExpression4(group.body, options2, false);
          var classes = ["enclosing"];
          if (group.attributes.class) {
            classes.push.apply(classes, group.attributes.class.trim().split(/\s+/));
          }
          var span = buildCommon2.makeSpan(classes, elements, options2);
          for (var attr in group.attributes) {
            if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
              span.setAttribute(attr, group.attributes[attr]);
            }
          }
          return span;
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          return buildExpressionRow3(group.body, options2);
        }
      });
      defineFunction2({
        type: "htmlmathml",
        names: ["\\html@mathml"],
        props: {
          numArgs: 2,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "htmlmathml",
            mode: parser.mode,
            html: ordargument3(args[0]),
            mathml: ordargument3(args[1])
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var elements = buildExpression4(group.html, options2, false);
          return buildCommon2.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          return buildExpressionRow3(group.mathml, options2);
        }
      });
      var sizeData3 = function sizeData4(str2) {
        if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str2)) {
          return {
            number: +str2,
            unit: "bp"
          };
        } else {
          var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str2);
          if (!match2) {
            throw new src_ParseError("Invalid size: '" + str2 + "' in \\includegraphics");
          }
          var data2 = {
            number: +(match2[1] + match2[2]),
            unit: match2[3]
          };
          if (!validUnit3(data2)) {
            throw new src_ParseError("Invalid unit: '" + data2.unit + "' in \\includegraphics.");
          }
          return data2;
        }
      };
      defineFunction2({
        type: "includegraphics",
        names: ["\\includegraphics"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          argTypes: ["raw", "url"],
          allowedInText: false
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var width = {
            number: 0,
            unit: "em"
          };
          var height = {
            number: 0.9,
            unit: "em"
          };
          var totalheight = {
            number: 0,
            unit: "em"
          };
          var alt = "";
          if (optArgs[0]) {
            var attributeStr = assertNodeType2(optArgs[0], "raw").string;
            var attributes = attributeStr.split(",");
            for (var i3 = 0; i3 < attributes.length; i3++) {
              var keyVal = attributes[i3].split("=");
              if (keyVal.length === 2) {
                var str2 = keyVal[1].trim();
                switch (keyVal[0].trim()) {
                  case "alt":
                    alt = str2;
                    break;
                  case "width":
                    width = sizeData3(str2);
                    break;
                  case "height":
                    height = sizeData3(str2);
                    break;
                  case "totalheight":
                    totalheight = sizeData3(str2);
                    break;
                  default:
                    throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                }
              }
            }
          }
          var src = assertNodeType2(args[0], "url").url;
          if (alt === "") {
            alt = src;
            alt = alt.replace(/^.*[\\/]/, "");
            alt = alt.substring(0, alt.lastIndexOf("."));
          }
          if (!parser.settings.isTrusted({
            command: "\\includegraphics",
            url: src
          })) {
            return parser.formatUnsupportedCmd("\\includegraphics");
          }
          return {
            type: "includegraphics",
            mode: parser.mode,
            alt,
            width,
            height,
            totalheight,
            src
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var height = calculateSize3(group.height, options2);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize3(group.totalheight, options2) - height;
          }
          var width = 0;
          if (group.width.number > 0) {
            width = calculateSize3(group.width, options2);
          }
          var style = {
            height: makeEm3(height + depth)
          };
          if (width > 0) {
            style.width = makeEm3(width);
          }
          if (depth > 0) {
            style.verticalAlign = makeEm3(-depth);
          }
          var node = new Img2(group.src, group.alt, style);
          node.height = height;
          node.depth = depth;
          return node;
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var node = new mathMLTree2.MathNode("mglyph", []);
          node.setAttribute("alt", group.alt);
          var height = calculateSize3(group.height, options2);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize3(group.totalheight, options2) - height;
            node.setAttribute("valign", makeEm3(-depth));
          }
          node.setAttribute("height", makeEm3(height + depth));
          if (group.width.number > 0) {
            var width = calculateSize3(group.width, options2);
            node.setAttribute("width", makeEm3(width));
          }
          node.setAttribute("src", group.src);
          return node;
        }
      });
      defineFunction2({
        type: "kern",
        names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          primitive: true,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var size = assertNodeType2(args[0], "size");
          if (parser.settings.strict) {
            var mathFunction = funcName[1] === "m";
            var muUnit = size.value.unit === "mu";
            if (mathFunction) {
              if (!muUnit) {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
              }
              if (parser.mode !== "math") {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
              }
            } else {
              if (muUnit) {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
              }
            }
          }
          return {
            type: "kern",
            mode: parser.mode,
            dimension: size.value
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          return buildCommon2.makeGlue(group.dimension, options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var dimension = calculateSize3(group.dimension, options2);
          return new mathMLTree2.SpaceNode(dimension);
        }
      });
      defineFunction2({
        type: "lap",
        names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "lap",
            mode: parser.mode,
            alignment: funcName.slice(5),
            body
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var inner3;
          if (group.alignment === "clap") {
            inner3 = buildCommon2.makeSpan([], [buildGroup4(group.body, options2)]);
            inner3 = buildCommon2.makeSpan(["inner"], [inner3], options2);
          } else {
            inner3 = buildCommon2.makeSpan(["inner"], [buildGroup4(group.body, options2)]);
          }
          var fix2 = buildCommon2.makeSpan(["fix"], []);
          var node = buildCommon2.makeSpan([group.alignment], [inner3, fix2], options2);
          var strut = buildCommon2.makeSpan(["strut"]);
          strut.style.height = makeEm3(node.height + node.depth);
          if (node.depth) {
            strut.style.verticalAlign = makeEm3(-node.depth);
          }
          node.children.unshift(strut);
          node = buildCommon2.makeSpan(["thinbox"], [node], options2);
          return buildCommon2.makeSpan(["mord", "vbox"], [node], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var node = new mathMLTree2.MathNode("mpadded", [buildMathML_buildGroup(group.body, options2)]);
          if (group.alignment !== "rlap") {
            var offset = group.alignment === "llap" ? "-1" : "-0.5";
            node.setAttribute("lspace", offset + "width");
          }
          node.setAttribute("width", "0px");
          return node;
        }
      });
      defineFunction2({
        type: "styling",
        names: ["\\(", "$"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler: function handler(_ref, args) {
          var funcName = _ref.funcName, parser = _ref.parser;
          var outerMode = parser.mode;
          parser.switchMode("math");
          var close2 = funcName === "\\(" ? "\\)" : "$";
          var body = parser.parseExpression(false, close2);
          parser.expect(close2);
          parser.switchMode(outerMode);
          return {
            type: "styling",
            mode: parser.mode,
            style: "text",
            body
          };
        }
      });
      defineFunction2({
        type: "text",
        names: ["\\)", "\\]"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler: function handler(context2, args) {
          throw new src_ParseError("Mismatched " + context2.funcName);
        }
      });
      var chooseMathStyle2 = function chooseMathStyle3(group, options2) {
        switch (options2.style.size) {
          case src_Style.DISPLAY.size:
            return group.display;
          case src_Style.TEXT.size:
            return group.text;
          case src_Style.SCRIPT.size:
            return group.script;
          case src_Style.SCRIPTSCRIPT.size:
            return group.scriptscript;
          default:
            return group.text;
        }
      };
      defineFunction2({
        type: "mathchoice",
        names: ["\\mathchoice"],
        props: {
          numArgs: 4,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "mathchoice",
            mode: parser.mode,
            display: ordargument3(args[0]),
            text: ordargument3(args[1]),
            script: ordargument3(args[2]),
            scriptscript: ordargument3(args[3])
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var body = chooseMathStyle2(group, options2);
          var elements = buildExpression4(body, options2, false);
          return buildCommon2.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var body = chooseMathStyle2(group, options2);
          return buildExpressionRow3(body, options2);
        }
      });
      var assembleSupSub2 = function assembleSupSub3(base2, supGroup, subGroup, options2, style, slant, baseShift) {
        base2 = buildCommon2.makeSpan([], [base2]);
        var subIsSingleCharacter = subGroup && utils2.isCharacterBox(subGroup);
        var sub2;
        var sup2;
        if (supGroup) {
          var elem = buildGroup4(supGroup, options2.havingStyle(style.sup()), options2);
          sup2 = {
            elem,
            kern: Math.max(options2.fontMetrics().bigOpSpacing1, options2.fontMetrics().bigOpSpacing3 - elem.depth)
          };
        }
        if (subGroup) {
          var _elem = buildGroup4(subGroup, options2.havingStyle(style.sub()), options2);
          sub2 = {
            elem: _elem,
            kern: Math.max(options2.fontMetrics().bigOpSpacing2, options2.fontMetrics().bigOpSpacing4 - _elem.height)
          };
        }
        var finalGroup;
        if (sup2 && sub2) {
          var bottom = options2.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base2.depth + baseShift;
          finalGroup = buildCommon2.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "kern",
              size: options2.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm3(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base2
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm3(slant)
            }, {
              type: "kern",
              size: options2.fontMetrics().bigOpSpacing5
            }]
          }, options2);
        } else if (sub2) {
          var top = base2.height - baseShift;
          finalGroup = buildCommon2.makeVList({
            positionType: "top",
            positionData: top,
            children: [{
              type: "kern",
              size: options2.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm3(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base2
            }]
          }, options2);
        } else if (sup2) {
          var _bottom = base2.depth + baseShift;
          finalGroup = buildCommon2.makeVList({
            positionType: "bottom",
            positionData: _bottom,
            children: [{
              type: "elem",
              elem: base2
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm3(slant)
            }, {
              type: "kern",
              size: options2.fontMetrics().bigOpSpacing5
            }]
          }, options2);
        } else {
          return base2;
        }
        var parts = [finalGroup];
        if (sub2 && slant !== 0 && !subIsSingleCharacter) {
          var spacer = buildCommon2.makeSpan(["mspace"], [], options2);
          spacer.style.marginRight = makeEm3(slant);
          parts.unshift(spacer);
        }
        return buildCommon2.makeSpan(["mop", "op-limits"], parts, options2);
      };
      var noSuccessor2 = ["\\smallint"];
      var op_htmlBuilder = function htmlBuilder4(grp, options2) {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType2(grp.base, "op");
          hasLimits = true;
        } else {
          group = assertNodeType2(grp, "op");
        }
        var style = options2.style;
        var large = false;
        if (style.size === src_Style.DISPLAY.size && group.symbol && !utils2.contains(noSuccessor2, group.name)) {
          large = true;
        }
        var base2;
        if (group.symbol) {
          var fontName = large ? "Size2-Regular" : "Size1-Regular";
          var stash = "";
          if (group.name === "\\oiint" || group.name === "\\oiiint") {
            stash = group.name.substr(1);
            group.name = stash === "oiint" ? "\\iint" : "\\iiint";
          }
          base2 = buildCommon2.makeSymbol(group.name, fontName, "math", options2, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
          if (stash.length > 0) {
            var italic = base2.italic;
            var oval = buildCommon2.staticSvg(stash + "Size" + (large ? "2" : "1"), options2);
            base2 = buildCommon2.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: base2,
                shift: 0
              }, {
                type: "elem",
                elem: oval,
                shift: large ? 0.08 : 0
              }]
            }, options2);
            group.name = "\\" + stash;
            base2.classes.unshift("mop");
            base2.italic = italic;
          }
        } else if (group.body) {
          var inner3 = buildExpression4(group.body, options2, true);
          if (inner3.length === 1 && inner3[0] instanceof SymbolNode2) {
            base2 = inner3[0];
            base2.classes[0] = "mop";
          } else {
            base2 = buildCommon2.makeSpan(["mop"], inner3, options2);
          }
        } else {
          var output = [];
          for (var i3 = 1; i3 < group.name.length; i3++) {
            output.push(buildCommon2.mathsym(group.name[i3], group.mode, options2));
          }
          base2 = buildCommon2.makeSpan(["mop"], output, options2);
        }
        var baseShift = 0;
        var slant = 0;
        if ((base2 instanceof SymbolNode2 || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
          baseShift = (base2.height - base2.depth) / 2 - options2.fontMetrics().axisHeight;
          slant = base2.italic;
        }
        if (hasLimits) {
          return assembleSupSub2(base2, supGroup, subGroup, options2, style, slant, baseShift);
        } else {
          if (baseShift) {
            base2.style.position = "relative";
            base2.style.top = makeEm3(baseShift);
          }
          return base2;
        }
      };
      var op_mathmlBuilder = function mathmlBuilder4(group, options2) {
        var node;
        if (group.symbol) {
          node = new MathNode2("mo", [makeText3(group.name, group.mode)]);
          if (utils2.contains(noSuccessor2, group.name)) {
            node.setAttribute("largeop", "false");
          }
        } else if (group.body) {
          node = new MathNode2("mo", buildMathML_buildExpression(group.body, options2));
        } else {
          node = new MathNode2("mi", [new TextNode2(group.name.slice(1))]);
          var operator = new MathNode2("mo", [makeText3("\u2061", "text")]);
          if (group.parentIsSupSub) {
            node = new MathNode2("mrow", [node, operator]);
          } else {
            node = newDocumentFragment2([node, operator]);
          }
        }
        return node;
      };
      var singleCharBigOps2 = {
        "\u220F": "\\prod",
        "\u2210": "\\coprod",
        "\u2211": "\\sum",
        "\u22C0": "\\bigwedge",
        "\u22C1": "\\bigvee",
        "\u22C2": "\\bigcap",
        "\u22C3": "\\bigcup",
        "\u2A00": "\\bigodot",
        "\u2A01": "\\bigoplus",
        "\u2A02": "\\bigotimes",
        "\u2A04": "\\biguplus",
        "\u2A06": "\\bigsqcup"
      };
      defineFunction2({
        type: "op",
        names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharBigOps2[fName];
          }
          return {
            type: "op",
            mode: parser.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction2({
        type: "op",
        names: ["\\mathop"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          var body = args[0];
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            body: ordargument3(body)
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      var singleCharIntegrals2 = {
        "\u222B": "\\int",
        "\u222C": "\\iint",
        "\u222D": "\\iiint",
        "\u222E": "\\oint",
        "\u222F": "\\oiint",
        "\u2230": "\\oiiint"
      };
      defineFunction2({
        type: "op",
        names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref3) {
          var parser = _ref3.parser, funcName = _ref3.funcName;
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction2({
        type: "op",
        names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref4) {
          var parser = _ref4.parser, funcName = _ref4.funcName;
          return {
            type: "op",
            mode: parser.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction2({
        type: "op",
        names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref5) {
          var parser = _ref5.parser, funcName = _ref5.funcName;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharIntegrals2[fName];
          }
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      var _macros2 = {};
      function defineMacro2(name, body) {
        _macros2[name] = body;
      }
      var operatorname_htmlBuilder = function htmlBuilder4(grp, options2) {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType2(grp.base, "operatorname");
          hasLimits = true;
        } else {
          group = assertNodeType2(grp, "operatorname");
        }
        var base2;
        if (group.body.length > 0) {
          var body = group.body.map(function(child2) {
            var childText = child2.text;
            if (typeof childText === "string") {
              return {
                type: "textord",
                mode: child2.mode,
                text: childText
              };
            } else {
              return child2;
            }
          });
          var expression = buildExpression4(body, options2.withFont("mathrm"), true);
          for (var i3 = 0; i3 < expression.length; i3++) {
            var child = expression[i3];
            if (child instanceof SymbolNode2) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            }
          }
          base2 = buildCommon2.makeSpan(["mop"], expression, options2);
        } else {
          base2 = buildCommon2.makeSpan(["mop"], [], options2);
        }
        if (hasLimits) {
          return assembleSupSub2(base2, supGroup, subGroup, options2, options2.style, 0, 0);
        } else {
          return base2;
        }
      };
      var operatorname_mathmlBuilder = function mathmlBuilder4(group, options2) {
        var expression = buildMathML_buildExpression(group.body, options2.withFont("mathrm"));
        var isAllString = true;
        for (var i3 = 0; i3 < expression.length; i3++) {
          var node = expression[i3];
          if (node instanceof mathMLTree2.SpaceNode)
            ;
          else if (node instanceof mathMLTree2.MathNode) {
            switch (node.type) {
              case "mi":
              case "mn":
              case "ms":
              case "mspace":
              case "mtext":
                break;
              case "mo": {
                var child = node.children[0];
                if (node.children.length === 1 && child instanceof mathMLTree2.TextNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }
                break;
              }
              default:
                isAllString = false;
            }
          } else {
            isAllString = false;
          }
        }
        if (isAllString) {
          var word = expression.map(function(node2) {
            return node2.toText();
          }).join("");
          expression = [new mathMLTree2.TextNode(word)];
        }
        var identifier = new mathMLTree2.MathNode("mi", expression);
        identifier.setAttribute("mathvariant", "normal");
        var operator = new mathMLTree2.MathNode("mo", [makeText3("\u2061", "text")]);
        if (group.parentIsSupSub) {
          return new mathMLTree2.MathNode("mrow", [identifier, operator]);
        } else {
          return mathMLTree2.newDocumentFragment([identifier, operator]);
        }
      };
      defineFunction2({
        type: "operatorname",
        names: ["\\operatorname@", "\\operatornamewithlimits"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "operatorname",
            mode: parser.mode,
            body: ordargument3(body),
            alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
            limits: false,
            parentIsSupSub: false
          };
        },
        htmlBuilder: operatorname_htmlBuilder,
        mathmlBuilder: operatorname_mathmlBuilder
      });
      defineMacro2("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
      defineFunctionBuilders2({
        type: "ordgroup",
        htmlBuilder: function htmlBuilder4(group, options2) {
          if (group.semisimple) {
            return buildCommon2.makeFragment(buildExpression4(group.body, options2, false));
          }
          return buildCommon2.makeSpan(["mord"], buildExpression4(group.body, options2, true), options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          return buildExpressionRow3(group.body, options2, true);
        }
      });
      defineFunction2({
        type: "overline",
        names: ["\\overline"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var body = args[0];
          return {
            type: "overline",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var innerGroup = buildGroup4(group.body, options2.havingCrampedStyle());
          var line = buildCommon2.makeLineSpan("overline-line", options2);
          var defaultRuleThickness = options2.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon2.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: innerGroup
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: defaultRuleThickness
            }]
          }, options2);
          return buildCommon2.makeSpan(["mord", "overline"], [vlist], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var operator = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node = new mathMLTree2.MathNode("mover", [buildMathML_buildGroup(group.body, options2), operator]);
          node.setAttribute("accent", "true");
          return node;
        }
      });
      defineFunction2({
        type: "phantom",
        names: ["\\phantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var body = args[0];
          return {
            type: "phantom",
            mode: parser.mode,
            body: ordargument3(body)
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var elements = buildExpression4(group.body, options2.withPhantom(), false);
          return buildCommon2.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var inner3 = buildMathML_buildExpression(group.body, options2);
          return new mathMLTree2.MathNode("mphantom", inner3);
        }
      });
      defineFunction2({
        type: "hphantom",
        names: ["\\hphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          var body = args[0];
          return {
            type: "hphantom",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var node = buildCommon2.makeSpan([], [buildGroup4(group.body, options2.withPhantom())]);
          node.height = 0;
          node.depth = 0;
          if (node.children) {
            for (var i3 = 0; i3 < node.children.length; i3++) {
              node.children[i3].height = 0;
              node.children[i3].depth = 0;
            }
          }
          node = buildCommon2.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node
            }]
          }, options2);
          return buildCommon2.makeSpan(["mord"], [node], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var inner3 = buildMathML_buildExpression(ordargument3(group.body), options2);
          var phantom = new mathMLTree2.MathNode("mphantom", inner3);
          var node = new mathMLTree2.MathNode("mpadded", [phantom]);
          node.setAttribute("height", "0px");
          node.setAttribute("depth", "0px");
          return node;
        }
      });
      defineFunction2({
        type: "vphantom",
        names: ["\\vphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser = _ref3.parser;
          var body = args[0];
          return {
            type: "vphantom",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var inner3 = buildCommon2.makeSpan(["inner"], [buildGroup4(group.body, options2.withPhantom())]);
          var fix2 = buildCommon2.makeSpan(["fix"], []);
          return buildCommon2.makeSpan(["mord", "rlap"], [inner3, fix2], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var inner3 = buildMathML_buildExpression(ordargument3(group.body), options2);
          var phantom = new mathMLTree2.MathNode("mphantom", inner3);
          var node = new mathMLTree2.MathNode("mpadded", [phantom]);
          node.setAttribute("width", "0px");
          return node;
        }
      });
      defineFunction2({
        type: "raisebox",
        names: ["\\raisebox"],
        props: {
          numArgs: 2,
          argTypes: ["size", "hbox"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var amount = assertNodeType2(args[0], "size").value;
          var body = args[1];
          return {
            type: "raisebox",
            mode: parser.mode,
            dy: amount,
            body
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var body = buildGroup4(group.body, options2);
          var dy = calculateSize3(group.dy, options2);
          return buildCommon2.makeVList({
            positionType: "shift",
            positionData: -dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var node = new mathMLTree2.MathNode("mpadded", [buildMathML_buildGroup(group.body, options2)]);
          var dy = group.dy.number + group.dy.unit;
          node.setAttribute("voffset", dy);
          return node;
        }
      });
      defineFunction2({
        type: "rule",
        names: ["\\rule"],
        props: {
          numArgs: 2,
          numOptionalArgs: 1,
          argTypes: ["size", "size", "size"]
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var shift = optArgs[0];
          var width = assertNodeType2(args[0], "size");
          var height = assertNodeType2(args[1], "size");
          return {
            type: "rule",
            mode: parser.mode,
            shift: shift && assertNodeType2(shift, "size").value,
            width: width.value,
            height: height.value
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var rule = buildCommon2.makeSpan(["mord", "rule"], [], options2);
          var width = calculateSize3(group.width, options2);
          var height = calculateSize3(group.height, options2);
          var shift = group.shift ? calculateSize3(group.shift, options2) : 0;
          rule.style.borderRightWidth = makeEm3(width);
          rule.style.borderTopWidth = makeEm3(height);
          rule.style.bottom = makeEm3(shift);
          rule.width = width;
          rule.height = height + shift;
          rule.depth = -shift;
          rule.maxFontSize = height * 1.125 * options2.sizeMultiplier;
          return rule;
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var width = calculateSize3(group.width, options2);
          var height = calculateSize3(group.height, options2);
          var shift = group.shift ? calculateSize3(group.shift, options2) : 0;
          var color = options2.color && options2.getColor() || "black";
          var rule = new mathMLTree2.MathNode("mspace");
          rule.setAttribute("mathbackground", color);
          rule.setAttribute("width", makeEm3(width));
          rule.setAttribute("height", makeEm3(height));
          var wrapper = new mathMLTree2.MathNode("mpadded", [rule]);
          if (shift >= 0) {
            wrapper.setAttribute("height", makeEm3(shift));
          } else {
            wrapper.setAttribute("height", makeEm3(shift));
            wrapper.setAttribute("depth", makeEm3(-shift));
          }
          wrapper.setAttribute("voffset", makeEm3(shift));
          return wrapper;
        }
      });
      function sizingGroup2(value, options2, baseOptions) {
        var inner3 = buildExpression4(value, options2, false);
        var multiplier = options2.sizeMultiplier / baseOptions.sizeMultiplier;
        for (var i3 = 0; i3 < inner3.length; i3++) {
          var pos = inner3[i3].classes.indexOf("sizing");
          if (pos < 0) {
            Array.prototype.push.apply(inner3[i3].classes, options2.sizingClasses(baseOptions));
          } else if (inner3[i3].classes[pos + 1] === "reset-size" + options2.size) {
            inner3[i3].classes[pos + 1] = "reset-size" + baseOptions.size;
          }
          inner3[i3].height *= multiplier;
          inner3[i3].depth *= multiplier;
        }
        return buildCommon2.makeFragment(inner3);
      }
      var sizeFuncs2 = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
      var sizing_htmlBuilder = function htmlBuilder4(group, options2) {
        var newOptions = options2.havingSize(group.size);
        return sizingGroup2(group.body, newOptions, options2);
      };
      defineFunction2({
        type: "sizing",
        names: sizeFuncs2,
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
          var body = parser.parseExpression(false, breakOnTokenText);
          return {
            type: "sizing",
            mode: parser.mode,
            size: sizeFuncs2.indexOf(funcName) + 1,
            body
          };
        },
        htmlBuilder: sizing_htmlBuilder,
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var newOptions = options2.havingSize(group.size);
          var inner3 = buildMathML_buildExpression(group.body, newOptions);
          var node = new mathMLTree2.MathNode("mstyle", inner3);
          node.setAttribute("mathsize", makeEm3(newOptions.sizeMultiplier));
          return node;
        }
      });
      defineFunction2({
        type: "smash",
        names: ["\\smash"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var smashHeight = false;
          var smashDepth = false;
          var tbArg = optArgs[0] && assertNodeType2(optArgs[0], "ordgroup");
          if (tbArg) {
            var letter = "";
            for (var i3 = 0; i3 < tbArg.body.length; ++i3) {
              var node = tbArg.body[i3];
              letter = node.text;
              if (letter === "t") {
                smashHeight = true;
              } else if (letter === "b") {
                smashDepth = true;
              } else {
                smashHeight = false;
                smashDepth = false;
                break;
              }
            }
          } else {
            smashHeight = true;
            smashDepth = true;
          }
          var body = args[0];
          return {
            type: "smash",
            mode: parser.mode,
            body,
            smashHeight,
            smashDepth
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var node = buildCommon2.makeSpan([], [buildGroup4(group.body, options2)]);
          if (!group.smashHeight && !group.smashDepth) {
            return node;
          }
          if (group.smashHeight) {
            node.height = 0;
            if (node.children) {
              for (var i3 = 0; i3 < node.children.length; i3++) {
                node.children[i3].height = 0;
              }
            }
          }
          if (group.smashDepth) {
            node.depth = 0;
            if (node.children) {
              for (var _i7 = 0; _i7 < node.children.length; _i7++) {
                node.children[_i7].depth = 0;
              }
            }
          }
          var smashedNode = buildCommon2.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node
            }]
          }, options2);
          return buildCommon2.makeSpan(["mord"], [smashedNode], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var node = new mathMLTree2.MathNode("mpadded", [buildMathML_buildGroup(group.body, options2)]);
          if (group.smashHeight) {
            node.setAttribute("height", "0px");
          }
          if (group.smashDepth) {
            node.setAttribute("depth", "0px");
          }
          return node;
        }
      });
      defineFunction2({
        type: "sqrt",
        names: ["\\sqrt"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var index = optArgs[0];
          var body = args[0];
          return {
            type: "sqrt",
            mode: parser.mode,
            body,
            index
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var inner3 = buildGroup4(group.body, options2.havingCrampedStyle());
          if (inner3.height === 0) {
            inner3.height = options2.fontMetrics().xHeight;
          }
          inner3 = buildCommon2.wrapFragment(inner3, options2);
          var metrics = options2.fontMetrics();
          var theta = metrics.defaultRuleThickness;
          var phi = theta;
          if (options2.style.id < src_Style.TEXT.id) {
            phi = options2.fontMetrics().xHeight;
          }
          var lineClearance = theta + phi / 4;
          var minDelimiterHeight = inner3.height + inner3.depth + lineClearance + theta;
          var _delimiter$sqrtImage = delimiter2.sqrtImage(minDelimiterHeight, options2), img = _delimiter$sqrtImage.span, ruleWidth = _delimiter$sqrtImage.ruleWidth, advanceWidth = _delimiter$sqrtImage.advanceWidth;
          var delimDepth = img.height - ruleWidth;
          if (delimDepth > inner3.height + inner3.depth + lineClearance) {
            lineClearance = (lineClearance + delimDepth - inner3.height - inner3.depth) / 2;
          }
          var imgShift = img.height - inner3.height - lineClearance - ruleWidth;
          inner3.style.paddingLeft = makeEm3(advanceWidth);
          var body = buildCommon2.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: inner3,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: -(inner3.height + imgShift)
            }, {
              type: "elem",
              elem: img
            }, {
              type: "kern",
              size: ruleWidth
            }]
          }, options2);
          if (!group.index) {
            return buildCommon2.makeSpan(["mord", "sqrt"], [body], options2);
          } else {
            var newOptions = options2.havingStyle(src_Style.SCRIPTSCRIPT);
            var rootm = buildGroup4(group.index, newOptions, options2);
            var toShift = 0.6 * (body.height - body.depth);
            var rootVList = buildCommon2.makeVList({
              positionType: "shift",
              positionData: -toShift,
              children: [{
                type: "elem",
                elem: rootm
              }]
            }, options2);
            var rootVListWrap = buildCommon2.makeSpan(["root"], [rootVList]);
            return buildCommon2.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options2);
          }
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var body = group.body, index = group.index;
          return index ? new mathMLTree2.MathNode("mroot", [buildMathML_buildGroup(body, options2), buildMathML_buildGroup(index, options2)]) : new mathMLTree2.MathNode("msqrt", [buildMathML_buildGroup(body, options2)]);
        }
      });
      var styling_styleMap = {
        "display": src_Style.DISPLAY,
        "text": src_Style.TEXT,
        "script": src_Style.SCRIPT,
        "scriptscript": src_Style.SCRIPTSCRIPT
      };
      defineFunction2({
        type: "styling",
        names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
          var body = parser.parseExpression(true, breakOnTokenText);
          var style = funcName.slice(1, funcName.length - 5);
          return {
            type: "styling",
            mode: parser.mode,
            style,
            body
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var newStyle = styling_styleMap[group.style];
          var newOptions = options2.havingStyle(newStyle).withFont("");
          return sizingGroup2(group.body, newOptions, options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var newStyle = styling_styleMap[group.style];
          var newOptions = options2.havingStyle(newStyle);
          var inner3 = buildMathML_buildExpression(group.body, newOptions);
          var node = new mathMLTree2.MathNode("mstyle", inner3);
          var styleAttributes = {
            "display": ["0", "true"],
            "text": ["0", "false"],
            "script": ["1", "false"],
            "scriptscript": ["2", "false"]
          };
          var attr = styleAttributes[group.style];
          node.setAttribute("scriptlevel", attr[0]);
          node.setAttribute("displaystyle", attr[1]);
          return node;
        }
      });
      var htmlBuilderDelegate3 = function htmlBuilderDelegate4(group, options2) {
        var base2 = group.base;
        if (!base2) {
          return null;
        } else if (base2.type === "op") {
          var delegate = base2.limits && (options2.style.size === src_Style.DISPLAY.size || base2.alwaysHandleSupSub);
          return delegate ? op_htmlBuilder : null;
        } else if (base2.type === "operatorname") {
          var _delegate = base2.alwaysHandleSupSub && (options2.style.size === src_Style.DISPLAY.size || base2.limits);
          return _delegate ? operatorname_htmlBuilder : null;
        } else if (base2.type === "accent") {
          return utils2.isCharacterBox(base2.base) ? htmlBuilder3 : null;
        } else if (base2.type === "horizBrace") {
          var isSup = !group.sub;
          return isSup === base2.isOver ? horizBrace_htmlBuilder : null;
        } else {
          return null;
        }
      };
      defineFunctionBuilders2({
        type: "supsub",
        htmlBuilder: function htmlBuilder4(group, options2) {
          var builderDelegate = htmlBuilderDelegate3(group, options2);
          if (builderDelegate) {
            return builderDelegate(group, options2);
          }
          var valueBase = group.base, valueSup = group.sup, valueSub = group.sub;
          var base2 = buildGroup4(valueBase, options2);
          var supm;
          var subm;
          var metrics = options2.fontMetrics();
          var supShift = 0;
          var subShift = 0;
          var isCharacterBox4 = valueBase && utils2.isCharacterBox(valueBase);
          if (valueSup) {
            var newOptions = options2.havingStyle(options2.style.sup());
            supm = buildGroup4(valueSup, newOptions, options2);
            if (!isCharacterBox4) {
              supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options2.sizeMultiplier;
            }
          }
          if (valueSub) {
            var _newOptions = options2.havingStyle(options2.style.sub());
            subm = buildGroup4(valueSub, _newOptions, options2);
            if (!isCharacterBox4) {
              subShift = base2.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options2.sizeMultiplier;
            }
          }
          var minSupShift;
          if (options2.style === src_Style.DISPLAY) {
            minSupShift = metrics.sup1;
          } else if (options2.style.cramped) {
            minSupShift = metrics.sup3;
          } else {
            minSupShift = metrics.sup2;
          }
          var multiplier = options2.sizeMultiplier;
          var marginRight = makeEm3(0.5 / metrics.ptPerEm / multiplier);
          var marginLeft = null;
          if (subm) {
            var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
            if (base2 instanceof SymbolNode2 || isOiint) {
              marginLeft = makeEm3(-base2.italic);
            }
          }
          var supsub;
          if (supm && subm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            subShift = Math.max(subShift, metrics.sub2);
            var ruleWidth = metrics.defaultRuleThickness;
            var maxWidth = 4 * ruleWidth;
            if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
              subShift = maxWidth - (supShift - supm.depth) + subm.height;
              var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
              if (psi > 0) {
                supShift += psi;
                subShift -= psi;
              }
            }
            var vlistElem = [{
              type: "elem",
              elem: subm,
              shift: subShift,
              marginRight,
              marginLeft
            }, {
              type: "elem",
              elem: supm,
              shift: -supShift,
              marginRight
            }];
            supsub = buildCommon2.makeVList({
              positionType: "individualShift",
              children: vlistElem
            }, options2);
          } else if (subm) {
            subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
            var _vlistElem = [{
              type: "elem",
              elem: subm,
              marginLeft,
              marginRight
            }];
            supsub = buildCommon2.makeVList({
              positionType: "shift",
              positionData: subShift,
              children: _vlistElem
            }, options2);
          } else if (supm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            supsub = buildCommon2.makeVList({
              positionType: "shift",
              positionData: -supShift,
              children: [{
                type: "elem",
                elem: supm,
                marginRight
              }]
            }, options2);
          } else {
            throw new Error("supsub must have either sup or sub.");
          }
          var mclass = getTypeOfDomTree3(base2, "right") || "mord";
          return buildCommon2.makeSpan([mclass], [base2, buildCommon2.makeSpan(["msupsub"], [supsub])], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var isBrace = false;
          var isOver;
          var isSup;
          if (group.base && group.base.type === "horizBrace") {
            isSup = !!group.sup;
            if (isSup === group.base.isOver) {
              isBrace = true;
              isOver = group.base.isOver;
            }
          }
          if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
            group.base.parentIsSupSub = true;
          }
          var children = [buildMathML_buildGroup(group.base, options2)];
          if (group.sub) {
            children.push(buildMathML_buildGroup(group.sub, options2));
          }
          if (group.sup) {
            children.push(buildMathML_buildGroup(group.sup, options2));
          }
          var nodeType;
          if (isBrace) {
            nodeType = isOver ? "mover" : "munder";
          } else if (!group.sub) {
            var base2 = group.base;
            if (base2 && base2.type === "op" && base2.limits && (options2.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
              nodeType = "mover";
            } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options2.style === src_Style.DISPLAY)) {
              nodeType = "mover";
            } else {
              nodeType = "msup";
            }
          } else if (!group.sup) {
            var _base = group.base;
            if (_base && _base.type === "op" && _base.limits && (options2.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {
              nodeType = "munder";
            } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options2.style === src_Style.DISPLAY)) {
              nodeType = "munder";
            } else {
              nodeType = "msub";
            }
          } else {
            var _base2 = group.base;
            if (_base2 && _base2.type === "op" && _base2.limits && options2.style === src_Style.DISPLAY) {
              nodeType = "munderover";
            } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options2.style === src_Style.DISPLAY || _base2.limits)) {
              nodeType = "munderover";
            } else {
              nodeType = "msubsup";
            }
          }
          return new mathMLTree2.MathNode(nodeType, children);
        }
      });
      defineFunctionBuilders2({
        type: "atom",
        htmlBuilder: function htmlBuilder4(group, options2) {
          return buildCommon2.mathsym(group.text, group.mode, options2, ["m" + group.family]);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var node = new mathMLTree2.MathNode("mo", [makeText3(group.text, group.mode)]);
          if (group.family === "bin") {
            var variant = getVariant3(group, options2);
            if (variant === "bold-italic") {
              node.setAttribute("mathvariant", variant);
            }
          } else if (group.family === "punct") {
            node.setAttribute("separator", "true");
          } else if (group.family === "open" || group.family === "close") {
            node.setAttribute("stretchy", "false");
          }
          return node;
        }
      });
      var defaultVariant2 = {
        "mi": "italic",
        "mn": "normal",
        "mtext": "normal"
      };
      defineFunctionBuilders2({
        type: "mathord",
        htmlBuilder: function htmlBuilder4(group, options2) {
          return buildCommon2.makeOrd(group, options2, "mathord");
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var node = new mathMLTree2.MathNode("mi", [makeText3(group.text, group.mode, options2)]);
          var variant = getVariant3(group, options2) || "italic";
          if (variant !== defaultVariant2[node.type]) {
            node.setAttribute("mathvariant", variant);
          }
          return node;
        }
      });
      defineFunctionBuilders2({
        type: "textord",
        htmlBuilder: function htmlBuilder4(group, options2) {
          return buildCommon2.makeOrd(group, options2, "textord");
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var text2 = makeText3(group.text, group.mode, options2);
          var variant = getVariant3(group, options2) || "normal";
          var node;
          if (group.mode === "text") {
            node = new mathMLTree2.MathNode("mtext", [text2]);
          } else if (/[0-9]/.test(group.text)) {
            node = new mathMLTree2.MathNode("mn", [text2]);
          } else if (group.text === "\\prime") {
            node = new mathMLTree2.MathNode("mo", [text2]);
          } else {
            node = new mathMLTree2.MathNode("mi", [text2]);
          }
          if (variant !== defaultVariant2[node.type]) {
            node.setAttribute("mathvariant", variant);
          }
          return node;
        }
      });
      var cssSpace2 = {
        "\\nobreak": "nobreak",
        "\\allowbreak": "allowbreak"
      };
      var regularSpace2 = {
        " ": {},
        "\\ ": {},
        "~": {
          className: "nobreak"
        },
        "\\space": {},
        "\\nobreakspace": {
          className: "nobreak"
        }
      };
      defineFunctionBuilders2({
        type: "spacing",
        htmlBuilder: function htmlBuilder4(group, options2) {
          if (regularSpace2.hasOwnProperty(group.text)) {
            var className = regularSpace2[group.text].className || "";
            if (group.mode === "text") {
              var ord = buildCommon2.makeOrd(group, options2, "textord");
              ord.classes.push(className);
              return ord;
            } else {
              return buildCommon2.makeSpan(["mspace", className], [buildCommon2.mathsym(group.text, group.mode, options2)], options2);
            }
          } else if (cssSpace2.hasOwnProperty(group.text)) {
            return buildCommon2.makeSpan(["mspace", cssSpace2[group.text]], [], options2);
          } else {
            throw new src_ParseError('Unknown type of space "' + group.text + '"');
          }
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var node;
          if (regularSpace2.hasOwnProperty(group.text)) {
            node = new mathMLTree2.MathNode("mtext", [new mathMLTree2.TextNode("\xA0")]);
          } else if (cssSpace2.hasOwnProperty(group.text)) {
            return new mathMLTree2.MathNode("mspace");
          } else {
            throw new src_ParseError('Unknown type of space "' + group.text + '"');
          }
          return node;
        }
      });
      var pad2 = function pad3() {
        var padNode = new mathMLTree2.MathNode("mtd", []);
        padNode.setAttribute("width", "50%");
        return padNode;
      };
      defineFunctionBuilders2({
        type: "tag",
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var table = new mathMLTree2.MathNode("mtable", [new mathMLTree2.MathNode("mtr", [pad2(), new mathMLTree2.MathNode("mtd", [buildExpressionRow3(group.body, options2)]), pad2(), new mathMLTree2.MathNode("mtd", [buildExpressionRow3(group.tag, options2)])])]);
          table.setAttribute("width", "100%");
          return table;
        }
      });
      var textFontFamilies2 = {
        "\\text": void 0,
        "\\textrm": "textrm",
        "\\textsf": "textsf",
        "\\texttt": "texttt",
        "\\textnormal": "textrm"
      };
      var textFontWeights2 = {
        "\\textbf": "textbf",
        "\\textmd": "textmd"
      };
      var textFontShapes2 = {
        "\\textit": "textit",
        "\\textup": "textup"
      };
      var optionsWithFont2 = function optionsWithFont3(group, options2) {
        var font = group.font;
        if (!font) {
          return options2;
        } else if (textFontFamilies2[font]) {
          return options2.withTextFontFamily(textFontFamilies2[font]);
        } else if (textFontWeights2[font]) {
          return options2.withTextFontWeight(textFontWeights2[font]);
        } else {
          return options2.withTextFontShape(textFontShapes2[font]);
        }
      };
      defineFunction2({
        type: "text",
        names: [
          "\\text",
          "\\textrm",
          "\\textsf",
          "\\texttt",
          "\\textnormal",
          "\\textbf",
          "\\textmd",
          "\\textit",
          "\\textup"
        ],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInArgument: true,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "text",
            mode: parser.mode,
            body: ordargument3(body),
            font: funcName
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var newOptions = optionsWithFont2(group, options2);
          var inner3 = buildExpression4(group.body, newOptions, true);
          return buildCommon2.makeSpan(["mord", "text"], inner3, newOptions);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var newOptions = optionsWithFont2(group, options2);
          return buildExpressionRow3(group.body, newOptions);
        }
      });
      defineFunction2({
        type: "underline",
        names: ["\\underline"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "underline",
            mode: parser.mode,
            body: args[0]
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var innerGroup = buildGroup4(group.body, options2);
          var line = buildCommon2.makeLineSpan("underline-line", options2);
          var defaultRuleThickness = options2.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon2.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "kern",
              size: defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options2);
          return buildCommon2.makeSpan(["mord", "underline"], [vlist], options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var operator = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node = new mathMLTree2.MathNode("munder", [buildMathML_buildGroup(group.body, options2), operator]);
          node.setAttribute("accentunder", "true");
          return node;
        }
      });
      defineFunction2({
        type: "vcenter",
        names: ["\\vcenter"],
        props: {
          numArgs: 1,
          argTypes: ["original"],
          allowedInText: false
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "vcenter",
            mode: parser.mode,
            body: args[0]
          };
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var body = buildGroup4(group.body, options2);
          var axisHeight = options2.fontMetrics().axisHeight;
          var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
          return buildCommon2.makeVList({
            positionType: "shift",
            positionData: dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options2);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          return new mathMLTree2.MathNode("mpadded", [buildMathML_buildGroup(group.body, options2)], ["vcenter"]);
        }
      });
      defineFunction2({
        type: "verb",
        names: ["\\verb"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(context2, args, optArgs) {
          throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
        },
        htmlBuilder: function htmlBuilder4(group, options2) {
          var text2 = makeVerb2(group);
          var body = [];
          var newOptions = options2.havingStyle(options2.style.text());
          for (var i3 = 0; i3 < text2.length; i3++) {
            var c2 = text2[i3];
            if (c2 === "~") {
              c2 = "\\textasciitilde";
            }
            body.push(buildCommon2.makeSymbol(c2, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
          }
          return buildCommon2.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options2)), buildCommon2.tryCombineChars(body), newOptions);
        },
        mathmlBuilder: function mathmlBuilder4(group, options2) {
          var text2 = new mathMLTree2.TextNode(makeVerb2(group));
          var node = new mathMLTree2.MathNode("mtext", [text2]);
          node.setAttribute("mathvariant", "monospace");
          return node;
        }
      });
      var makeVerb2 = function makeVerb3(group) {
        return group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
      };
      var functions2 = _functions2;
      var src_functions = functions2;
      var SourceLocation2 = /* @__PURE__ */ function() {
        function SourceLocation3(lexer, start, end) {
          this.lexer = void 0;
          this.start = void 0;
          this.end = void 0;
          this.lexer = lexer;
          this.start = start;
          this.end = end;
        }
        SourceLocation3.range = function range2(first, second) {
          if (!second) {
            return first && first.loc;
          } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
            return null;
          } else {
            return new SourceLocation3(first.loc.lexer, first.loc.start, second.loc.end);
          }
        };
        return SourceLocation3;
      }();
      var Token2 = /* @__PURE__ */ function() {
        function Token3(text2, loc) {
          this.text = void 0;
          this.loc = void 0;
          this.noexpand = void 0;
          this.treatAsRelax = void 0;
          this.text = text2;
          this.loc = loc;
        }
        var _proto = Token3.prototype;
        _proto.range = function range2(endToken, text2) {
          return new Token3(text2, SourceLocation2.range(this, endToken));
        };
        return Token3;
      }();
      var spaceRegexString2 = "[ \r\n	]";
      var controlWordRegexString2 = "\\\\[a-zA-Z@]+";
      var controlSymbolRegexString2 = "\\\\[^\uD800-\uDFFF]";
      var controlWordWhitespaceRegexString2 = "(" + controlWordRegexString2 + ")" + spaceRegexString2 + "*";
      var controlSpaceRegexString2 = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
      var combiningDiacriticalMarkString2 = "[\u0300-\u036F]";
      var combiningDiacriticalMarksEndRegex2 = new RegExp(combiningDiacriticalMarkString2 + "+$");
      var tokenRegexString2 = "(" + spaceRegexString2 + "+)|" + (controlSpaceRegexString2 + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (combiningDiacriticalMarkString2 + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (combiningDiacriticalMarkString2 + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + controlWordWhitespaceRegexString2) + ("|" + controlSymbolRegexString2 + ")");
      var Lexer2 = /* @__PURE__ */ function() {
        function Lexer3(input, settings) {
          this.input = void 0;
          this.settings = void 0;
          this.tokenRegex = void 0;
          this.catcodes = void 0;
          this.input = input;
          this.settings = settings;
          this.tokenRegex = new RegExp(tokenRegexString2, "g");
          this.catcodes = {
            "%": 14,
            "~": 13
          };
        }
        var _proto = Lexer3.prototype;
        _proto.setCatcode = function setCatcode(char, code2) {
          this.catcodes[char] = code2;
        };
        _proto.lex = function lex() {
          var input = this.input;
          var pos = this.tokenRegex.lastIndex;
          if (pos === input.length) {
            return new Token2("EOF", new SourceLocation2(this, pos, pos));
          }
          var match2 = this.tokenRegex.exec(input);
          if (match2 === null || match2.index !== pos) {
            throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token2(input[pos], new SourceLocation2(this, pos, pos + 1)));
          }
          var text2 = match2[6] || match2[3] || (match2[2] ? "\\ " : " ");
          if (this.catcodes[text2] === 14) {
            var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
            if (nlIndex === -1) {
              this.tokenRegex.lastIndex = input.length;
              this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
            } else {
              this.tokenRegex.lastIndex = nlIndex + 1;
            }
            return this.lex();
          }
          return new Token2(text2, new SourceLocation2(this, pos, this.tokenRegex.lastIndex));
        };
        return Lexer3;
      }();
      var Namespace2 = /* @__PURE__ */ function() {
        function Namespace3(builtins, globalMacros) {
          if (builtins === void 0) {
            builtins = {};
          }
          if (globalMacros === void 0) {
            globalMacros = {};
          }
          this.current = void 0;
          this.builtins = void 0;
          this.undefStack = void 0;
          this.current = globalMacros;
          this.builtins = builtins;
          this.undefStack = [];
        }
        var _proto = Namespace3.prototype;
        _proto.beginGroup = function beginGroup() {
          this.undefStack.push({});
        };
        _proto.endGroup = function endGroup() {
          if (this.undefStack.length === 0) {
            throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
          }
          var undefs = this.undefStack.pop();
          for (var undef in undefs) {
            if (undefs.hasOwnProperty(undef)) {
              if (undefs[undef] === void 0) {
                delete this.current[undef];
              } else {
                this.current[undef] = undefs[undef];
              }
            }
          }
        };
        _proto.endGroups = function endGroups() {
          while (this.undefStack.length > 0) {
            this.endGroup();
          }
        };
        _proto.has = function has(name) {
          return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
        };
        _proto.get = function get(name) {
          if (this.current.hasOwnProperty(name)) {
            return this.current[name];
          } else {
            return this.builtins[name];
          }
        };
        _proto.set = function set(name, value, global2) {
          if (global2 === void 0) {
            global2 = false;
          }
          if (global2) {
            for (var i3 = 0; i3 < this.undefStack.length; i3++) {
              delete this.undefStack[i3][name];
            }
            if (this.undefStack.length > 0) {
              this.undefStack[this.undefStack.length - 1][name] = value;
            }
          } else {
            var top = this.undefStack[this.undefStack.length - 1];
            if (top && !top.hasOwnProperty(name)) {
              top[name] = this.current[name];
            }
          }
          this.current[name] = value;
        };
        return Namespace3;
      }();
      var macros2 = _macros2;
      var src_macros = macros2;
      defineMacro2("\\noexpand", function(context2) {
        var t2 = context2.popToken();
        if (context2.isExpandable(t2.text)) {
          t2.noexpand = true;
          t2.treatAsRelax = true;
        }
        return {
          tokens: [t2],
          numArgs: 0
        };
      });
      defineMacro2("\\expandafter", function(context2) {
        var t2 = context2.popToken();
        context2.expandOnce(true);
        return {
          tokens: [t2],
          numArgs: 0
        };
      });
      defineMacro2("\\@firstoftwo", function(context2) {
        var args = context2.consumeArgs(2);
        return {
          tokens: args[0],
          numArgs: 0
        };
      });
      defineMacro2("\\@secondoftwo", function(context2) {
        var args = context2.consumeArgs(2);
        return {
          tokens: args[1],
          numArgs: 0
        };
      });
      defineMacro2("\\@ifnextchar", function(context2) {
        var args = context2.consumeArgs(3);
        context2.consumeSpaces();
        var nextToken = context2.future();
        if (args[0].length === 1 && args[0][0].text === nextToken.text) {
          return {
            tokens: args[1],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[2],
            numArgs: 0
          };
        }
      });
      defineMacro2("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
      defineMacro2("\\TextOrMath", function(context2) {
        var args = context2.consumeArgs(2);
        if (context2.mode === "text") {
          return {
            tokens: args[0],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[1],
            numArgs: 0
          };
        }
      });
      var digitToNumber2 = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "a": 10,
        "A": 10,
        "b": 11,
        "B": 11,
        "c": 12,
        "C": 12,
        "d": 13,
        "D": 13,
        "e": 14,
        "E": 14,
        "f": 15,
        "F": 15
      };
      defineMacro2("\\char", function(context2) {
        var token = context2.popToken();
        var base2;
        var number = "";
        if (token.text === "'") {
          base2 = 8;
          token = context2.popToken();
        } else if (token.text === '"') {
          base2 = 16;
          token = context2.popToken();
        } else if (token.text === "`") {
          token = context2.popToken();
          if (token.text[0] === "\\") {
            number = token.text.charCodeAt(1);
          } else if (token.text === "EOF") {
            throw new src_ParseError("\\char` missing argument");
          } else {
            number = token.text.charCodeAt(0);
          }
        } else {
          base2 = 10;
        }
        if (base2) {
          number = digitToNumber2[token.text];
          if (number == null || number >= base2) {
            throw new src_ParseError("Invalid base-" + base2 + " digit " + token.text);
          }
          var digit;
          while ((digit = digitToNumber2[context2.future().text]) != null && digit < base2) {
            number *= base2;
            number += digit;
            context2.popToken();
          }
        }
        return "\\@char{" + number + "}";
      });
      var newcommand2 = function newcommand3(context2, existsOK, nonexistsOK) {
        var arg = context2.consumeArg().tokens;
        if (arg.length !== 1) {
          throw new src_ParseError("\\newcommand's first argument must be a macro name");
        }
        var name = arg[0].text;
        var exists = context2.isDefined(name);
        if (exists && !existsOK) {
          throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
        }
        if (!exists && !nonexistsOK) {
          throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
        }
        var numArgs = 0;
        arg = context2.consumeArg().tokens;
        if (arg.length === 1 && arg[0].text === "[") {
          var argText = "";
          var token = context2.expandNextToken();
          while (token.text !== "]" && token.text !== "EOF") {
            argText += token.text;
            token = context2.expandNextToken();
          }
          if (!argText.match(/^\s*[0-9]+\s*$/)) {
            throw new src_ParseError("Invalid number of arguments: " + argText);
          }
          numArgs = parseInt(argText);
          arg = context2.consumeArg().tokens;
        }
        context2.macros.set(name, {
          tokens: arg,
          numArgs
        });
        return "";
      };
      defineMacro2("\\newcommand", function(context2) {
        return newcommand2(context2, false, true);
      });
      defineMacro2("\\renewcommand", function(context2) {
        return newcommand2(context2, true, false);
      });
      defineMacro2("\\providecommand", function(context2) {
        return newcommand2(context2, true, true);
      });
      defineMacro2("\\message", function(context2) {
        var arg = context2.consumeArgs(1)[0];
        console.log(arg.reverse().map(function(token) {
          return token.text;
        }).join(""));
        return "";
      });
      defineMacro2("\\errmessage", function(context2) {
        var arg = context2.consumeArgs(1)[0];
        console.error(arg.reverse().map(function(token) {
          return token.text;
        }).join(""));
        return "";
      });
      defineMacro2("\\show", function(context2) {
        var tok = context2.popToken();
        var name = tok.text;
        console.log(tok, context2.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
        return "";
      });
      defineMacro2("\\bgroup", "{");
      defineMacro2("\\egroup", "}");
      defineMacro2("~", "\\nobreakspace");
      defineMacro2("\\lq", "`");
      defineMacro2("\\rq", "'");
      defineMacro2("\\aa", "\\r a");
      defineMacro2("\\AA", "\\r A");
      defineMacro2("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
      defineMacro2("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
      defineMacro2("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
      defineMacro2("\u212C", "\\mathscr{B}");
      defineMacro2("\u2130", "\\mathscr{E}");
      defineMacro2("\u2131", "\\mathscr{F}");
      defineMacro2("\u210B", "\\mathscr{H}");
      defineMacro2("\u2110", "\\mathscr{I}");
      defineMacro2("\u2112", "\\mathscr{L}");
      defineMacro2("\u2133", "\\mathscr{M}");
      defineMacro2("\u211B", "\\mathscr{R}");
      defineMacro2("\u212D", "\\mathfrak{C}");
      defineMacro2("\u210C", "\\mathfrak{H}");
      defineMacro2("\u2128", "\\mathfrak{Z}");
      defineMacro2("\\Bbbk", "\\Bbb{k}");
      defineMacro2("\xB7", "\\cdotp");
      defineMacro2("\\llap", "\\mathllap{\\textrm{#1}}");
      defineMacro2("\\rlap", "\\mathrlap{\\textrm{#1}}");
      defineMacro2("\\clap", "\\mathclap{\\textrm{#1}}");
      defineMacro2("\\mathstrut", "\\vphantom{(}");
      defineMacro2("\\underbar", "\\underline{\\text{#1}}");
      defineMacro2("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
      defineMacro2("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
      defineMacro2("\\ne", "\\neq");
      defineMacro2("\u2260", "\\neq");
      defineMacro2("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
      defineMacro2("\u2209", "\\notin");
      defineMacro2("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
      defineMacro2("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
      defineMacro2("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
      defineMacro2("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
      defineMacro2("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
      defineMacro2("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
      defineMacro2("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
      defineMacro2("\u27C2", "\\perp");
      defineMacro2("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
      defineMacro2("\u220C", "\\notni");
      defineMacro2("\u231C", "\\ulcorner");
      defineMacro2("\u231D", "\\urcorner");
      defineMacro2("\u231E", "\\llcorner");
      defineMacro2("\u231F", "\\lrcorner");
      defineMacro2("\xA9", "\\copyright");
      defineMacro2("\xAE", "\\textregistered");
      defineMacro2("\uFE0F", "\\textregistered");
      defineMacro2("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
      defineMacro2("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
      defineMacro2("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
      defineMacro2("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
      defineMacro2("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
      defineMacro2("\u22EE", "\\vdots");
      defineMacro2("\\varGamma", "\\mathit{\\Gamma}");
      defineMacro2("\\varDelta", "\\mathit{\\Delta}");
      defineMacro2("\\varTheta", "\\mathit{\\Theta}");
      defineMacro2("\\varLambda", "\\mathit{\\Lambda}");
      defineMacro2("\\varXi", "\\mathit{\\Xi}");
      defineMacro2("\\varPi", "\\mathit{\\Pi}");
      defineMacro2("\\varSigma", "\\mathit{\\Sigma}");
      defineMacro2("\\varUpsilon", "\\mathit{\\Upsilon}");
      defineMacro2("\\varPhi", "\\mathit{\\Phi}");
      defineMacro2("\\varPsi", "\\mathit{\\Psi}");
      defineMacro2("\\varOmega", "\\mathit{\\Omega}");
      defineMacro2("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
      defineMacro2("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");
      defineMacro2("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
      defineMacro2("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
      defineMacro2("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
      defineMacro2("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
      var dotsByToken2 = {
        ",": "\\dotsc",
        "\\not": "\\dotsb",
        "+": "\\dotsb",
        "=": "\\dotsb",
        "<": "\\dotsb",
        ">": "\\dotsb",
        "-": "\\dotsb",
        "*": "\\dotsb",
        ":": "\\dotsb",
        "\\DOTSB": "\\dotsb",
        "\\coprod": "\\dotsb",
        "\\bigvee": "\\dotsb",
        "\\bigwedge": "\\dotsb",
        "\\biguplus": "\\dotsb",
        "\\bigcap": "\\dotsb",
        "\\bigcup": "\\dotsb",
        "\\prod": "\\dotsb",
        "\\sum": "\\dotsb",
        "\\bigotimes": "\\dotsb",
        "\\bigoplus": "\\dotsb",
        "\\bigodot": "\\dotsb",
        "\\bigsqcup": "\\dotsb",
        "\\And": "\\dotsb",
        "\\longrightarrow": "\\dotsb",
        "\\Longrightarrow": "\\dotsb",
        "\\longleftarrow": "\\dotsb",
        "\\Longleftarrow": "\\dotsb",
        "\\longleftrightarrow": "\\dotsb",
        "\\Longleftrightarrow": "\\dotsb",
        "\\mapsto": "\\dotsb",
        "\\longmapsto": "\\dotsb",
        "\\hookrightarrow": "\\dotsb",
        "\\doteq": "\\dotsb",
        "\\mathbin": "\\dotsb",
        "\\mathrel": "\\dotsb",
        "\\relbar": "\\dotsb",
        "\\Relbar": "\\dotsb",
        "\\xrightarrow": "\\dotsb",
        "\\xleftarrow": "\\dotsb",
        "\\DOTSI": "\\dotsi",
        "\\int": "\\dotsi",
        "\\oint": "\\dotsi",
        "\\iint": "\\dotsi",
        "\\iiint": "\\dotsi",
        "\\iiiint": "\\dotsi",
        "\\idotsint": "\\dotsi",
        "\\DOTSX": "\\dotsx"
      };
      defineMacro2("\\dots", function(context2) {
        var thedots = "\\dotso";
        var next = context2.expandAfterFuture().text;
        if (next in dotsByToken2) {
          thedots = dotsByToken2[next];
        } else if (next.substr(0, 4) === "\\not") {
          thedots = "\\dotsb";
        } else if (next in src_symbols.math) {
          if (utils2.contains(["bin", "rel"], src_symbols.math[next].group)) {
            thedots = "\\dotsb";
          }
        }
        return thedots;
      });
      var spaceAfterDots2 = {
        ")": true,
        "]": true,
        "\\rbrack": true,
        "\\}": true,
        "\\rbrace": true,
        "\\rangle": true,
        "\\rceil": true,
        "\\rfloor": true,
        "\\rgroup": true,
        "\\rmoustache": true,
        "\\right": true,
        "\\bigr": true,
        "\\biggr": true,
        "\\Bigr": true,
        "\\Biggr": true,
        "$": true,
        ";": true,
        ".": true,
        ",": true
      };
      defineMacro2("\\dotso", function(context2) {
        var next = context2.future().text;
        if (next in spaceAfterDots2) {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro2("\\dotsc", function(context2) {
        var next = context2.future().text;
        if (next in spaceAfterDots2 && next !== ",") {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro2("\\cdots", function(context2) {
        var next = context2.future().text;
        if (next in spaceAfterDots2) {
          return "\\@cdots\\,";
        } else {
          return "\\@cdots";
        }
      });
      defineMacro2("\\dotsb", "\\cdots");
      defineMacro2("\\dotsm", "\\cdots");
      defineMacro2("\\dotsi", "\\!\\cdots");
      defineMacro2("\\dotsx", "\\ldots\\,");
      defineMacro2("\\DOTSI", "\\relax");
      defineMacro2("\\DOTSB", "\\relax");
      defineMacro2("\\DOTSX", "\\relax");
      defineMacro2("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
      defineMacro2("\\,", "\\tmspace+{3mu}{.1667em}");
      defineMacro2("\\thinspace", "\\,");
      defineMacro2("\\>", "\\mskip{4mu}");
      defineMacro2("\\:", "\\tmspace+{4mu}{.2222em}");
      defineMacro2("\\medspace", "\\:");
      defineMacro2("\\;", "\\tmspace+{5mu}{.2777em}");
      defineMacro2("\\thickspace", "\\;");
      defineMacro2("\\!", "\\tmspace-{3mu}{.1667em}");
      defineMacro2("\\negthinspace", "\\!");
      defineMacro2("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
      defineMacro2("\\negthickspace", "\\tmspace-{5mu}{.277em}");
      defineMacro2("\\enspace", "\\kern.5em ");
      defineMacro2("\\enskip", "\\hskip.5em\\relax");
      defineMacro2("\\quad", "\\hskip1em\\relax");
      defineMacro2("\\qquad", "\\hskip2em\\relax");
      defineMacro2("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
      defineMacro2("\\tag@paren", "\\tag@literal{({#1})}");
      defineMacro2("\\tag@literal", function(context2) {
        if (context2.macros.get("\\df@tag")) {
          throw new src_ParseError("Multiple \\tag");
        }
        return "\\gdef\\df@tag{\\text{#1}}";
      });
      defineMacro2("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
      defineMacro2("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
      defineMacro2("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
      defineMacro2("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
      defineMacro2("\\pmb", "\\html@mathml{\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}{\\mathbf{#1}}");
      defineMacro2("\\newline", "\\\\\\relax");
      defineMacro2("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
      var latexRaiseA2 = makeEm3(fontMetricsData2["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData2["Main-Regular"]["A".charCodeAt(0)][1]);
      defineMacro2("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA2 + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
      defineMacro2("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA2 + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
      defineMacro2("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
      defineMacro2("\\@hspace", "\\hskip #1\\relax");
      defineMacro2("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
      defineMacro2("\\ordinarycolon", ":");
      defineMacro2("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
      defineMacro2("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
      defineMacro2("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
      defineMacro2("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
      defineMacro2("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
      defineMacro2("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
      defineMacro2("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
      defineMacro2("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
      defineMacro2("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
      defineMacro2("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
      defineMacro2("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
      defineMacro2("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
      defineMacro2("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
      defineMacro2("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
      defineMacro2("\u2237", "\\dblcolon");
      defineMacro2("\u2239", "\\eqcolon");
      defineMacro2("\u2254", "\\coloneqq");
      defineMacro2("\u2255", "\\eqqcolon");
      defineMacro2("\u2A74", "\\Coloneqq");
      defineMacro2("\\ratio", "\\vcentcolon");
      defineMacro2("\\coloncolon", "\\dblcolon");
      defineMacro2("\\colonequals", "\\coloneqq");
      defineMacro2("\\coloncolonequals", "\\Coloneqq");
      defineMacro2("\\equalscolon", "\\eqqcolon");
      defineMacro2("\\equalscoloncolon", "\\Eqqcolon");
      defineMacro2("\\colonminus", "\\coloneq");
      defineMacro2("\\coloncolonminus", "\\Coloneq");
      defineMacro2("\\minuscolon", "\\eqcolon");
      defineMacro2("\\minuscoloncolon", "\\Eqcolon");
      defineMacro2("\\coloncolonapprox", "\\Colonapprox");
      defineMacro2("\\coloncolonsim", "\\Colonsim");
      defineMacro2("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro2("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro2("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro2("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro2("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
      defineMacro2("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
      defineMacro2("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
      defineMacro2("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
      defineMacro2("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
      defineMacro2("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
      defineMacro2("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
      defineMacro2("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
      defineMacro2("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
      defineMacro2("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
      defineMacro2("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
      defineMacro2("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
      defineMacro2("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
      defineMacro2("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
      defineMacro2("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
      defineMacro2("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
      defineMacro2("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
      defineMacro2("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
      defineMacro2("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
      defineMacro2("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
      defineMacro2("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
      defineMacro2("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
      defineMacro2("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
      defineMacro2("\\imath", "\\html@mathml{\\@imath}{\u0131}");
      defineMacro2("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
      defineMacro2("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
      defineMacro2("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
      defineMacro2("\u27E6", "\\llbracket");
      defineMacro2("\u27E7", "\\rrbracket");
      defineMacro2("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
      defineMacro2("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
      defineMacro2("\u2983", "\\lBrace");
      defineMacro2("\u2984", "\\rBrace");
      defineMacro2("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
      defineMacro2("\u29B5", "\\minuso");
      defineMacro2("\\darr", "\\downarrow");
      defineMacro2("\\dArr", "\\Downarrow");
      defineMacro2("\\Darr", "\\Downarrow");
      defineMacro2("\\lang", "\\langle");
      defineMacro2("\\rang", "\\rangle");
      defineMacro2("\\uarr", "\\uparrow");
      defineMacro2("\\uArr", "\\Uparrow");
      defineMacro2("\\Uarr", "\\Uparrow");
      defineMacro2("\\N", "\\mathbb{N}");
      defineMacro2("\\R", "\\mathbb{R}");
      defineMacro2("\\Z", "\\mathbb{Z}");
      defineMacro2("\\alef", "\\aleph");
      defineMacro2("\\alefsym", "\\aleph");
      defineMacro2("\\Alpha", "\\mathrm{A}");
      defineMacro2("\\Beta", "\\mathrm{B}");
      defineMacro2("\\bull", "\\bullet");
      defineMacro2("\\Chi", "\\mathrm{X}");
      defineMacro2("\\clubs", "\\clubsuit");
      defineMacro2("\\cnums", "\\mathbb{C}");
      defineMacro2("\\Complex", "\\mathbb{C}");
      defineMacro2("\\Dagger", "\\ddagger");
      defineMacro2("\\diamonds", "\\diamondsuit");
      defineMacro2("\\empty", "\\emptyset");
      defineMacro2("\\Epsilon", "\\mathrm{E}");
      defineMacro2("\\Eta", "\\mathrm{H}");
      defineMacro2("\\exist", "\\exists");
      defineMacro2("\\harr", "\\leftrightarrow");
      defineMacro2("\\hArr", "\\Leftrightarrow");
      defineMacro2("\\Harr", "\\Leftrightarrow");
      defineMacro2("\\hearts", "\\heartsuit");
      defineMacro2("\\image", "\\Im");
      defineMacro2("\\infin", "\\infty");
      defineMacro2("\\Iota", "\\mathrm{I}");
      defineMacro2("\\isin", "\\in");
      defineMacro2("\\Kappa", "\\mathrm{K}");
      defineMacro2("\\larr", "\\leftarrow");
      defineMacro2("\\lArr", "\\Leftarrow");
      defineMacro2("\\Larr", "\\Leftarrow");
      defineMacro2("\\lrarr", "\\leftrightarrow");
      defineMacro2("\\lrArr", "\\Leftrightarrow");
      defineMacro2("\\Lrarr", "\\Leftrightarrow");
      defineMacro2("\\Mu", "\\mathrm{M}");
      defineMacro2("\\natnums", "\\mathbb{N}");
      defineMacro2("\\Nu", "\\mathrm{N}");
      defineMacro2("\\Omicron", "\\mathrm{O}");
      defineMacro2("\\plusmn", "\\pm");
      defineMacro2("\\rarr", "\\rightarrow");
      defineMacro2("\\rArr", "\\Rightarrow");
      defineMacro2("\\Rarr", "\\Rightarrow");
      defineMacro2("\\real", "\\Re");
      defineMacro2("\\reals", "\\mathbb{R}");
      defineMacro2("\\Reals", "\\mathbb{R}");
      defineMacro2("\\Rho", "\\mathrm{P}");
      defineMacro2("\\sdot", "\\cdot");
      defineMacro2("\\sect", "\\S");
      defineMacro2("\\spades", "\\spadesuit");
      defineMacro2("\\sub", "\\subset");
      defineMacro2("\\sube", "\\subseteq");
      defineMacro2("\\supe", "\\supseteq");
      defineMacro2("\\Tau", "\\mathrm{T}");
      defineMacro2("\\thetasym", "\\vartheta");
      defineMacro2("\\weierp", "\\wp");
      defineMacro2("\\Zeta", "\\mathrm{Z}");
      defineMacro2("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
      defineMacro2("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
      defineMacro2("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
      defineMacro2("\\bra", "\\mathinner{\\langle{#1}|}");
      defineMacro2("\\ket", "\\mathinner{|{#1}\\rangle}");
      defineMacro2("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
      defineMacro2("\\Bra", "\\left\\langle#1\\right|");
      defineMacro2("\\Ket", "\\left|#1\\right\\rangle");
      defineMacro2("\\angln", "{\\angl n}");
      defineMacro2("\\blue", "\\textcolor{##6495ed}{#1}");
      defineMacro2("\\orange", "\\textcolor{##ffa500}{#1}");
      defineMacro2("\\pink", "\\textcolor{##ff00af}{#1}");
      defineMacro2("\\red", "\\textcolor{##df0030}{#1}");
      defineMacro2("\\green", "\\textcolor{##28ae7b}{#1}");
      defineMacro2("\\gray", "\\textcolor{gray}{#1}");
      defineMacro2("\\purple", "\\textcolor{##9d38bd}{#1}");
      defineMacro2("\\blueA", "\\textcolor{##ccfaff}{#1}");
      defineMacro2("\\blueB", "\\textcolor{##80f6ff}{#1}");
      defineMacro2("\\blueC", "\\textcolor{##63d9ea}{#1}");
      defineMacro2("\\blueD", "\\textcolor{##11accd}{#1}");
      defineMacro2("\\blueE", "\\textcolor{##0c7f99}{#1}");
      defineMacro2("\\tealA", "\\textcolor{##94fff5}{#1}");
      defineMacro2("\\tealB", "\\textcolor{##26edd5}{#1}");
      defineMacro2("\\tealC", "\\textcolor{##01d1c1}{#1}");
      defineMacro2("\\tealD", "\\textcolor{##01a995}{#1}");
      defineMacro2("\\tealE", "\\textcolor{##208170}{#1}");
      defineMacro2("\\greenA", "\\textcolor{##b6ffb0}{#1}");
      defineMacro2("\\greenB", "\\textcolor{##8af281}{#1}");
      defineMacro2("\\greenC", "\\textcolor{##74cf70}{#1}");
      defineMacro2("\\greenD", "\\textcolor{##1fab54}{#1}");
      defineMacro2("\\greenE", "\\textcolor{##0d923f}{#1}");
      defineMacro2("\\goldA", "\\textcolor{##ffd0a9}{#1}");
      defineMacro2("\\goldB", "\\textcolor{##ffbb71}{#1}");
      defineMacro2("\\goldC", "\\textcolor{##ff9c39}{#1}");
      defineMacro2("\\goldD", "\\textcolor{##e07d10}{#1}");
      defineMacro2("\\goldE", "\\textcolor{##a75a05}{#1}");
      defineMacro2("\\redA", "\\textcolor{##fca9a9}{#1}");
      defineMacro2("\\redB", "\\textcolor{##ff8482}{#1}");
      defineMacro2("\\redC", "\\textcolor{##f9685d}{#1}");
      defineMacro2("\\redD", "\\textcolor{##e84d39}{#1}");
      defineMacro2("\\redE", "\\textcolor{##bc2612}{#1}");
      defineMacro2("\\maroonA", "\\textcolor{##ffbde0}{#1}");
      defineMacro2("\\maroonB", "\\textcolor{##ff92c6}{#1}");
      defineMacro2("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
      defineMacro2("\\maroonD", "\\textcolor{##ca337c}{#1}");
      defineMacro2("\\maroonE", "\\textcolor{##9e034e}{#1}");
      defineMacro2("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
      defineMacro2("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
      defineMacro2("\\purpleC", "\\textcolor{##aa87ff}{#1}");
      defineMacro2("\\purpleD", "\\textcolor{##7854ab}{#1}");
      defineMacro2("\\purpleE", "\\textcolor{##543b78}{#1}");
      defineMacro2("\\mintA", "\\textcolor{##f5f9e8}{#1}");
      defineMacro2("\\mintB", "\\textcolor{##edf2df}{#1}");
      defineMacro2("\\mintC", "\\textcolor{##e0e5cc}{#1}");
      defineMacro2("\\grayA", "\\textcolor{##f6f7f7}{#1}");
      defineMacro2("\\grayB", "\\textcolor{##f0f1f2}{#1}");
      defineMacro2("\\grayC", "\\textcolor{##e3e5e6}{#1}");
      defineMacro2("\\grayD", "\\textcolor{##d6d8da}{#1}");
      defineMacro2("\\grayE", "\\textcolor{##babec2}{#1}");
      defineMacro2("\\grayF", "\\textcolor{##888d93}{#1}");
      defineMacro2("\\grayG", "\\textcolor{##626569}{#1}");
      defineMacro2("\\grayH", "\\textcolor{##3b3e40}{#1}");
      defineMacro2("\\grayI", "\\textcolor{##21242c}{#1}");
      defineMacro2("\\kaBlue", "\\textcolor{##314453}{#1}");
      defineMacro2("\\kaGreen", "\\textcolor{##71B307}{#1}");
      var implicitCommands2 = {
        "\\relax": true,
        "^": true,
        "_": true,
        "\\limits": true,
        "\\nolimits": true
      };
      var MacroExpander2 = /* @__PURE__ */ function() {
        function MacroExpander3(input, settings, mode) {
          this.settings = void 0;
          this.expansionCount = void 0;
          this.lexer = void 0;
          this.macros = void 0;
          this.stack = void 0;
          this.mode = void 0;
          this.settings = settings;
          this.expansionCount = 0;
          this.feed(input);
          this.macros = new Namespace2(src_macros, settings.macros);
          this.mode = mode;
          this.stack = [];
        }
        var _proto = MacroExpander3.prototype;
        _proto.feed = function feed(input) {
          this.lexer = new Lexer2(input, this.settings);
        };
        _proto.switchMode = function switchMode(newMode) {
          this.mode = newMode;
        };
        _proto.beginGroup = function beginGroup() {
          this.macros.beginGroup();
        };
        _proto.endGroup = function endGroup() {
          this.macros.endGroup();
        };
        _proto.endGroups = function endGroups() {
          this.macros.endGroups();
        };
        _proto.future = function future() {
          if (this.stack.length === 0) {
            this.pushToken(this.lexer.lex());
          }
          return this.stack[this.stack.length - 1];
        };
        _proto.popToken = function popToken() {
          this.future();
          return this.stack.pop();
        };
        _proto.pushToken = function pushToken(token) {
          this.stack.push(token);
        };
        _proto.pushTokens = function pushTokens(tokens) {
          var _this$stack;
          (_this$stack = this.stack).push.apply(_this$stack, tokens);
        };
        _proto.scanArgument = function scanArgument(isOptional) {
          var start;
          var end;
          var tokens;
          if (isOptional) {
            this.consumeSpaces();
            if (this.future().text !== "[") {
              return null;
            }
            start = this.popToken();
            var _this$consumeArg = this.consumeArg(["]"]);
            tokens = _this$consumeArg.tokens;
            end = _this$consumeArg.end;
          } else {
            var _this$consumeArg2 = this.consumeArg();
            tokens = _this$consumeArg2.tokens;
            start = _this$consumeArg2.start;
            end = _this$consumeArg2.end;
          }
          this.pushToken(new Token2("EOF", end.loc));
          this.pushTokens(tokens);
          return start.range(end, "");
        };
        _proto.consumeSpaces = function consumeSpaces() {
          for (; ; ) {
            var token = this.future();
            if (token.text === " ") {
              this.stack.pop();
            } else {
              break;
            }
          }
        };
        _proto.consumeArg = function consumeArg(delims) {
          var tokens = [];
          var isDelimited = delims && delims.length > 0;
          if (!isDelimited) {
            this.consumeSpaces();
          }
          var start = this.future();
          var tok;
          var depth = 0;
          var match2 = 0;
          do {
            tok = this.popToken();
            tokens.push(tok);
            if (tok.text === "{") {
              ++depth;
            } else if (tok.text === "}") {
              --depth;
              if (depth === -1) {
                throw new src_ParseError("Extra }", tok);
              }
            } else if (tok.text === "EOF") {
              throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match2] : "}") + "'", tok);
            }
            if (delims && isDelimited) {
              if ((depth === 0 || depth === 1 && delims[match2] === "{") && tok.text === delims[match2]) {
                ++match2;
                if (match2 === delims.length) {
                  tokens.splice(-match2, match2);
                  break;
                }
              } else {
                match2 = 0;
              }
            }
          } while (depth !== 0 || isDelimited);
          if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
            tokens.pop();
            tokens.shift();
          }
          tokens.reverse();
          return {
            tokens,
            start,
            end: tok
          };
        };
        _proto.consumeArgs = function consumeArgs(numArgs, delimiters3) {
          if (delimiters3) {
            if (delimiters3.length !== numArgs + 1) {
              throw new src_ParseError("The length of delimiters doesn't match the number of args!");
            }
            var delims = delimiters3[0];
            for (var i3 = 0; i3 < delims.length; i3++) {
              var tok = this.popToken();
              if (delims[i3] !== tok.text) {
                throw new src_ParseError("Use of the macro doesn't match its definition", tok);
              }
            }
          }
          var args = [];
          for (var _i7 = 0; _i7 < numArgs; _i7++) {
            args.push(this.consumeArg(delimiters3 && delimiters3[_i7 + 1]).tokens);
          }
          return args;
        };
        _proto.expandOnce = function expandOnce(expandableOnly) {
          var topToken = this.popToken();
          var name = topToken.text;
          var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
          if (expansion == null || expandableOnly && expansion.unexpandable) {
            if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
              throw new src_ParseError("Undefined control sequence: " + name);
            }
            this.pushToken(topToken);
            return topToken;
          }
          this.expansionCount++;
          if (this.expansionCount > this.settings.maxExpand) {
            throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
          }
          var tokens = expansion.tokens;
          var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
          if (expansion.numArgs) {
            tokens = tokens.slice();
            for (var i3 = tokens.length - 1; i3 >= 0; --i3) {
              var tok = tokens[i3];
              if (tok.text === "#") {
                if (i3 === 0) {
                  throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                }
                tok = tokens[--i3];
                if (tok.text === "#") {
                  tokens.splice(i3 + 1, 1);
                } else if (/^[1-9]$/.test(tok.text)) {
                  var _tokens;
                  (_tokens = tokens).splice.apply(_tokens, [i3, 2].concat(args[+tok.text - 1]));
                } else {
                  throw new src_ParseError("Not a valid argument number", tok);
                }
              }
            }
          }
          this.pushTokens(tokens);
          return tokens;
        };
        _proto.expandAfterFuture = function expandAfterFuture() {
          this.expandOnce();
          return this.future();
        };
        _proto.expandNextToken = function expandNextToken() {
          for (; ; ) {
            var expanded = this.expandOnce();
            if (expanded instanceof Token2) {
              if (expanded.text === "\\relax" || expanded.treatAsRelax) {
                this.stack.pop();
              } else {
                return this.stack.pop();
              }
            }
          }
          throw new Error();
        };
        _proto.expandMacro = function expandMacro(name) {
          return this.macros.has(name) ? this.expandTokens([new Token2(name)]) : void 0;
        };
        _proto.expandTokens = function expandTokens(tokens) {
          var output = [];
          var oldStackLength = this.stack.length;
          this.pushTokens(tokens);
          while (this.stack.length > oldStackLength) {
            var expanded = this.expandOnce(true);
            if (expanded instanceof Token2) {
              if (expanded.treatAsRelax) {
                expanded.noexpand = false;
                expanded.treatAsRelax = false;
              }
              output.push(this.stack.pop());
            }
          }
          return output;
        };
        _proto.expandMacroAsText = function expandMacroAsText(name) {
          var tokens = this.expandMacro(name);
          if (tokens) {
            return tokens.map(function(token) {
              return token.text;
            }).join("");
          } else {
            return tokens;
          }
        };
        _proto._getExpansion = function _getExpansion(name) {
          var definition = this.macros.get(name);
          if (definition == null) {
            return definition;
          }
          if (name.length === 1) {
            var catcode = this.lexer.catcodes[name];
            if (catcode != null && catcode !== 13) {
              return;
            }
          }
          var expansion = typeof definition === "function" ? definition(this) : definition;
          if (typeof expansion === "string") {
            var numArgs = 0;
            if (expansion.indexOf("#") !== -1) {
              var stripped = expansion.replace(/##/g, "");
              while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                ++numArgs;
              }
            }
            var bodyLexer = new Lexer2(expansion, this.settings);
            var tokens = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
              tokens.push(tok);
              tok = bodyLexer.lex();
            }
            tokens.reverse();
            var expanded = {
              tokens,
              numArgs
            };
            return expanded;
          }
          return expansion;
        };
        _proto.isDefined = function isDefined(name) {
          return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands2.hasOwnProperty(name);
        };
        _proto.isExpandable = function isExpandable(name) {
          var macro = this.macros.get(name);
          return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
        };
        return MacroExpander3;
      }();
      var unicodeAccents2 = {
        "\u0301": {
          "text": "\\'",
          "math": "\\acute"
        },
        "\u0300": {
          "text": "\\`",
          "math": "\\grave"
        },
        "\u0308": {
          "text": '\\"',
          "math": "\\ddot"
        },
        "\u0303": {
          "text": "\\~",
          "math": "\\tilde"
        },
        "\u0304": {
          "text": "\\=",
          "math": "\\bar"
        },
        "\u0306": {
          "text": "\\u",
          "math": "\\breve"
        },
        "\u030C": {
          "text": "\\v",
          "math": "\\check"
        },
        "\u0302": {
          "text": "\\^",
          "math": "\\hat"
        },
        "\u0307": {
          "text": "\\.",
          "math": "\\dot"
        },
        "\u030A": {
          "text": "\\r",
          "math": "\\mathring"
        },
        "\u030B": {
          "text": "\\H"
        },
        "\u0327": {
          "text": "\\c"
        }
      };
      var unicodeSymbols2 = {
        "\xE1": "a\u0301",
        "\xE0": "a\u0300",
        "\xE4": "a\u0308",
        "\u01DF": "a\u0308\u0304",
        "\xE3": "a\u0303",
        "\u0101": "a\u0304",
        "\u0103": "a\u0306",
        "\u1EAF": "a\u0306\u0301",
        "\u1EB1": "a\u0306\u0300",
        "\u1EB5": "a\u0306\u0303",
        "\u01CE": "a\u030C",
        "\xE2": "a\u0302",
        "\u1EA5": "a\u0302\u0301",
        "\u1EA7": "a\u0302\u0300",
        "\u1EAB": "a\u0302\u0303",
        "\u0227": "a\u0307",
        "\u01E1": "a\u0307\u0304",
        "\xE5": "a\u030A",
        "\u01FB": "a\u030A\u0301",
        "\u1E03": "b\u0307",
        "\u0107": "c\u0301",
        "\u1E09": "c\u0327\u0301",
        "\u010D": "c\u030C",
        "\u0109": "c\u0302",
        "\u010B": "c\u0307",
        "\xE7": "c\u0327",
        "\u010F": "d\u030C",
        "\u1E0B": "d\u0307",
        "\u1E11": "d\u0327",
        "\xE9": "e\u0301",
        "\xE8": "e\u0300",
        "\xEB": "e\u0308",
        "\u1EBD": "e\u0303",
        "\u0113": "e\u0304",
        "\u1E17": "e\u0304\u0301",
        "\u1E15": "e\u0304\u0300",
        "\u0115": "e\u0306",
        "\u1E1D": "e\u0327\u0306",
        "\u011B": "e\u030C",
        "\xEA": "e\u0302",
        "\u1EBF": "e\u0302\u0301",
        "\u1EC1": "e\u0302\u0300",
        "\u1EC5": "e\u0302\u0303",
        "\u0117": "e\u0307",
        "\u0229": "e\u0327",
        "\u1E1F": "f\u0307",
        "\u01F5": "g\u0301",
        "\u1E21": "g\u0304",
        "\u011F": "g\u0306",
        "\u01E7": "g\u030C",
        "\u011D": "g\u0302",
        "\u0121": "g\u0307",
        "\u0123": "g\u0327",
        "\u1E27": "h\u0308",
        "\u021F": "h\u030C",
        "\u0125": "h\u0302",
        "\u1E23": "h\u0307",
        "\u1E29": "h\u0327",
        "\xED": "i\u0301",
        "\xEC": "i\u0300",
        "\xEF": "i\u0308",
        "\u1E2F": "i\u0308\u0301",
        "\u0129": "i\u0303",
        "\u012B": "i\u0304",
        "\u012D": "i\u0306",
        "\u01D0": "i\u030C",
        "\xEE": "i\u0302",
        "\u01F0": "j\u030C",
        "\u0135": "j\u0302",
        "\u1E31": "k\u0301",
        "\u01E9": "k\u030C",
        "\u0137": "k\u0327",
        "\u013A": "l\u0301",
        "\u013E": "l\u030C",
        "\u013C": "l\u0327",
        "\u1E3F": "m\u0301",
        "\u1E41": "m\u0307",
        "\u0144": "n\u0301",
        "\u01F9": "n\u0300",
        "\xF1": "n\u0303",
        "\u0148": "n\u030C",
        "\u1E45": "n\u0307",
        "\u0146": "n\u0327",
        "\xF3": "o\u0301",
        "\xF2": "o\u0300",
        "\xF6": "o\u0308",
        "\u022B": "o\u0308\u0304",
        "\xF5": "o\u0303",
        "\u1E4D": "o\u0303\u0301",
        "\u1E4F": "o\u0303\u0308",
        "\u022D": "o\u0303\u0304",
        "\u014D": "o\u0304",
        "\u1E53": "o\u0304\u0301",
        "\u1E51": "o\u0304\u0300",
        "\u014F": "o\u0306",
        "\u01D2": "o\u030C",
        "\xF4": "o\u0302",
        "\u1ED1": "o\u0302\u0301",
        "\u1ED3": "o\u0302\u0300",
        "\u1ED7": "o\u0302\u0303",
        "\u022F": "o\u0307",
        "\u0231": "o\u0307\u0304",
        "\u0151": "o\u030B",
        "\u1E55": "p\u0301",
        "\u1E57": "p\u0307",
        "\u0155": "r\u0301",
        "\u0159": "r\u030C",
        "\u1E59": "r\u0307",
        "\u0157": "r\u0327",
        "\u015B": "s\u0301",
        "\u1E65": "s\u0301\u0307",
        "\u0161": "s\u030C",
        "\u1E67": "s\u030C\u0307",
        "\u015D": "s\u0302",
        "\u1E61": "s\u0307",
        "\u015F": "s\u0327",
        "\u1E97": "t\u0308",
        "\u0165": "t\u030C",
        "\u1E6B": "t\u0307",
        "\u0163": "t\u0327",
        "\xFA": "u\u0301",
        "\xF9": "u\u0300",
        "\xFC": "u\u0308",
        "\u01D8": "u\u0308\u0301",
        "\u01DC": "u\u0308\u0300",
        "\u01D6": "u\u0308\u0304",
        "\u01DA": "u\u0308\u030C",
        "\u0169": "u\u0303",
        "\u1E79": "u\u0303\u0301",
        "\u016B": "u\u0304",
        "\u1E7B": "u\u0304\u0308",
        "\u016D": "u\u0306",
        "\u01D4": "u\u030C",
        "\xFB": "u\u0302",
        "\u016F": "u\u030A",
        "\u0171": "u\u030B",
        "\u1E7D": "v\u0303",
        "\u1E83": "w\u0301",
        "\u1E81": "w\u0300",
        "\u1E85": "w\u0308",
        "\u0175": "w\u0302",
        "\u1E87": "w\u0307",
        "\u1E98": "w\u030A",
        "\u1E8D": "x\u0308",
        "\u1E8B": "x\u0307",
        "\xFD": "y\u0301",
        "\u1EF3": "y\u0300",
        "\xFF": "y\u0308",
        "\u1EF9": "y\u0303",
        "\u0233": "y\u0304",
        "\u0177": "y\u0302",
        "\u1E8F": "y\u0307",
        "\u1E99": "y\u030A",
        "\u017A": "z\u0301",
        "\u017E": "z\u030C",
        "\u1E91": "z\u0302",
        "\u017C": "z\u0307",
        "\xC1": "A\u0301",
        "\xC0": "A\u0300",
        "\xC4": "A\u0308",
        "\u01DE": "A\u0308\u0304",
        "\xC3": "A\u0303",
        "\u0100": "A\u0304",
        "\u0102": "A\u0306",
        "\u1EAE": "A\u0306\u0301",
        "\u1EB0": "A\u0306\u0300",
        "\u1EB4": "A\u0306\u0303",
        "\u01CD": "A\u030C",
        "\xC2": "A\u0302",
        "\u1EA4": "A\u0302\u0301",
        "\u1EA6": "A\u0302\u0300",
        "\u1EAA": "A\u0302\u0303",
        "\u0226": "A\u0307",
        "\u01E0": "A\u0307\u0304",
        "\xC5": "A\u030A",
        "\u01FA": "A\u030A\u0301",
        "\u1E02": "B\u0307",
        "\u0106": "C\u0301",
        "\u1E08": "C\u0327\u0301",
        "\u010C": "C\u030C",
        "\u0108": "C\u0302",
        "\u010A": "C\u0307",
        "\xC7": "C\u0327",
        "\u010E": "D\u030C",
        "\u1E0A": "D\u0307",
        "\u1E10": "D\u0327",
        "\xC9": "E\u0301",
        "\xC8": "E\u0300",
        "\xCB": "E\u0308",
        "\u1EBC": "E\u0303",
        "\u0112": "E\u0304",
        "\u1E16": "E\u0304\u0301",
        "\u1E14": "E\u0304\u0300",
        "\u0114": "E\u0306",
        "\u1E1C": "E\u0327\u0306",
        "\u011A": "E\u030C",
        "\xCA": "E\u0302",
        "\u1EBE": "E\u0302\u0301",
        "\u1EC0": "E\u0302\u0300",
        "\u1EC4": "E\u0302\u0303",
        "\u0116": "E\u0307",
        "\u0228": "E\u0327",
        "\u1E1E": "F\u0307",
        "\u01F4": "G\u0301",
        "\u1E20": "G\u0304",
        "\u011E": "G\u0306",
        "\u01E6": "G\u030C",
        "\u011C": "G\u0302",
        "\u0120": "G\u0307",
        "\u0122": "G\u0327",
        "\u1E26": "H\u0308",
        "\u021E": "H\u030C",
        "\u0124": "H\u0302",
        "\u1E22": "H\u0307",
        "\u1E28": "H\u0327",
        "\xCD": "I\u0301",
        "\xCC": "I\u0300",
        "\xCF": "I\u0308",
        "\u1E2E": "I\u0308\u0301",
        "\u0128": "I\u0303",
        "\u012A": "I\u0304",
        "\u012C": "I\u0306",
        "\u01CF": "I\u030C",
        "\xCE": "I\u0302",
        "\u0130": "I\u0307",
        "\u0134": "J\u0302",
        "\u1E30": "K\u0301",
        "\u01E8": "K\u030C",
        "\u0136": "K\u0327",
        "\u0139": "L\u0301",
        "\u013D": "L\u030C",
        "\u013B": "L\u0327",
        "\u1E3E": "M\u0301",
        "\u1E40": "M\u0307",
        "\u0143": "N\u0301",
        "\u01F8": "N\u0300",
        "\xD1": "N\u0303",
        "\u0147": "N\u030C",
        "\u1E44": "N\u0307",
        "\u0145": "N\u0327",
        "\xD3": "O\u0301",
        "\xD2": "O\u0300",
        "\xD6": "O\u0308",
        "\u022A": "O\u0308\u0304",
        "\xD5": "O\u0303",
        "\u1E4C": "O\u0303\u0301",
        "\u1E4E": "O\u0303\u0308",
        "\u022C": "O\u0303\u0304",
        "\u014C": "O\u0304",
        "\u1E52": "O\u0304\u0301",
        "\u1E50": "O\u0304\u0300",
        "\u014E": "O\u0306",
        "\u01D1": "O\u030C",
        "\xD4": "O\u0302",
        "\u1ED0": "O\u0302\u0301",
        "\u1ED2": "O\u0302\u0300",
        "\u1ED6": "O\u0302\u0303",
        "\u022E": "O\u0307",
        "\u0230": "O\u0307\u0304",
        "\u0150": "O\u030B",
        "\u1E54": "P\u0301",
        "\u1E56": "P\u0307",
        "\u0154": "R\u0301",
        "\u0158": "R\u030C",
        "\u1E58": "R\u0307",
        "\u0156": "R\u0327",
        "\u015A": "S\u0301",
        "\u1E64": "S\u0301\u0307",
        "\u0160": "S\u030C",
        "\u1E66": "S\u030C\u0307",
        "\u015C": "S\u0302",
        "\u1E60": "S\u0307",
        "\u015E": "S\u0327",
        "\u0164": "T\u030C",
        "\u1E6A": "T\u0307",
        "\u0162": "T\u0327",
        "\xDA": "U\u0301",
        "\xD9": "U\u0300",
        "\xDC": "U\u0308",
        "\u01D7": "U\u0308\u0301",
        "\u01DB": "U\u0308\u0300",
        "\u01D5": "U\u0308\u0304",
        "\u01D9": "U\u0308\u030C",
        "\u0168": "U\u0303",
        "\u1E78": "U\u0303\u0301",
        "\u016A": "U\u0304",
        "\u1E7A": "U\u0304\u0308",
        "\u016C": "U\u0306",
        "\u01D3": "U\u030C",
        "\xDB": "U\u0302",
        "\u016E": "U\u030A",
        "\u0170": "U\u030B",
        "\u1E7C": "V\u0303",
        "\u1E82": "W\u0301",
        "\u1E80": "W\u0300",
        "\u1E84": "W\u0308",
        "\u0174": "W\u0302",
        "\u1E86": "W\u0307",
        "\u1E8C": "X\u0308",
        "\u1E8A": "X\u0307",
        "\xDD": "Y\u0301",
        "\u1EF2": "Y\u0300",
        "\u0178": "Y\u0308",
        "\u1EF8": "Y\u0303",
        "\u0232": "Y\u0304",
        "\u0176": "Y\u0302",
        "\u1E8E": "Y\u0307",
        "\u0179": "Z\u0301",
        "\u017D": "Z\u030C",
        "\u1E90": "Z\u0302",
        "\u017B": "Z\u0307",
        "\u03AC": "\u03B1\u0301",
        "\u1F70": "\u03B1\u0300",
        "\u1FB1": "\u03B1\u0304",
        "\u1FB0": "\u03B1\u0306",
        "\u03AD": "\u03B5\u0301",
        "\u1F72": "\u03B5\u0300",
        "\u03AE": "\u03B7\u0301",
        "\u1F74": "\u03B7\u0300",
        "\u03AF": "\u03B9\u0301",
        "\u1F76": "\u03B9\u0300",
        "\u03CA": "\u03B9\u0308",
        "\u0390": "\u03B9\u0308\u0301",
        "\u1FD2": "\u03B9\u0308\u0300",
        "\u1FD1": "\u03B9\u0304",
        "\u1FD0": "\u03B9\u0306",
        "\u03CC": "\u03BF\u0301",
        "\u1F78": "\u03BF\u0300",
        "\u03CD": "\u03C5\u0301",
        "\u1F7A": "\u03C5\u0300",
        "\u03CB": "\u03C5\u0308",
        "\u03B0": "\u03C5\u0308\u0301",
        "\u1FE2": "\u03C5\u0308\u0300",
        "\u1FE1": "\u03C5\u0304",
        "\u1FE0": "\u03C5\u0306",
        "\u03CE": "\u03C9\u0301",
        "\u1F7C": "\u03C9\u0300",
        "\u038E": "\u03A5\u0301",
        "\u1FEA": "\u03A5\u0300",
        "\u03AB": "\u03A5\u0308",
        "\u1FE9": "\u03A5\u0304",
        "\u1FE8": "\u03A5\u0306",
        "\u038F": "\u03A9\u0301",
        "\u1FFA": "\u03A9\u0300"
      };
      var Parser2 = /* @__PURE__ */ function() {
        function Parser3(input, settings) {
          this.mode = void 0;
          this.gullet = void 0;
          this.settings = void 0;
          this.leftrightDepth = void 0;
          this.nextToken = void 0;
          this.mode = "math";
          this.gullet = new MacroExpander2(input, settings, this.mode);
          this.settings = settings;
          this.leftrightDepth = 0;
        }
        var _proto = Parser3.prototype;
        _proto.expect = function expect(text2, consume) {
          if (consume === void 0) {
            consume = true;
          }
          if (this.fetch().text !== text2) {
            throw new src_ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
          }
          if (consume) {
            this.consume();
          }
        };
        _proto.consume = function consume() {
          this.nextToken = null;
        };
        _proto.fetch = function fetch() {
          if (this.nextToken == null) {
            this.nextToken = this.gullet.expandNextToken();
          }
          return this.nextToken;
        };
        _proto.switchMode = function switchMode(newMode) {
          this.mode = newMode;
          this.gullet.switchMode(newMode);
        };
        _proto.parse = function parse() {
          if (!this.settings.globalGroup) {
            this.gullet.beginGroup();
          }
          if (this.settings.colorIsTextColor) {
            this.gullet.macros.set("\\color", "\\textcolor");
          }
          try {
            var parse2 = this.parseExpression(false);
            this.expect("EOF");
            if (!this.settings.globalGroup) {
              this.gullet.endGroup();
            }
            return parse2;
          } finally {
            this.gullet.endGroups();
          }
        };
        _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {
          var body = [];
          while (true) {
            if (this.mode === "math") {
              this.consumeSpaces();
            }
            var lex = this.fetch();
            if (Parser3.endOfExpression.indexOf(lex.text) !== -1) {
              break;
            }
            if (breakOnTokenText && lex.text === breakOnTokenText) {
              break;
            }
            if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
              break;
            }
            var atom = this.parseAtom(breakOnTokenText);
            if (!atom) {
              break;
            } else if (atom.type === "internal") {
              continue;
            }
            body.push(atom);
          }
          if (this.mode === "text") {
            this.formLigatures(body);
          }
          return this.handleInfixNodes(body);
        };
        _proto.handleInfixNodes = function handleInfixNodes(body) {
          var overIndex = -1;
          var funcName;
          for (var i3 = 0; i3 < body.length; i3++) {
            if (body[i3].type === "infix") {
              if (overIndex !== -1) {
                throw new src_ParseError("only one infix operator per group", body[i3].token);
              }
              overIndex = i3;
              funcName = body[i3].replaceWith;
            }
          }
          if (overIndex !== -1 && funcName) {
            var numerNode;
            var denomNode;
            var numerBody = body.slice(0, overIndex);
            var denomBody = body.slice(overIndex + 1);
            if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
              numerNode = numerBody[0];
            } else {
              numerNode = {
                type: "ordgroup",
                mode: this.mode,
                body: numerBody
              };
            }
            if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
              denomNode = denomBody[0];
            } else {
              denomNode = {
                type: "ordgroup",
                mode: this.mode,
                body: denomBody
              };
            }
            var node;
            if (funcName === "\\\\abovefrac") {
              node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
            } else {
              node = this.callFunction(funcName, [numerNode, denomNode], []);
            }
            return [node];
          } else {
            return body;
          }
        };
        _proto.handleSupSubscript = function handleSupSubscript(name) {
          var symbolToken = this.fetch();
          var symbol = symbolToken.text;
          this.consume();
          this.consumeSpaces();
          var group = this.parseGroup(name);
          if (!group) {
            throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
          }
          return group;
        };
        _proto.formatUnsupportedCmd = function formatUnsupportedCmd(text2) {
          var textordArray = [];
          for (var i3 = 0; i3 < text2.length; i3++) {
            textordArray.push({
              type: "textord",
              mode: "text",
              text: text2[i3]
            });
          }
          var textNode = {
            type: "text",
            mode: this.mode,
            body: textordArray
          };
          var colorNode = {
            type: "color",
            mode: this.mode,
            color: this.settings.errorColor,
            body: [textNode]
          };
          return colorNode;
        };
        _proto.parseAtom = function parseAtom(breakOnTokenText) {
          var base2 = this.parseGroup("atom", breakOnTokenText);
          if (this.mode === "text") {
            return base2;
          }
          var superscript;
          var subscript;
          while (true) {
            this.consumeSpaces();
            var lex = this.fetch();
            if (lex.text === "\\limits" || lex.text === "\\nolimits") {
              if (base2 && base2.type === "op") {
                var limits = lex.text === "\\limits";
                base2.limits = limits;
                base2.alwaysHandleSupSub = true;
              } else if (base2 && base2.type === "operatorname") {
                if (base2.alwaysHandleSupSub) {
                  base2.limits = lex.text === "\\limits";
                }
              } else {
                throw new src_ParseError("Limit controls must follow a math operator", lex);
              }
              this.consume();
            } else if (lex.text === "^") {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              superscript = this.handleSupSubscript("superscript");
            } else if (lex.text === "_") {
              if (subscript) {
                throw new src_ParseError("Double subscript", lex);
              }
              subscript = this.handleSupSubscript("subscript");
            } else if (lex.text === "'") {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              var prime2 = {
                type: "textord",
                mode: this.mode,
                text: "\\prime"
              };
              var primes2 = [prime2];
              this.consume();
              while (this.fetch().text === "'") {
                primes2.push(prime2);
                this.consume();
              }
              if (this.fetch().text === "^") {
                primes2.push(this.handleSupSubscript("superscript"));
              }
              superscript = {
                type: "ordgroup",
                mode: this.mode,
                body: primes2
              };
            } else {
              break;
            }
          }
          if (superscript || subscript) {
            return {
              type: "supsub",
              mode: this.mode,
              base: base2,
              sup: superscript,
              sub: subscript
            };
          } else {
            return base2;
          }
        };
        _proto.parseFunction = function parseFunction(breakOnTokenText, name) {
          var token = this.fetch();
          var func = token.text;
          var funcData = src_functions[func];
          if (!funcData) {
            return null;
          }
          this.consume();
          if (name && name !== "atom" && !funcData.allowedInArgument) {
            throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
          } else if (this.mode === "text" && !funcData.allowedInText) {
            throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
          } else if (this.mode === "math" && funcData.allowedInMath === false) {
            throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
          }
          var _this$parseArguments = this.parseArguments(func, funcData), args = _this$parseArguments.args, optArgs = _this$parseArguments.optArgs;
          return this.callFunction(func, args, optArgs, token, breakOnTokenText);
        };
        _proto.callFunction = function callFunction(name, args, optArgs, token, breakOnTokenText) {
          var context2 = {
            funcName: name,
            parser: this,
            token,
            breakOnTokenText
          };
          var func = src_functions[name];
          if (func && func.handler) {
            return func.handler(context2, args, optArgs);
          } else {
            throw new src_ParseError("No function handler for " + name);
          }
        };
        _proto.parseArguments = function parseArguments(func, funcData) {
          var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
          if (totalArgs === 0) {
            return {
              args: [],
              optArgs: []
            };
          }
          var args = [];
          var optArgs = [];
          for (var i3 = 0; i3 < totalArgs; i3++) {
            var argType = funcData.argTypes && funcData.argTypes[i3];
            var isOptional = i3 < funcData.numOptionalArgs;
            if (funcData.primitive && argType == null || funcData.type === "sqrt" && i3 === 1 && optArgs[0] == null) {
              argType = "primitive";
            }
            var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
            if (isOptional) {
              optArgs.push(arg);
            } else if (arg != null) {
              args.push(arg);
            } else {
              throw new src_ParseError("Null argument, please report this as a bug");
            }
          }
          return {
            args,
            optArgs
          };
        };
        _proto.parseGroupOfType = function parseGroupOfType(name, type, optional) {
          switch (type) {
            case "color":
              return this.parseColorGroup(optional);
            case "size":
              return this.parseSizeGroup(optional);
            case "url":
              return this.parseUrlGroup(optional);
            case "math":
            case "text":
              return this.parseArgumentGroup(optional, type);
            case "hbox": {
              var group = this.parseArgumentGroup(optional, "text");
              return group != null ? {
                type: "styling",
                mode: group.mode,
                body: [group],
                style: "text"
              } : null;
            }
            case "raw": {
              var token = this.parseStringGroup("raw", optional);
              return token != null ? {
                type: "raw",
                mode: "text",
                string: token.text
              } : null;
            }
            case "primitive": {
              if (optional) {
                throw new src_ParseError("A primitive argument cannot be optional");
              }
              var _group = this.parseGroup(name);
              if (_group == null) {
                throw new src_ParseError("Expected group as " + name, this.fetch());
              }
              return _group;
            }
            case "original":
            case null:
            case void 0:
              return this.parseArgumentGroup(optional);
            default:
              throw new src_ParseError("Unknown group type as " + name, this.fetch());
          }
        };
        _proto.consumeSpaces = function consumeSpaces() {
          while (this.fetch().text === " ") {
            this.consume();
          }
        };
        _proto.parseStringGroup = function parseStringGroup(modeName, optional) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var str2 = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF") {
            str2 += nextToken.text;
            this.consume();
          }
          this.consume();
          argToken.text = str2;
          return argToken;
        };
        _proto.parseRegexGroup = function parseRegexGroup(regex, modeName) {
          var firstToken = this.fetch();
          var lastToken = firstToken;
          var str2 = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str2 + nextToken.text)) {
            lastToken = nextToken;
            str2 += lastToken.text;
            this.consume();
          }
          if (str2 === "") {
            throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
          }
          return firstToken.range(lastToken, str2);
        };
        _proto.parseColorGroup = function parseColorGroup(optional) {
          var res = this.parseStringGroup("color", optional);
          if (res == null) {
            return null;
          }
          var match2 = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
          if (!match2) {
            throw new src_ParseError("Invalid color: '" + res.text + "'", res);
          }
          var color = match2[0];
          if (/^[0-9a-f]{6}$/i.test(color)) {
            color = "#" + color;
          }
          return {
            type: "color-token",
            mode: this.mode,
            color
          };
        };
        _proto.parseSizeGroup = function parseSizeGroup(optional) {
          var res;
          var isBlank = false;
          this.gullet.consumeSpaces();
          if (!optional && this.gullet.future().text !== "{") {
            res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
          } else {
            res = this.parseStringGroup("size", optional);
          }
          if (!res) {
            return null;
          }
          if (!optional && res.text.length === 0) {
            res.text = "0pt";
            isBlank = true;
          }
          var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
          if (!match2) {
            throw new src_ParseError("Invalid size: '" + res.text + "'", res);
          }
          var data2 = {
            number: +(match2[1] + match2[2]),
            unit: match2[3]
          };
          if (!validUnit3(data2)) {
            throw new src_ParseError("Invalid unit: '" + data2.unit + "'", res);
          }
          return {
            type: "size",
            mode: this.mode,
            value: data2,
            isBlank
          };
        };
        _proto.parseUrlGroup = function parseUrlGroup(optional) {
          this.gullet.lexer.setCatcode("%", 13);
          this.gullet.lexer.setCatcode("~", 12);
          var res = this.parseStringGroup("url", optional);
          this.gullet.lexer.setCatcode("%", 14);
          this.gullet.lexer.setCatcode("~", 13);
          if (res == null) {
            return null;
          }
          var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
          return {
            type: "url",
            mode: this.mode,
            url
          };
        };
        _proto.parseArgumentGroup = function parseArgumentGroup(optional, mode) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var outerMode = this.mode;
          if (mode) {
            this.switchMode(mode);
          }
          this.gullet.beginGroup();
          var expression = this.parseExpression(false, "EOF");
          this.expect("EOF");
          this.gullet.endGroup();
          var result2 = {
            type: "ordgroup",
            mode: this.mode,
            loc: argToken.loc,
            body: expression
          };
          if (mode) {
            this.switchMode(outerMode);
          }
          return result2;
        };
        _proto.parseGroup = function parseGroup(name, breakOnTokenText) {
          var firstToken = this.fetch();
          var text2 = firstToken.text;
          var result2;
          if (text2 === "{" || text2 === "\\begingroup") {
            this.consume();
            var groupEnd = text2 === "{" ? "}" : "\\endgroup";
            this.gullet.beginGroup();
            var expression = this.parseExpression(false, groupEnd);
            var lastToken = this.fetch();
            this.expect(groupEnd);
            this.gullet.endGroup();
            result2 = {
              type: "ordgroup",
              mode: this.mode,
              loc: SourceLocation2.range(firstToken, lastToken),
              body: expression,
              semisimple: text2 === "\\begingroup" || void 0
            };
          } else {
            result2 = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
            if (result2 == null && text2[0] === "\\" && !implicitCommands2.hasOwnProperty(text2)) {
              if (this.settings.throwOnError) {
                throw new src_ParseError("Undefined control sequence: " + text2, firstToken);
              }
              result2 = this.formatUnsupportedCmd(text2);
              this.consume();
            }
          }
          return result2;
        };
        _proto.formLigatures = function formLigatures(group) {
          var n2 = group.length - 1;
          for (var i3 = 0; i3 < n2; ++i3) {
            var a2 = group[i3];
            var v2 = a2.text;
            if (v2 === "-" && group[i3 + 1].text === "-") {
              if (i3 + 1 < n2 && group[i3 + 2].text === "-") {
                group.splice(i3, 3, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation2.range(a2, group[i3 + 2]),
                  text: "---"
                });
                n2 -= 2;
              } else {
                group.splice(i3, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation2.range(a2, group[i3 + 1]),
                  text: "--"
                });
                n2 -= 1;
              }
            }
            if ((v2 === "'" || v2 === "`") && group[i3 + 1].text === v2) {
              group.splice(i3, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation2.range(a2, group[i3 + 1]),
                text: v2 + v2
              });
              n2 -= 1;
            }
          }
        };
        _proto.parseSymbol = function parseSymbol() {
          var nucleus = this.fetch();
          var text2 = nucleus.text;
          if (/^\\verb[^a-zA-Z]/.test(text2)) {
            this.consume();
            var arg = text2.slice(5);
            var star = arg.charAt(0) === "*";
            if (star) {
              arg = arg.slice(1);
            }
            if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
              throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
            }
            arg = arg.slice(1, -1);
            return {
              type: "verb",
              mode: "text",
              body: arg,
              star
            };
          }
          if (unicodeSymbols2.hasOwnProperty(text2[0]) && !src_symbols[this.mode][text2[0]]) {
            if (this.settings.strict && this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
            }
            text2 = unicodeSymbols2[text2[0]] + text2.substr(1);
          }
          var match2 = combiningDiacriticalMarksEndRegex2.exec(text2);
          if (match2) {
            text2 = text2.substring(0, match2.index);
            if (text2 === "i") {
              text2 = "\u0131";
            } else if (text2 === "j") {
              text2 = "\u0237";
            }
          }
          var symbol;
          if (src_symbols[this.mode][text2]) {
            if (this.settings.strict && this.mode === "math" && extraLatin2.indexOf(text2) >= 0) {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
            }
            var group = src_symbols[this.mode][text2].group;
            var loc = SourceLocation2.range(nucleus);
            var s2;
            if (ATOMS2.hasOwnProperty(group)) {
              var family = group;
              s2 = {
                type: "atom",
                mode: this.mode,
                family,
                loc,
                text: text2
              };
            } else {
              s2 = {
                type: group,
                mode: this.mode,
                loc,
                text: text2
              };
            }
            symbol = s2;
          } else if (text2.charCodeAt(0) >= 128) {
            if (this.settings.strict) {
              if (!supportedCodepoint2(text2.charCodeAt(0))) {
                this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
              } else if (this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
              }
            }
            symbol = {
              type: "textord",
              mode: "text",
              loc: SourceLocation2.range(nucleus),
              text: text2
            };
          } else {
            return null;
          }
          this.consume();
          if (match2) {
            for (var i3 = 0; i3 < match2[0].length; i3++) {
              var accent3 = match2[0][i3];
              if (!unicodeAccents2[accent3]) {
                throw new src_ParseError("Unknown accent ' " + accent3 + "'", nucleus);
              }
              var command = unicodeAccents2[accent3][this.mode] || unicodeAccents2[accent3].text;
              if (!command) {
                throw new src_ParseError("Accent " + accent3 + " unsupported in " + this.mode + " mode", nucleus);
              }
              symbol = {
                type: "accent",
                mode: this.mode,
                loc: SourceLocation2.range(nucleus),
                label: command,
                isStretchy: false,
                isShifty: true,
                base: symbol
              };
            }
          }
          return symbol;
        };
        return Parser3;
      }();
      Parser2.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
      var parseTree3 = function parseTree4(toParse, settings) {
        if (!(typeof toParse === "string" || toParse instanceof String)) {
          throw new TypeError("KaTeX can only parse string typed expression");
        }
        var parser = new Parser2(toParse, settings);
        delete parser.gullet.macros.current["\\df@tag"];
        var tree = parser.parse();
        delete parser.gullet.macros.current["\\current@color"];
        delete parser.gullet.macros.current["\\color"];
        if (parser.gullet.macros.get("\\df@tag")) {
          if (!settings.displayMode) {
            throw new src_ParseError("\\tag works only in display equations");
          }
          parser.gullet.feed("\\df@tag");
          tree = [{
            type: "tag",
            mode: "text",
            body: tree,
            tag: parser.parse()
          }];
        }
        return tree;
      };
      var src_parseTree = parseTree3;
      var render3 = function render4(expression, baseNode, options2) {
        baseNode.textContent = "";
        var node = renderToDomTree3(expression, options2).toNode();
        baseNode.appendChild(node);
      };
      if (typeof document !== "undefined") {
        if (document.compatMode !== "CSS1Compat") {
          typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
          render3 = function render4() {
            throw new src_ParseError("KaTeX doesn't work in quirks mode.");
          };
        }
      }
      var renderToString3 = function renderToString4(expression, options2) {
        var markup = renderToDomTree3(expression, options2).toMarkup();
        return markup;
      };
      var generateParseTree3 = function generateParseTree4(expression, options2) {
        var settings = new Settings2(options2);
        return src_parseTree(expression, settings);
      };
      var renderError3 = function renderError4(error2, expression, options2) {
        if (options2.throwOnError || !(error2 instanceof src_ParseError)) {
          throw error2;
        }
        var node = buildCommon2.makeSpan(["katex-error"], [new SymbolNode2(expression)]);
        node.setAttribute("title", error2.toString());
        node.setAttribute("style", "color:" + options2.errorColor);
        return node;
      };
      var renderToDomTree3 = function renderToDomTree4(expression, options2) {
        var settings = new Settings2(options2);
        try {
          var tree = src_parseTree(expression, settings);
          return buildTree3(tree, expression, settings);
        } catch (error2) {
          return renderError3(error2, expression, settings);
        }
      };
      var renderToHTMLTree3 = function renderToHTMLTree4(expression, options2) {
        var settings = new Settings2(options2);
        try {
          var tree = src_parseTree(expression, settings);
          return buildHTMLTree3(tree, expression, settings);
        } catch (error2) {
          return renderError3(error2, expression, settings);
        }
      };
      var katex2 = {
        version: "0.13.24",
        render: render3,
        renderToString: renderToString3,
        ParseError: src_ParseError,
        __parse: generateParseTree3,
        __renderToDomTree: renderToDomTree3,
        __renderToHTMLTree: renderToHTMLTree3,
        __setFontMetrics: setFontMetrics2,
        __defineSymbol: defineSymbol2,
        __defineMacro: defineMacro2,
        __domTree: {
          Span: Span2,
          Anchor: Anchor2,
          SymbolNode: SymbolNode2,
          SvgNode: SvgNode2,
          PathNode: PathNode2,
          LineNode: LineNode2
        }
      };
      var katex_webpack = katex2;
      __webpack_exports__ = __webpack_exports__["default"];
      return __webpack_exports__;
    }();
  });
})(katex);
var katexObj = katex.exports;
globalThis.katex = katexObj;
function at(n2) {
  n2 = Math.trunc(n2) || 0;
  if (n2 < 0)
    n2 += this.length;
  if (n2 < 0 || n2 >= this.length)
    return void 0;
  return this[n2];
}
const TypedArray = Reflect.getPrototypeOf(Int8Array);
for (const C2 of [Array, String, TypedArray]) {
  Object.defineProperty(C2.prototype, "at", {
    value: at,
    writable: true,
    enumerable: false,
    configurable: true
  });
}
